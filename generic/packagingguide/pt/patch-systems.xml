<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" 
        "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % globalent SYSTEM "../../../libs/global.ent">
%globalent;
<!ENTITY % cdo-C SYSTEM "../../../libs/cdo-C.ent">
%cdo-C;
<!ENTITY % pg-common SYSTEM "../pg-common.ent">
%pg-common;
<!ENTITY % xinclude SYSTEM "../../../libs/xinclude.mod">
%xinclude;
<!ENTITY language "en">
<!ENTITY ubuntu '<phrase>Ubuntu</phrase>'>
]>
<chapter id="ps-chap" status="writing">
        <title>Patch Systems</title>
        <para>Quite often it turns out that the upstream source needs to be patched, either to adjust the program to work with Ubuntu or to fix bugs in the source before they are fixed upstream. But how should we reperesent these changes? We could simply make the changes in the unpacked source package, in which case the patch would be expressed in the <filename>.diff.gz</filename> file. However, this is not ideal. If there is more than one patch you loose the ability to seperate the patches as you just see one big diff that also contains the packaging files (in <filename>debian/</filename>. This can make it more difficult when you want to send the patches upstream. It is also very convenient to seperate the author's source from the changes made for Ubuntu. The best place to put this information is in the <filename>debian/</filename> that is already used for the packaging files. For the rest of this chapter we will be looking at the various ways to set up patches in this way.</para>
	
	<sect1 id="ps-scratch" status="writing">
		<title>Patching Without a Patch System</title>
		<para>Como mencionado em cima, podemos corrigir a fonte original fazendo simplesmente as mudanças na directoria fonte descompactada. Um exemplo real disto é o <application>cron</application>. Se obter o pacote fonte do <application>cron</application> e analisar o <filename>.diff.gz</filename> verá que vários ficheiros fonte do pacote original foram mudados.</para>

		<screen>
apt-get source cron
zgrep +++ cron*.diff.gz
</screen>

		<para>But as we mentioned before this is not really the best way to represent patches. One better way is to create individual patch files, but them in <filename>debian/patches/</filename> and apply the patches (using <application>patch</application>) in <filename>debian/rules</filename>. This is what is done for <application>udev</application>:</para>
		
		<screen>
apt-get source udev
zgrep +++ udev*.diff.gz
ls udev*/debian/patches/
less udev*/debian/rules
</screen>
		
		<para>O ficheiro de <filename>regras</filename> tem as regras seguintes para aplicar e não aplicar correcções:</para>
		<screen>
# Apply patches to the package
patch: patch-stamp
patch-stamp:
       dh_testdir
       @patches=debian/patches/*.patch; for patch in $$patches; do \
               test -f $$patch || continue; \
               echo "Applying $$patch"; \
               patch -stuN -p1 &lt; $$patch || exit 1; \
       done
       touch $@

# Remove patches from the package
unpatch:
       dh_testdir
       @if test -f patch-stamp; then \
               patches=debian/patches/*.patch; \
               for patch in $$patches; do \
                      reversepatches="$$patch $$reversepatches"; \
               done; \
               for patch in $$reversepatches; do \
                      test -f $$patch || continue; \
                      echo "Reversing $$patch"; \
                      patch -suRf -p1 &lt; $$patch || exit 1; \
               done; \
               rm -f patch-stamp; \
       fi
</screen>
	
		<para>É tudo muito bonito, mas como criamos novas correcções para o <application>udev</application> usando este esquema? A abordagem genérica é:</para>
		<orderedlist>
			<listitem><para>copy the clean source tree to a temporary directory</para></listitem>
			<listitem><para>aplicar todas as correcções até aquela que quer editar; se quiser criar uma nova correcção, aplique todas as existentes (isto é necessário visto que as correcções genéricas dependem de correcções anteriores)</para>
			<para>if you want, you can use debian/rules for this: remove the patches that come *after* the one you want to edit, and call 'debian/rules patch'. The actual name for the patch target varies, I have seen the following ones so far: patch setup apply-patches unpack patch-stamp. You have to look in <filename>debian/rules</filename> how it is called.</para></listitem>
			<listitem><para>copie toda a árvore fonte outra vez: <screen>cp -a /tmp/old /tmp/new</screen></para></listitem>
			<listitem><para>va até /tmp/new, e faça as suas modificações</para></listitem>
			<listitem><para>regresse à sua árvore fonte, gere a correcção com: <screen>diff -Nurp /tmp/old /tmp/new &gt; mypatchname.patch</screen></para></listitem>
		</orderedlist>

		
		<sect2>
			<title>Exemplo 1.</title>
			<para>Let us make a new patch for <application>udev</application> called <filename>90_penguins.patch</filename> which replaces <emphasis>Linux</emphasis> with <emphasis>Penguin</emphasis> in the <application>udev</application> <filename>README</filename> file:</para>
			<screen>
cd udev*/
cp -a . /tmp/old
pushd /tmp/old
debian/rules patch
cp -a . /tmp/new; cd ../new
sed -i 's/Linux/Penguin/g' README
cd ..
diff -Nurp old new &gt; 90_penguins.patch
popd
mv /tmp/90_penguins.patch debian/patches
rm -rf /tmp/old /tmp/new
</screen>
		</sect2>
		
		<sect2>
			<title>Exemplo 2.</title>
			<para>O que acontece se quisermos editar uma correcção existente? Podemos usar um procedimento semelhante como no Exemplo 1 mas iremos aplicar a correcção após a editar primeiro: <screen>
cp -a . /tmp/old
pushd /tmp/old
cp -a . /tmp/new; cd ../new
patch -p1 &lt; debian/patches/10-selinux-include-udev-h.patch
sed -i '1 s/$/***** HELLO WORLD ****/' udev_selinux.c
cd ..
diff -Nurp old new &gt; 10-selinux-include-udev-h.patch
popd
mv /tmp/10-selinux-include-udev-h.patch debian/patches
rm -rf /tmp/old /tmp/new

</screen></para>
			<para>So this way of patching the source, while technically fine, can become very complicated and unmanageable. To make patching easier and more straightforward patch systems were developed. We will take a look at couple popular ones.</para>
		</sect2>
	</sect1>
	<sect1>
		<title>CDBS with Simple Patchsys</title>
		<para>The CDBS build helper system (see <xref linkend="basic-cdbs"/> ) has a very simple patch system built in. You simply need to add an include for <emphasis>simple-patchsys.mk</emphasis> in <filename>debian/rules</filename>. An example is <application>pmount</application>. Its entire <filename>rules</filename> looks like:
		<screen>
#!/usr/bin/make -f
include /usr/share/cdbs/1/rules/debhelper.mk
include /usr/share/cdbs/1/class/autotools.mk
include /usr/share/cdbs/1/rules/simple-patchsys.mk

common-post-build-arch::
        # Generate a POT file
        cd po; intltool-update -p --verbose
</screen>
		</para>
		<para>O patchsys simples tem um editor de correcções embutido chamado <application>cdbs-edit-patch</application>. Pode dar ao <application>cdbs-edit-patch</application> tanto um nome de uma correcção existente ou uma nova correcção a criar. Irá aplicar a correcção existente, se existir, e colocá-lo numa nova shell. Depois pode fazer a alterações que quiser à correcção e finalmente teclar <emphasis>Ctrl-D</emphasis> para sair da shell e criar a nova correcção. As correcções são armazenadas em <filename>debian/patches/</filename></para>
	</sect1>
		
	<sect1>
		<title>dpatch</title>
		<para>Um sistema popular de correcção é o <application>dpatch</application>. O <application>dpatch-edit-patch</application> tem um sistema de scripts parecido com o do <application>cdbs</application> mas armazena as correcções de forma ligeiramente diferente. Usa um ficheiro chamado <filename>debian/patches/00list</filename> para procurar o nome e ordem das correcções a aplicar. Isto significa que pode ordenar as suas correcções da maneira que quiser e pode desactivar uma correcção sem remover todas as outras. No entanto, também significa que precisa de actualizar o <filename>00list</filename> se adicionar uma correcção. Se o <application>dpatch-edit-patch</application> é chamado com dois argumentos ele editará/criará a correcção com o nome do primeiro argumento relativamente à correcção com o nome do segundo argumento. Por outras palavras: <screen>dpatch-edit-patch new.dpatch old.dpatch</screen> aplicará as correcções até ao <filename>old.dpatch</filename> e a seguir cria <filename>new.dpatch</filename>. Note que as correcções do <application>dpatch</application> geralmente têm um sufixo .dpatch. Isto porque o <application>dpatch</application> armazena as correcções num formato ligeiramente diferente  de uma correcção normal que adiciona um cabeçalho especial.</para>
		<para>Um exemplo da vida real de uso do dpatch é o pacote <application>xterm</application>.</para>
	</sect1>

	<sect1>
		<title>Corrigindo pacotes de outras pessoas</title>
		<para>A coisa mais importante a ter em mente quando corrigir pacotes mantidos por outras pessoas é manter o sistema de correcção (ou falta dele) que o responsável definiu. Isto assegurará consistência e fará com que o responsável do pacote aceite mais fácilmente a sua correcção.</para>
			<para>Também é boa ideia separar as correcções logicamente em vez de criar uma correcção gigante. Se os autores do envio aplicarem uma das suas correcções mas não outra é muito mais fácil deixar uma correcção e a seguir editar uma correcção monolítica para o actualizar.</para>
	</sect1>
</chapter>

