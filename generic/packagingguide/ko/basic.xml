<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" 
	"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % globalent SYSTEM "../../../libs/global.ent">
%globalent;
<!ENTITY % cdo-C SYSTEM "../../../libs/cdo-C.ent">
%cdo-C;
<!ENTITY % pg-common SYSTEM "../pg-common.ent">
%pg-common;
<!ENTITY % xinclude SYSTEM "../../../libs/xinclude.mod">
%xinclude;
<!ENTITY language "en">
]>
<chapter id="basic-chap" status="complete">
	<title>패키징 기초</title>

	<para>많은 초보 패키지 관리자가 직면하는 두 가지 문제는 패키징을 하는 여러가지 방법이 있다는 것과 그 일을 하기 위한 하나의 도구보다 많은 것은 있다는 것 입니다. 우리는 일반 빌드 시스템을 가지고 세 가지 예제를 읽어보게 됩니다. 첫 번째, 우리는 아무 빌드 도움 프로그램도 사용하지 않습니다. 이 접근 방법은 보통 가장 어렵고 실제에 자주 사용하지 않지만 패키징 과정을 들여보는데 가장 단순한 것을 줍니다. 두 번째, 우리는 데비안에서 가장 일반적인 빌드 시스템인 <application>debhelper</application> 를 사용할 것 입니다. 이것은 반복적인 작업을 자동화 함으로서 패키지 관리자를 돕습니다. 세 번째, 우리는 간략하게, <application>debhelper</application> 를 사용하는 것보다 좀 더 간소화 된 <emphasis role="bold">C</emphasis>ommon <emphasis role="bold">D</emphasis>ebian <emphasis role="bold">B</emphasis>uild <emphasis role="bold">S</emphasis>ystem (<application>CDBS</application>) 에 대해 알아볼 것 입니다.</para>

	<tip><para>Package development often requires installing many packages
			(especially <application>-dev</application> packages containing
			headers and other common development files) that are not
			part of a normal desktop <phrase>Ubuntu</phrase> installation. If you want
			to avoid installing extra packages or would like to develop for a
			different <phrase>Ubuntu</phrase> release (the development one, for instance) from
			what you currently have, the use of a chroot environment
			is highly recommended. A guide to setting up a <xref linkend="appendix-chroot"/> can be found in the
			Appendix.</para></tip>

	
	<sect1 id="basic-scratch" status="complete">
		<title>도구없이 패키징 하기</title>
		
		<important><para><emphasis role="bold">요구사항:</emphasis> build-essential, automake, gnupg, lintian, fakeroot 그리고 <xref linkend="gs-pbuilder"/>.</para>
		</important>
					
		<para>이 예제에서 우리는 GNU <application><ulink url="http://www.gnu.org/software/hello/hello.html">hello</ulink></application> 프로그램을 예로 사용할 것 입니다. 여러분은 소스 tarball을 <ulink url="http://ftp.gnu.org/gnu/hello/hello-2.1.1.tar.gz">ftp.gnu.org</ulink> 에서 내려 받을 수 있습니다. 이 예제의 용도를 위해, 우리는 <filename>~/hello/</filename> 디렉토리를 사용할 것 입니다.</para>
		<screen>
mkdir ~/hello
cd ~/hello
wget http://ftp.gnu.org/gnu/hello/hello-2.1.1.tar.gz</screen>

		<para>We will also compare our package to one that is already
			packaged in the <phrase>Ubuntu</phrase> repository. For now, we will place
			it in the <filename>ubuntu</filename> directory so we can look at
			it later. To get the source
			package, make sure you have a "deb-src" line in your
			<filename>/etc/apt/sources.list</filename> file for the Main
			repository. Then, simply execute:</para>

		<screen>
mkdir ubuntu
cd ubuntu
apt-get source hello
cd ..</screen>
		
		<note><para>대부분의 <application>apt-get</application> 명령과는 다르게, 소스 패키지는 현재 디렉토리로 내려 받아지기 때문에, 여러분은 소스 패키지를 가지기 위해 루트 권한을 가질 필요가 없습니다. 실제로, 여러분은 <emphasis>오직</emphasis> 일반 사용자로써 <application>apt-get source</application> 를 사용하는 것이 권장 됩니다, 왜냐면 루트의 권한이 필요한 것 없이 소스 패키지 내의 파일을 편집할 수 있어야 하기 때문 입니다.</para></note>
		
		<para><application>apt-get source</application> 명령이 하는 것은 다음 입니다:</para>
		
		<orderedlist>

			<listitem><para>소스 패키지를 내려 받습니다. 소스 패키지는 보통 그 패키지를 기술하고 소스 패키지의 md5sum을 주는 .dsc 파일과, 저작자의 소스 코드를 가지는 .orig.tar.gz 파일, 그리고 패키징 정보와 함께 소스 코드에 적용된 패치를 가지는 .diff.gz 파일을 포함하고 있습니다.</para></listitem>

			<listitem><para>현재 디렉토리로 .orig.tar.gz 파일을 untar 합니다.</para></listitem>

			<listitem><para>gnuzipped .diff.gz 파일은 압축 풀려진 소스 디렉토리에 적용 합니다.</para></listitem>

			</orderedlist>

		<para>만약 여러분이 소스 패키지를 (.dsc, .orig.tar.gz, and .diff.gz files) 수동으로 내려 받았다면, 다음과 같이 <application>dpkg-source</application> 를 사용하여 <application>apt-get source</application> 가 하는 같은 방법으로 패키지를 압축 풀 수 있습니다:</para>
		<para><screen>dpkg-source -x *.dsc</screen></para>

		<para>여러분이 해야할 첫 번째 일은 다음의 형식으로 원래 (때로는 "업스트림"으로 불리는) tarball의 복사본을 만드는 것 입니다: <filename>&lt;packagename&gt;_&lt;version&gt;.orig.tar.gz</filename> 이 단계는 두 가지 일을 합니다. 첫 번째, 이것은 소스 코드 두 본을 만듭니다. 만약 작업하는 복사본을 실수로 변경하거나 삭제하였다면, 여러분은 내려받은 것을 사용할 수 있습니다. 두 번째, 이것은 절대적으로 필요하지 않는 한 원래의 소스 tarball을 변경하는 것은 좋지 않은 패키징 작업으로 여겨 집니다. 사유는 <xref linkend="basic-mistakes"/> 를 보십시오.</para>

		<screen>
cp hello-2.1.1.tar.gz hello_2.1.1.orig.tar.gz
tar -xzvf hello_2.1.1.orig.tar.gz</screen>

		<warning><para>패키지 이름(hello)와 버전(2.1.1) 사이에 있는 언더스코어 "_" 는 하이픈 "-"과 대조되고, 매우 중요 합니다. 하이픈 일때는 여러분의 소스 패키지는 데비안 패키지에 맞지 않게 잘못 만들어지게 됩니다.</para></warning>

		<para>우리는 이제 소스 파일을 포함하는 <filename>hello-2.1.1</filename> 디렉토리를 가졌습니다. 이제 우리는 패키지 정보를 저장하고, 프로그램 소스 파일에서 분리하여 패키징 파일을 허용하는 우리가 정의한 <application>debian</application> 디렉토리를 만들 필요가 있습니다.</para>

		<screen>
mkdir hello-2.1.1/debian
cd hello-2.1.1/debian/</screen>

		<para>We now need to create the essential files for any <phrase>Ubuntu</phrase>
			source package: <filename>changelog</filename>,
			<filename>control</filename>, <filename>copyright</filename>, and
			<filename>rules</filename>. These are the files needed to create
			the binary packages (.deb files) from the original (upstream)
			source code. Let us look at each one in turn.</para>
		
		<sect2>
			<title>changelog</title>
			
			<para><filename>changelog</filename> 파일은, 그것의 이름이 뜻하는 대로, 각 버전에서 만들어진 변경들의 목록 입니다. 이것은 패키지 이름, 버전, 배포, 변경과 주어진 시간에 누가 변경을 하였는지의 특정 형식을 가지고 있습니다. 만약 여러분이 GPG 키를 가지고 있다면, <filename>changelog</filename> 에 사용하는 이름과 이메일 주소는 여러분의 키에 있는 것과 같은 것을 사용하는 것을 확신 하십시오. 다음은 <filename>changelog</filename> 의 양식 입니다:</para>
			<screen>
package (version) distribution; urgency=urgency

  * change details
    more change details
  * even more change details

-- maintainer name &lt;email address&gt;[two spaces] date</screen>

			<para>이 형식은 (특히 날짜 형식) 중요 합니다. 날짜는 반드시 RFC822 형식이어야 하고, 그것은 <application>822-date</application> 에서 얻을 수 있습니다.</para>

			<para>여기에 <application>hello</application> 프로그램을 위한 예제 <filename>changelog</filename> 파일이 있습니다:</para>

			<screen>
hello (2.1.1-1) edgy; urgency=low

   * New upstream release with lots of bug fixes.

-- Captain Packager &lt;packager@coolness.com&gt;  Wed,  5 Apr 2006 22:38:49 -0700</screen>

			<para>버전에 -1 이 덧붙여졌음을, 그리고 이것은 데비안 개정 번호라 불리고, 같은 소스 릴리스 버전 내에서 (예를 들어 버그를 고치기 위해) 새 업로드로 패키지가 업데이트 될 때 사용을 하는 것을 주의 하십시오.</para>

			<note><para><phrase>Ubuntu</phrase> and Debian have slightly different package versioning
					schemes to avoid conflicting packages with the same
					source version. If a Debian package has been changed in <phrase>Ubuntu</phrase>,
					it has <emphasis>ubuntuX</emphasis> (where
					<emphasis>X</emphasis> is the <phrase>Ubuntu</phrase> revision number)
					appended to the end of the Debian version. So if the
					Debian <application>hello</application> package was
					changed by <phrase>Ubuntu</phrase>, the version string would be
					<filename>2.1.1-1ubuntu1</filename>. If a package for the
					application does not exist in Debian, then the Debian
					revision is <emphasis>0</emphasis>
					(<emphasis>e.g.</emphasis>,
					<filename>2.1.1-0ubuntu1</filename>).</para></note>
		
			<para>Now look at the <filename>changelog</filename> for the
				<phrase>Ubuntu</phrase> source package that we downloaded earlier:</para>

			<screen>
less ../../ubuntu/hello-2.1.1/debian/changelog</screen>

			<para>Notice that in this case the <emphasis>distribution</emphasis>
				is <emphasis>unstable</emphasis> (a Debian branch),
				because the Debian package has not been changed by <phrase>Ubuntu</phrase>.
				Remember to set the <emphasis>distribution</emphasis> to your
				target distribution release.</para>

			<para>이제 <filename>changelog</filename> 파일을 여러분이 아직 있어야 할 <filename>debian</filename> 디렉토리에 만듭니다.</para>
			
		</sect2>

		<sect2>
			<title>control</title>
			<para>control 파일은 패키지 관리 프로그램이 (<application>apt-get</application>, <application>synaptic</application>, 그리고 <application>aptitude</application> 와 같은) 사용할 정보, 빌드-타임 의존, 패키지 관리자 정보 그리고 훨씬 많은 것들을 가지고 있습니다.</para>
			<para>For the <phrase>Ubuntu</phrase> <application>hello</application> package,
				the control file looks something like:</para>
			<para><screen>Source: hello
Section: devel
Priority: optional
Maintainer: Captain Packager &lt;packager@coolness.com&gt; 
Standards-Version: 3.6.1

Package: hello
Architecture: any
Depends: ${shlibs:Depends}
Description: The classic greeting, and a good example
 The GNU hello program produces a familiar, friendly greeting. It
 allows non-programmers to use a classic computer science tool which
 would otherwise be unavailable to them.
 .
 Seriously, though: this is an example of how to do a Debian
 package.
 It is the Debian version of the GNU Project's `hello world' program
 (which is itself an example for the GNU Project).</screen></para>

			<para>위의 정보를 사용하여 <filename>control</filename> 파일을 만듭니다. (<emphasis>Maintainer</emphasis> 필드에 여러분의 정보를 제공하는 것은 확신 하십시오.)</para>
			
			<para>첫번째 문단은 소스 패키지에 대한 정보를 줍니다. 각각의 줄을 읽어보도록 하죠:</para>
			<itemizedlist>
				
				<listitem><para><emphasis role="bold">Source:</emphasis> 이것은 소스 패키지의 이름이고, 이 경우에는,  <emphasis>hello</emphasis> 입니다.</para></listitem>

				<listitem><para><emphasis role="bold">Section:</emphasis> apt 저장소는 열람하기 쉽고 소프트웨어의 분류를 위하여 영역으로 나누어 집니다. 이 경우에는, <application>hello</application> 는 <emphasis>devel</emphasis> 영역에 속합니다.</para></listitem>

				<listitem><para><emphasis role="bold">Priority:</emphasis> 이것은 사용자에게 패키지의 중요도를 지정 합니다. 이것은 반드시 다음 중의 하나이어야만 합니다:</para>

					<itemizedlist>
					
						<listitem><para><emphasis role="bold">Required</emphasis> - 패키지가 시스템이 적절히 동작하기 위해 필수적일 때 입니다. 만약 이 패키지가 삭제되면, 여러분의 시스템은 회복할 수 없게 고장이 나는 것이기가 아주 쉽습니다.</para></listitem>
						
						<listitem><para><emphasis role="bold">Important</emphasis> - 시스템 사용을 위한 최소한의 패키지의 집합에 속할 때 입니다. 이 패키지를 삭제하는 것은 여러분의 시스템이 회복 불능한 고장을 만들지는 않지만, 일반적으로 어떤 리눅스 설치도 이것이 없으면 불완전하다고 여겨지는 중요한 도구 입니다. 주의: 이것은 Emacs 또는 심지어 X 윈도우 시스템 같은 것을 포함하지 않습니다.</para></listitem>
						
						<listitem><para><emphasis role="bold">Standard</emphasis> - 약간은 스스로 설명하고 있죠.</para></listitem>
						
						<listitem><para><emphasis role="bold">Optional</emphasis> - 실제로 이 분류는 요구되지 않는 패키지를 위하거나 대부분의 패키지들을 위해서 입니다. 그러나, 이 패키지들은 각기 다른 패키지들과 충돌이 없어야만 합니다.</para></listitem>
						
						<listitem><para><emphasis role="bold">Extra</emphasis> - 이 곳의 패키지는 위의 분류 중 하나에 있는 패키지와 충돌이 있을 수도 있습니다. 또한 이미 패키지의 목적을 알고 있는 사람들에게만 유용한 특정한 패키지를 위하여 사용 됩니다.</para></listitem>
					
					</itemizedlist>
				</listitem>

				<listitem><para><emphasis role="bold">Extra</emphasis> 이메일 주소와 함께 패키지 관리자 이름을 적습니다.</para></listitem>

				<listitem><para><emphasis role="bold">Standards-Version:</emphasis> 패키지에 부착하는 <ulink url="http://www.debian.org/doc/debian-policy/">Debian Policy</ulink> 의 버전 입니다. (이 경우는, 3.6.1 버전 입니다.)  현재 버전을 찾는 쉬운 방법은 <emphasis>apt-cache show debian-policy | grep Version</emphasis> 입니다.</para></listitem>

				<listitem><para><emphasis role="bold">Build-Depends:</emphasis> 가장 중요한 필드의 하나이고 종종 버그의 원천이 됩니다. 이 줄은 소스 패키지로 부터 바이너리 패키지를 만들기 위해 설치가 필요한 바이너리 패키지의 (필요하다면 버전과 함께) 목록 입니다. <emphasis>build-essential</emphasis> 에 의해 요구되는 필수적인 패키지는 Build-Depends 줄에 포함될 필요가 없습니다. <application>hello</application> 프로그램의 경우는, 모든 필요한 패키지가 build-essential 의 부분 이므로 Build-Depends 줄은 필요가 없습니다. build-essential 패키지의 목록은 <filename>/usr/share/doc/build-essential/list</filename> 에서 찾을 수 있습니다.</para></listitem>
			
			</itemizedlist>

		
			<para>두번째 문단은 소스로 부터 만들어질 바이너리 패키지를 위해서 입니다. 만약 소스 패키지로 부터 다수의 바이너리 패키지가 만들어지면, <emphasis>각각의</emphasis> 것을 위한 영역이 반드시 있어야 합니다. 다시, 각각의 줄을 읽어 보겠습니다:</para>
			
			<itemizedlist>
			
				<listitem><para><emphasis role="bold">Package:</emphasis> 바이너리 패키지의 이름 입니다. 많은 경우의 단순한 프로그램은 (<application>hello</application> 과 같은), 소스와 바이너리 패키지의 이름이 동일 합니다.</para></listitem>
				
				<listitem><para><emphasis role="bold">Architecture:</emphasis> 바이너리 패키지가 만들어질 아키덱쳐 입니다. 예들 들어:</para>
					
					<itemizedlist>
						
						<listitem><para><emphasis role="bold">all</emphasis> - 소스가 아키텍쳐-의존이 <emphasis>아닌</emphasis> 경우 입니다. 파이썬과 다른 인터프리터 언어를 사용하는 프로그램들이 이 아키텍쳐 값을 사용 합니다. 결과의 바이너리 패키지는 <filename>_all.deb</filename> 로 끝나게 됩니다.</para></listitem>

						<listitem><para><emphasis role="bold">any</emphasis> - 소스가 아키텍쳐-의존 <emphasis>이고</emphasis>, 모든 지원되는 아키텍쳐에서 컴파일이 되어야 합니다. 각각의 아키텍쳐를 위한 .deb 파일이 있게 됩니다. (예를 들어 <filename>_i386.deb</filename>)</para></listitem>

						<listitem><para>A subset of architectures (i386, amd64, ppc, etc.)
								can be listed to indicate that the source is
								architecture-dependent and does not work for all
								architectures supported by <phrase>Ubuntu</phrase>.</para></listitem>

					</itemizedlist></listitem>

				<listitem><para><emphasis role="bold">Depends:</emphasis> 기능성을 위하여 바이너리 패키지가 의존하는 패키지의 목록 입니다. <application>hello</application> 을 위해, 우리는 <filename>${shlibs:Depends}</filename> 를 보게 되고, 이것은 필요한 공유 라이브러리로 대체하게 되는 변수 입니다. 더 많은 정보는 <filename>dpkg-source</filename> man 페이지를 보십시오.</para></listitem>

				<listitem><para><emphasis role="bold">Recommends:</emphasis> 강력히 권장하는 패키지에 사용되고 보통은 그 패키지와 함께 설치가 됩니다. 몇 몇의 패키지 관리자 프로그램은, 잘 알려진 것으로  <application>aptitude</application> 는, 권장 패키지를 자동으로 설치 합니다.</para></listitem>

				<listitem><para><emphasis role="bold">Suggests:</emphasis> 이 패키지가 설치될 때 비슷한 또는 유용한 패키지를 위하여 사용 됩니다.</para></listitem>
				
				<listitem><para><emphasis role="bold">Conflicts:</emphasis> 이 패키지와 충돌이 일어나는 패키지를 위하여 사용 됩니다. 동시에 양쪽 모두를 설치할 수 없습니다. 하나가 설치되면, 다른 하나는 삭제 됩니다.</para></listitem>

				<listitem><para><emphasis role="bold">Description:</emphasis> 패키지 관리자에 의해 짧은 그리고 긴 설명 모두를 적는 항목으로 사용 됩니다. 형식은 다음과 같습니다:</para>
					
<screen>Description: &lt;한 줄의 개요&gt;
 &lt;몇 줄에 걸친 확장된 설명&gt;</screen>

						<para>긴 설명 란의 각각의 줄의 시작에 하나의 공백이 있음을 주의 하십시오. 어떻게 좋은 설명을 만드는지에 대한 더 많은 설명은 <ulink url="http://people.debian.org/~walters/descriptions.html">http://people.debian.org/~walters/descriptions.html</ulink> 에서 찾을 수 있습니다.</para></listitem>
				
			</itemizedlist>
					
		</sect2>

		<sect2>
			<title>copyright</title>

			<para>이 파일은 저작권 정보를 줍니다. 일반적으로, 저작권 정보는 프로그램의 소스 디렉토리에 있는 <filename>COPYING</filename> 파일에서 찾아 봅니다. 이 파일은 저작자와 패키지 관리자의 이름과 같은 정보, 어디서 소스가 왔는지를 알리는 URL, 연도와 저작권 소유자를 알리는 저작권 줄, 그리고 저작권 자체의 텍스트를 포함하여야만 합니다. 예제 양식은 다음과 같습니다:</para>

			<screen>This package was debianized by {Your Name} &lt;your email address&gt;
{Date}

It was downloaded from: {URL of webpage} 

Upstream Author(s): {Name(s) and email address(es) of author(s)}

Copyright:
	Copyright (C) {Year(s)} by {Author(s)} {Email address(es)}

License:

</screen>

			<para>As one can imagine, <application>hello</application> is
				released under the GPL license. In this case it is easiest to
				just copy the <filename>copyright</filename> file from the
				<phrase>Ubuntu</phrase> package:</para>

			<screen>
cp ../../ubuntu/hello-2.1.1/debian/copyright .</screen>

			<para>여러분은 저작권이 GPL, LGPL, BSD, 또는 Artistic License 아니면 완전한 저작권을 반드시 포함시켜야 합니다. 앞에 언급된 저작권의 경우는 <filename>/usr/share/common-licenses/</filename> 디렉토리에 있는 대응하는 파일을 참조할 수 있습니다.</para>

			<para>Notice that the <phrase>Ubuntu</phrase> package's
				<filename>copyright</filename> includes a license statement for
				the manual. It is important that <emphasis>all</emphasis> the
				files in the source be covered by a license statement.</para>
			
		</sect2>	

		<sect2 id="basic-scratch-rules">
			<title>rules</title>
			
			<para>The <filename>rules</filename> file is an executable
				Makefile that has rules for building the binary package from
				the source packages. For <application>hello</application>, it
				will be easier to use the <filename>rules</filename>
				from the <phrase>Ubuntu</phrase> package:</para>

			<screen>#!/usr/bin/make -f
# Sample debian/rules file - for GNU Hello.
# Copyright 1994,1995 by Ian Jackson.
# I hereby give you perpetual unlimited permission to copy,
# modify and relicense this file, provided that you do not remove
# my name from the file itself. (I assert my moral right of
# paternity under the Copyright, Designs and Patents Act 1988.)
# This file may have to be extensively modified

package = hello
docdir = debian/tmp/usr/share/doc/$(package)

CC = gcc
CFLAGS = -g -Wall
INSTALL_PROGRAM = install

ifeq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
  CFLAGS += -O2
endif
ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
  INSTALL_PROGRAM += -s
endif

build:
        $(checkdir)
        ./configure --prefix=/usr
        $(MAKE) CC="$(CC)" CFLAGS="$(CFLAGS)"
        touch build

clean:
        $(checkdir)
        rm -f build
        -$(MAKE) -i distclean
        rm -rf *~ debian/tmp debian/*~ debian/files* debian/substvars

binary-indep: checkroot build
        $(checkdir)
# There are no architecture-independent files to be uploaded
# generated by this package. If there were any they would be
# made here.

binary-arch: checkroot build
        $(checkdir)
        rm -rf debian/tmp
        install -d debian/tmp/DEBIAN $(docdir)
        install -m 755 debian/postinst debian/prerm debian/tmp/DEBIAN
        $(MAKE) INSTALL_PROGRAM="$(INSTALL_PROGRAM)" \
        prefix=$$(pwd)/debian/tmp/usr install
        cd debian/tmp &amp;&amp; mv usr/info usr/man usr/share
        cp -a NEWS debian/copyright $(docdir)
        cp -a debian/changelog $(docdir)/changelog.Debian
        cp -a ChangeLog $(docdir)/changelog
        cd $(docdir) &amp;&amp; gzip -9 changelog changelog.Debian
        gzip -r9 debian/tmp/usr/share/man
        gzip -9 debian/tmp/usr/share/info/*
        dpkg-shlibdeps debian/tmp/usr/bin/hello
        dpkg-gencontrol -isp
        chown -R root:root debian/tmp
        chmod -R u+w,go=rX debian/tmp
        dpkg --build debian/tmp ..

define checkdir
        test -f src/$(package).c -a -f debian/rules
endef

binary: binary-indep binary-arch

checkroot:
        $(checkdir)
        test $$(id -u) = 0

.PHONY: binary binary-arch binary-indep clean checkroot
</screen>

			<para>이 파일을 더 자세하게 읽어 보도록 합시다. 첫 번째 부분에 여러분이 보는 것은 몇 가지 변수에 대한 정의 입니다:</para>
			<screen>package = hello
docdir = debian/tmp/usr/share/doc/$(package)

CC = gcc
CFLAGS = -g -Wall
INSTALL_PROGRAM = install

ifeq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
  CFLAGS += -O2
endif
ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
  INSTALL_PROGRAM += -s
endif
</screen>
			<para>이 영역은 컴파일러를 위한 CFLAGS 를 지정하고 또한 디버깅을 위한 <filename>noopt</filename> 와 <filename>nostrip</filename> DEB_BUILD_OPTIONS 을 관리 합니다.</para>
			
			<para>다음은 <filename>build</filename> 규칙 입니다:</para>
			<screen>build:
	$(checkdir)
	./configure --prefix=/usr
	$(MAKE) CC="$(CC)" CFLAGS="$(CFLAGS)"
	touch build</screen>
			<para>이 규칙은 적절한 접두 명칭과 함께 <emphasis>./configure</emphasis> 을 실행하고, <emphasis>make</emphasis> 를 실행하며, 그리고 오류가 있을 수 있는 여러 번의 컴파일을 막기 위해 빌드의 시각을 가지는 <filename>build</filename> 파일을 만듭니다.</para>
			<para>다음 규칙은 <filename>clean</filename> 입니다, 이것은 <emphasis>make -i distclean</emphasis> 을 실행하고 패키지가 빌드되는 동안에 만들어진 파일들을 삭제 합니다.</para>

			<screen>clean:
	$(checkdir)
	rm -f build
	-$(MAKE) -i distclean
	rm -rf *~ debian/tmp debian/*~ debian/files* debian/substvars</screen>

			<para>다음으로 우리는 빈 <filename>binary-indep</filename> 규칙을 봅니다, 왜냐면 이 패키지에는 생성된 아키텍쳐-독립 파일이 없기 때문 입니다.</para>

			<para>그러나, 많은 아키텍쳐-의존 파일이 있고, 그래서 <filename>binary-arch</filename> 이 사용 됩니다:</para>

			<screen>binary-arch: checkroot build
		$(checkdir)
		rm -rf debian/tmp
		install -d debian/tmp/DEBIAN $(docdir)
		install -m 755 debian/postinst debian/prerm debian/tmp/DEBIAN
		$(MAKE) INSTALL_PROGRAM="$(INSTALL_PROGRAM)" \
		prefix=$$(pwd)/debian/tmp/usr install
		cd debian/tmp  mv usr/info usr/man usr/share
		cp -a NEWS debian/copyright $(docdir)
		cp -a debian/changelog $(docdir)/changelog.Debian
		cp -a ChangeLog $(docdir)/changelog
		cd $(docdir)  gzip -9 changelog changelog.Debian
		gzip -r9 debian/tmp/usr/share/man
		gzip -9 debian/tmp/usr/share/info/*
		dpkg-shlibdeps debian/tmp/usr/bin/hello
		dpkg-gencontrol -isp
		chown -R root:root debian/tmp
		chmod -R u+w,go=rX debian/tmp
		dpkg --build debian/tmp ..</screen>
			
			<para>첫 번째, 이 규칙은 패키지가 root로써 만들어졌는지 확신하기 위하여 <filename>checkroot</filename> 를 호출하고 소스를 컴파일 하기 위하여 <filename>build</filename> 규칙을 호출 하는 것을 주목 하십시오. 그 다음에, <filename>debian/tmp/DEBIAN</filename> 과<filename>debian/tmp/usr/share/doc/hello</filename> 파일이 만들어지고, <filename>postinst</filename> 와 <filename>prerm&gt;</filename> 스크립트가 <filename>debian/tmp/DEBIAN</filename> 에 설치 됩니다. 그런 후 <emphasis>make install</emphasis> 이 prefix와 함께 실행되어 <filename>debian/tmp/usr</filename> 로 설치 됩니다. 이어서 문서 파일들이 (NEWS, ChangeLog, 와 그 debian changelog) 압축되고 설치 됩니다. <emphasis>dpkg-shlibdeps</emphasis> 는 <application>hello</application> 실행 파일의 공유 라이브러리 의존성을 찾기 위하여 수행되고, 그것은 <filename>control</filename> 내의 ${shlibs:Depends} 변수를 위한 <filename>debian/substvars</filename> 파일 내의 목록을 저장 합니다. 그 다음에, <emphasis>dpkg-gencontrol</emphasis> 이 바이너리 패키지를 위한 control 파일을 만들기 위하여 실행이 되고, <emphasis>dpkg-shlibdeps</emphasis> 에 의해 생성된 대체를 만듭니다. 마지막으로, <filename>debian/tmp</filename> 의 접근 권한이 지정된 후, <emphasis>dpkg --build</emphasis> 가 바이너리 .deb 패키지를 만들고 상위 디렉토리에 그것을 옮겨놓기 위하여 실행이 됩니다.</para>

		</sect2>

		<sect2> 
			<title>postinst and prerm</title> 
			
			<para>The <filename>postinst</filename> and
				<filename>prerm</filename> files are examples of maintainer
				scripts.  They are shell scripts that are executed after
				installation and before removal, respectively, of the package. In the case of
				the <phrase>Ubuntu</phrase> <application>hello</application> package, they
				are used to install (and remove) the info file. Go ahead and
				copy them into the current <filename>debian</filename>
				directory.</para>

			<screen>
cp ../../ubuntu/hello-2.1.1/debian/postinst .
cp ../../ubuntu/hello-2.1.1/debian/prerm .</screen>
		
		</sect2>

		<sect2>
			<title>소스 패키지 만들기</title>
			
			<para>이제 우리는 자세하게 <application>hello</application> 를 위한 <filename>debian</filename> 디렉토리 내의 파일들을 읽어 보았고, 소스(그리고 바이너리) 패키지를 만들 수 있습니다. 우선 압축이 풀려진 소스의 루트로 이동해 보도록 하겠습니다:</para>
			
			<para><screen>cd ..</screen></para>
			
			<para>이제 우리는 <application>dpkg-buildpackage</application> 를 사용하여 소스 패키지를 만듭니다:</para>
			
			<para><screen>dpkg-buildpackage -S -rfakeroot</screen></para>
			
			<para> The -S flag tells
				<application>dpkg-buildpackage</application> to build a source
				package, and the -r flag tells it to use
				<application>fakeroot</application> to allow us to have fake
				root privileges when making the package.
				<application>dpkg-buildpackage</application> will take the
				<filename>.orig.tar.gz</filename> file and produce a
				<filename>.diff.gz</filename> (the difference between
				the original tarball from the author and the directory we
				have created, <filename>debian/</filename> and its contents)
				and a <filename>.dsc</filename> file that has the
				description and md5sums for the source package. The
				<filename>.dsc</filename> and
				<filename>*_source.changes</filename> (used for uploading the
				source package) files are signed using your GPG key.</para>
				
			<warning><para>If you do not have a <application>gpg</application> key set up you will get an error from <application>debuild</application>. You can either set up a <application>gpg</application> key or use the <emphasis>-us -uc</emphasis> keys with <application>debuild</application> to turn off signing. However, you will not be able to have your packages uploaded to Ubuntu without signing them.</para></warning>
			
			<tip><para>To make sure <application>debuild</application> finds the right <application>gpg</application> key you should set the DEBFULLNAME and DEBEMAIL environment variables (in your <filename>~/.bashrc</filename> for instance) to the name and email address you use for your <application>gpg</application> key and in the <filename>debian/changelog</filename></para> <para>Some people have reported that they were unable to get <application>debuild</application> to find their <application>gpg</application> key properly, even after setting the above environment variables. To get around this you can give <application>debuild</application> the <emphasis>-k&lt;keyid&gt;</emphasis> flag where &lt;keyid&gt; is your <application>gpg</application> key ID.</para></tip>

			
			<para>소스 패키지에 더하여, 우리는 또한 <application>pbuilder</application> 를 가지고 바이너리 패키지를 만들 수 있습니다:</para>
			
			<para><screen>sudo pbuilder build ../*.dsc</screen></para>

			<para>바이너리 패키지를 만들기 위해 <application>pbuilder</application> 를 사용하는 것은 매우 중요 합니다. 이것은 <application>pbuilder</application> 는 오직 최소한의 환경을 제공하므로, 모든 빌드-타임 의존성은 <filename>control</filename> 파일에 의해서 결정되기 때문에 빌드 의존성을 정확히 하는 것을 확신하게 합니다.</para>
			
			<para>우리는 <application>lintian</application> 을 가지고 소스 패키지의 일반적인 실수를 점검할 수 있습니다:</para>
			
			<screen>cd ..
lintian -i *.dsc</screen>
			
		</sect2>

	</sect1>

	<sect1 id="basic-debhelper" status="complete">
		<title>Debhelper 로 패키징</title>
		
		<important><para><emphasis role="bold">요구 사항:</emphasis> <xref linkend="basic-scratch"/> 영역에 있는 요구 사항들에 debhelper와 dh-make를 더합니다.</para> </important>

		<para>패키지 관리자로써, 여러분은 이전 부분에서 마쳤던 것처럼 아무 도구없이 패키지를 만드는 것은 극히 적습니다. 여러분이 상상할 수 있는 것처럼, 예를 들어, <filename>rules</filename> 파일에 있는 많은 작업과 정보는 패키지의 공통적인 사항 입니다. 패키징을 좀 더 쉽고 효과적으로 하려면, 이러한 작업을 돕기 위하여 <application>debhelper</application> 를 사용할 수 있습니다. Debhelper 는 패키지-빌딩의 과정을 자동화 하는 (<emphasis>dh_</emphasis> 로 시작하는) 펄 스크립트의 집합 입니다. 이 스크립트들로, 데비안 패키지를 만드는 것은 아주 단순해 졌습니다.</para>

		<para>In this example, we will again build the GNU Hello package, but this
			time we will be comparing our work to the Ubuntu
			<application>hello-debhelper</application> package. Again,
			create a directory where you will be working: </para>

		<screen>mkdir ~/hello-debhelper
cd ~/hello-debhelper
wget http://ftp.gnu.org/gnu/hello/hello-2.1.1.tar.gz
mkdir ubuntu
cd ubuntu</screen>
		

		<para>Then, get the Ubuntu source package:</para>

		<screen>apt-get source hello-debhelper
cd ..</screen>

		<para>이전의 예제와 마찬가지로, 우리가 할 필요가 있는 첫 번째 일은 원래의 (업스트림) tarball을 압축 푸는 것 입니다.</para>

		<screen>tar -xzvf hello-2.1.1.tar.gz</screen>

		<para>이전 예제에서 우리가 했던 것처럼 업스트림의 tarball을 <filename>hello_2.1.1.orig.tar.gz</filename> 로 복사하는 대신에, 우리는 <application>dh_make</application> 가 우리를 위하여 그 작업을 하도록 시킬 겁니다. 오직 여러분이 해야하는 것은 소스 폴더의 이름을 변경하는 것 입니다. 그래서 그것은 <emphasis>&lt;packagename&gt;-&lt;version&gt;</emphasis> 형식이 되고 패키지 이름은 소문자 입니다. 이 경우에, 단지 tarball의 압축을 푸는 것으로 정확한 이름의 소스 디렉토리를 생성하고 그래야 우리는 그 곳으로 이동할 수 있습니다:</para>

		<screen>cd hello-2.1.1</screen>

		<para>소스의 초기 "데비안화"를 만들기 위해, 우리는 <application>dh_make</application> 를 사용 합니다.</para>

		<screen>
dh_make -e your.maintainer@address -f ../hello-2.1.1.tar.gz
		</screen>

		<para>dh_make는 여러분에게 연속되는 질문들을 물어 봅니다:</para>

		<screen>
Type of package: single binary, multiple binary, library, kernel module or cdbs?
[s/m/l/k/b] <emphasis role="bold">s</emphasis></screen>

		<screen>
Maintainer name : Captain Packager
Email-Address : packager@coolness.com
Date : Thu, 6 Apr 2006 10:07:19 -0700
Package Name : hello
Version : 2.1.1
License : blank
Type of Package : Single
Hit &lt;enter&gt; to confirm: <emphasis role="bold">Enter</emphasis></screen>

		<caution><para>오직 한 번만 <application>dh_make -e</application> 를 실행 합니다. 그것은 첫 번째 실행한 후에 다시 실행 한다면, 그것은 적절하게 동작하지 않습니다. 그것을 변경하기를 원하거나 실수를 하였다면, 소스 디렉토리를 삭제하고 새로운 업스트림 tarball을 압축 풉니다. 그런 후에 그 소스 디렉토리로 이전할 수 있고 다시 시도 합니다.</para></caution>
		
		<para><application>dh_make -e</application> 실행하는 것은 두 가지 일을 합니다:</para>

		<orderedlist> 
			
			<listitem><para>상위 디렉토리에 <filename>hello_2.1.1.orig.tar.gz</filename> 파일을 만듭니다.</para></listitem>

			<listitem><para><filename>debian/</filename> 에 필요한 기본 파일들과 필요할 수 있는 많은 양식 파일(.ex)들을 만듭니다.</para></listitem>
			
		</orderedlist>

		<para>우리가 <xref linkend="basic-scratch"/> 에서 본 것 처럼, <application>Hello</application> 프로그램은 매우 복잡하지 않고, 패키징은 기본 파일보다 훨씬 많은 것을 요구하지 않습니다. 그래서, <filename>.ex</filename> 파일들을 다음과 같이 삭제 합니다:</para>

		<screen>cd debian
rm *.ex *.EX</screen>

		<para><filename>README.Debian</filename>(프로그램 일반적인 사항을 담은 README가 아니라 데비안에만 해당하는 사항을 담은 README)이나 <filename>dirs</filename>(필요한 디렉토리를 <application>dh_installdirs</application> 프로그램을 통해 만들 때 사용), <filename>docs</filename>(문서를 <application>dh_installdocs</application> 프로그램을 통해 설치하고자 할 때 사용), <filename>info</filename>(info 파일을 <application>dh_installinfo</application> 프로그램을 통해 설치하고자 할 때 사용) 역시 꼭 필요한 것은 아닙니다. 자세한 정보는 <xref linkend="appendix-examples"/>를 참조해 주십시오.</para>

		<para>이 시점에서, 여러분은 오직 <filename>changelog</filename>, <filename>compat</filename>, <filename>control</filename>, <filename>copyright</filename>, 그리고 <filename>rules</filename> 파일을 <filename>debian</filename> 디렉토리 내에 가져야만 합니다. <xref linkend="basic-scratch"/> 에서, 새로운 파일은 오직 <filename>compat</filename> 입니다, 이것은 사용된 <application>debhelper</application> 버전을 가지고 있습니다. (이 경우에는 4 입니다.)</para>

		<para>You will need to adjust the
			<filename>changelog</filename> slightly in this case to reflect
			that this package is named
			<application>hello-debhelper</application> rather than just
			<application>hello</application>:</para>

		<screen>
hello-debhelper (2.1.1-1) edgy; urgency=low

  * Initial release

  -- Captain Packager &lt;packager@coolness.com&gt;  Thu,  6 Apr 2006 10:07:19 -0700</screen>
		
		<para>By using <application>debhelper</application>, the only
			things we need to change in <filename>control</filename> are the
			name (substituting <application>hello</application> for
			<application>hello-debhelper</application>) and adding
			<application>debhelper (&gt;= 4.0.0)</application> to the
			<emphasis>Build-Depends</emphasis> field for the source
			package. The Ubuntu package for
			<application>hello-debhelper</application> looks like:</para>

		<screen>
Source: hello-debhelper
Section: devel
Priority: extra
Maintainer: Capitan Packager &lt;packager@coolness.com&gt;
Standards-Version: 3.6.1
Build-Depends: debhelper (&gt;= 4)

Package: hello-debhelper
Architecture: any
Depends: ${shlibs:Depends}
Conflicts: hello
Provides: hello
Replaces: hello
Description: The classic greeting, and a good example
 The GNU hello program produces a familiar, friendly greeting. It
 allows non-programmers to use a classic computer science tool which
 would otherwise be unavailable to them.
 .
 Seriously, though: this is an example of how to do a Debian package.
 It is the Debian version of the GNU Project's `hello world' program
 (which is itself an example for the GNU Project).
 .
 This is the same as the hello package, except it uses debhelper to
 make the deb. Please see debhelper as to what it is.
		</screen>

		<para>We can copy the <filename>copyright</filename> file and the
			<filename>postinst</filename> and <filename>prerm</filename>
			scripts from the Ubuntu
			<application>hello-debhelper</application> package, as they have
			not changed since <xref linkend="basic-scratch"/>. We will also
			copy the <filename>rules</filename> file so we can inspect
			it.</para>

		<screen>
cp ../../ubuntu/hello-debhelper-2.1.1/debian/copyright .
cp ../../ubuntu/hello-debhelper-2.1.1/debian/postinst .
cp ../../ubuntu/hello-debhelper-2.1.1/debian/prerm .
cp ../../ubuntu/hello-debhelper-2.1.1/debian/rules .</screen>

		<para>마지막으로 봐야할 파을은 <filename>rules</filename>입니다. 이 파일에서 <application>debhelper</application> 스크립트의 기능을 확인해보실 수 있습니다. <filename>rules</filename>의 54줄 짜리 <application>debhelper</application>용 버전은 72줄 짜리 <xref linkend="basic-scratch-rules"/>용 버전보다 좀 짧습니다.</para>

		<para><application>debhelper</application> 버전은 다음과 비슷합니다:</para>

		<screen> #!/usr/bin/make -f

package = hello-debhelper

CC = gcc
CFLAGS = -g -Wall

ifeq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
  CFLAGS += -O2
endif

#export DH_VERBOSE=1

clean:
        dh_testdir
        dh_clean
        rm -f build
        -$(MAKE) -i distclean

install: build
        dh_clean
        dh_installdirs
        $(MAKE) prefix=$(CURDIR)/debian/$(package)/usr \
                mandir=$(CURDIR)/debian/$(package)/usr/share/man \
                infodir=$(CURDIR)/debian/$(package)/usr/share/info \
                install

build:
        ./configure --prefix=/usr
        $(MAKE) CC="$(CC)" CFLAGS="$(CFLAGS)"
        touch build

binary-indep: install
# There are no architecture-independent files to be uploaded
# generated by this package. If there were any they would be
# made here.

binary-arch: install
        dh_testdir -a
        dh_testroot -a
        dh_installdocs -a NEWS
        dh_installchangelogs -a ChangeLog
        dh_strip -a
        dh_compress -a
        dh_fixperms -a
        dh_installdeb -a
        dh_shlibdeps -a
        dh_gencontrol -a
        dh_md5sums -a
        dh_builddeb -a

binary: binary-indep binary-arch

.PHONY: binary binary-arch binary-indep clean checkroot
			</screen>

		<para>참고로, 현재 올바른 디렉트리에 있는지(<application>dh_testdir</application>), 루트 권한으로 패키지를 빌드하고 있는지(<application>dh_testroot</application>) 확인하는 작업, 문서를 설치하고((<application>dh_installdocs</application>와 <application>dh_installchangelogs</application>), 빌드가 끝난 후 정리하는 작업(<application>dh_clean</application>)은 모두 자동으로 처리됩니다. <application>hello</application> 패키지보다 훨씬 복잡한 패키지들도 filename&gt;rules</para>

			<sect2>
			<title>소스 패키지 만들기</title>
			
			<para>이제 우리는 <application>hello-debhelper</application> 를 위한 <filename>debian</filename> 디렉토리 내의 파일들을 모두 살펴 보았고, 소스(그리고 바이너리) 패키지를 만들 수 있습니다. 우선은, 소스 디렉토리로 다시 이동합니다:</para>
			
			<para><screen>cd ..</screen></para>
			
			<para>이제 우리는 <application>dpkg-buildpackage</application> 를 위한 랩퍼 스크립트인, <application>debuild</application> 를 사용하여 소스 패키지를 만듭니다:</para>
			
			<para><screen>debuild -S</screen></para>
				
			<para>바이너리 패키지, <application>pbuilder</application> 사용:</para>
			
			<para><screen>sudo pbuilder build ../*.dsc</screen></para>

			<para>그리고 마지막으로 <application>lintian</application> 을 사용하여 소스 패키지의 일반적인 실수를 점검 합니다:</para>
			
			<screen>cd ..
lintian -i *.dsc</screen>
			
		</sect2>
	
	</sect1>

	<sect1 id="basic-cdbs" status="complete">
		<title>CDBS로 패키징</title>

		<para>CDBS는 데비안 패키지를 만들고 유지관리 하는 것을 보다 쉽게 만들기 위해 debhelper를 사용하는 도구 입니다. 이것은 많은 장점을 가지고 있습니다:</para>

			<itemizedlist>
				<listitem><para>이것은 간결한, 읽기쉬운, 그리고 효과적인 <filename>debian/rules</filename> 을 생산 합니다.</para></listitem>
				
				<listitem><para>이것은 여러분을 위하여 debhelper와 autotools를 자동화 하고, 그래서 여러분은 반복적인 작업에 대해 걱정하지 않아도 됩니다.</para></listitem>
				
				<listitem><para>그것은 커스터마이징에 제한하는 것 없이 도울 수 있으므로 보다 중요한 패키징 문제에 여러분이 집중할 수 있도록 돕습니다</para></listitem>
				
				<listitem><para>그것의 클래스는 매우 잘 테스트 되었으므로 공통적인 문제를 해결하기 위해 지저분하게 여기저기를 고치는 것을 피할 수 있습니다</para></listitem>
				
				<listitem><para>CDBS로 전환하는 것은 쉽습니다</para></listitem>
				
				<listitem><para>이것은 확장가능 합니다</para></listitem>
			</itemizedlist>
		
		<sect2>
			<title>패키지에 CDBS 사용 하기</title>
		
			<para>Using CDBS for Ubuntu packages is very easy. After adding 
				<application>cdbs</application> to the Build-Depends in 
				<filename>debian/control</filename>, a basic
				<filename>debian/rules</filename> file using CDBS can fit in 2 lines. 
				For a simple C/C++ application with no extra rules, such as
				<application>hello</application>, <filename>debian/rules</filename> can
				look like this :</para>

			<screen>#!/usr/bin/make -f
				
include /usr/share/cdbs/1/rules/debhelper.mk
include /usr/share/cdbs/1/class/autotools.mk</screen>

			<para>이것은 프로그램을 빌드하기 위해 여러분이 필요한 전부 입니다! CDBS 가 설치와 지우는 것을 관리 합니다. 여러분은 그런 후에 <filename>debian/rules</filename> 를 위한 다양한 영역에 있는 보통의 debhelper 기능과 함께 여러분의 패키지를 조정하기 위해 <filename>.install</filename> 과  <filename>.info</filename> 파일을 사용할 수 있습니다.</para>

			<warning><para><filename>debian/control</filename> 파일을 자동적으로 변경하기 위하여 DEB_AUTO_UPDATE_DEBIAN_CONTROL:=yes 를 사용하지 마십시오, 그것은 안 좋은 일을 일으키고, 데비안에서는 그러한 패키지가 저장소에 들어올 때 거절을 하는 이유로 고려를 하고 있습니다. 더 많은 정보는, <ulink url="http://ftp-master.debian.org/REJECT-FAQ.html"> http://ftp-master.debian.org/REJECT-FAQ.html</ulink> 을 보십시오.</para></warning>
			
			<para>여러분이 보는 것처럼, CDBS는 <filename>debian/rules</filename> 내의 <filename>.mk</filename> Makefiles 를 포함하는 것에 의해 대부분 동작 합니다. <application>cdbs</application> 패키지는 여러분이 아주 많은 패키징 작업을 할 수 있도록 허용하는 <filename>/usr/share/cdbs/1/</filename> 내에 그러한 파일들을 제공 합니다. <application>quilt</application> 와 같은 다른 패키지들은, 모듈을 CDBS에 추가하고 Build-Depends 로 사용되어 질 수 있습니다. 여러분은 또한 여러분 소유의 CDBS 규칙들을 사용할 수 있고 그것들을 패키지에 포함할 수 있음을 주의 하십시오. <application>cdbs</application> 패키지에 포함되는 가장 유용한 모듈들은 다음과 같습니다:</para>

			<itemizedlist>
				
				<listitem><para><filename>rules/debhelper.mk</filename>: 모든 필요한 영역에 debhelper를 호출 합니다.</para></listitem>
			
				<listitem><para><filename>rules/dpatch.mk</filename>: 여러분이 소스를 쉽게 패칭하기 위해 dpatch를 사용하는 것을 허용 합니다.</para></listitem>
				
				<listitem><para><filename>rules/simple-patchsys.mk</filename>: 소스를 패치하는 아주 쉬운 방법을 제공 합니다.</para></listitem>
				
				<listitem><para><filename>rules/tarball.mk</filename>: 여러분이 패키지에서 압축된 tarball을 사용하여 패키지를 만드는 것을 허용 합니다.</para></listitem>
				
				<listitem><para><filename>class/autotools.mk</filename>: 모든 필요한 영역에 autotools를 호출 합니다.</para></listitem>
				
				<listitem><para><filename>class/gnome.mk</filename>: GNOME 프로그램을 만듭니다. (<filename>debian/control</filename> 내에 적절한 Build-Depends 을 요구 합니다.)</para></listitem>
				
				<listitem><para><filename>class/kde.mk</filename>: KDE 프로그램을 만듭니다. (<filename>debian/control</filename> 내에 적절한 Build-Depends 을 요구 합니다.)</para></listitem>
				
				<listitem><para><filename>class/python-distutils.mk</filename>: 파이썬 프로그램의 패키징을 용이하게 합니다.</para></listitem>
			
			</itemizedlist>
		</sect2>
		
		<sect2>
			<title>CDBS에 대한 더 많은 정보</title>
		
			<para>CDBS에 대한 더 많은 정보는, <ulink url="https://perso.duckcorp.org/duck/cdbs-doc/cdbs-doc.xhtml">https://perso.duckcorp.org/duck/cdbs-doc/cdbs-doc.xhtml</ulink> 에 있는 Marc Dequènes 의 안내서를 보십시오.</para>
		
		</sect2>
	</sect1>

	<sect1 id="basic-mistakes" status="complete">
		<title>일반적인 실수</title>
			
		<sect2 id="basic-ex_files">
			<title>dh_make 예제 파일</title>
			
			<para>여러분이 초기 "데비안화"를 만들기 위하여 dh_make를 사용할 때, 다양한 작업을 위한 예제 파일은 <filename>debian/</filename> 디렉토리에 만들어 집니다. 그 양식들은 .ex 확장자를 가지고 있습니다. 만약 여러분이 하나를 사용하기를 원한다면, 그것은 확장자를 제거하여 이름을 변경 하십시오. 만약 그것이 필요하지 않다면, <filename>debian/</filename> 디렉토리를 깨끗하게 유지하기 위하여 그것을 삭제 하십시오.</para>

		</sect2>

		<sect2 id="basic-orig-tarball">
			<title>원래의 Tarball 변경 하기</title>

			<para>There are two types of source packages, native and non-native.
				A native package is one that is specific to <phrase>Ubuntu</phrase>/Debian. It has the
				<application>debian/</application> directory containing the packaging
				information and any changes to the source included in the tarball (usually
				&lt;packagename&gt;_&lt;version&gt;.tar.gz). Non-native packages are more
				common. A non-native package splits
				the source package into a &lt;packagename&gt;_&lt;version&gt;.orig.tar.gz
				tarball that is identical (hopefully including md5sum) to the source
				tarball downloaded from the project's homepage and a .diff.gz file that
				contains all the differences (<filename>debian/</filename> directory and
				patches) from the original source tarball.</para>

			<para>만약 여러분이 원래의 tarball을 변경 한다면 일어날 수 있는 가능한 위험에 대한 목록이 여기에 있습니다:</para>
		
			<orderedlist>

				<listitem><para>재생 가능성</para>

					<para>만약 여러분이 단지 .diff.gz 와 .dsc 만을 취한다면, 여러분 또는 다른 사람이 원래의 tarball에 있는 변경을 재생산할 수단이 없습니다.</para></listitem>

				<listitem><para>업그레이드 가능성</para>
		
					<para>It is much easier to upgrade to a new upstream (from the author)
						version if the .orig.tar.gz is preserved and there is a clear
						separation between the upstream source and the changes made to
						produce the <phrase>Ubuntu</phrase> source package.</para> </listitem>

				<listitem><para>Debian to <phrase>Ubuntu</phrase> Synchronization</para>

					<para>Changing original tarballs makes it hard to automatically sync
						from Debian to <phrase>Ubuntu</phrase>. Normally, only the .diff.gz and .dsc files
						change within the same upstream version, since the .orig.tar.gz
						file is shared by all the Debian or <phrase>Ubuntu</phrase> revisions. It is much
						more difficult to sync if the md5sums of the .orig.tar.gz files
						are not the same.</para> </listitem>

				<listitem><para>데비안 패키지를 위한 개정 관리의 사용</para>
					
					<para>만약 여러분의 데비안 패키지를 관리하기 위하여 svn (<application>svn-buildpackage</application>) 을 사용한다면, 그것 내에 보통은 원래의 tarball을 저장하지 않습니다. 만약 다른 누군가 체크아웃을 한다면, 따로이 원래의 tarball을 가지는 것이 필요 합니다. 다른 버전 관리 시스템은 오직 패키징 파일 (<filename>debian/</filename>, 기타) 만을 추적하고 전체 소스는 추적하지 않는 것에 이용될 수 있습니다. 그러나, .orig.tar.gz 이 같지 않다면, 그것은 분명히 문제를 일으킬 수 있습니다.</para></listitem>

				<listitem><para>보안 추적</para>

					<para>어떤 사람이 backdoor/rootkit 또는 다른 나쁜 것을 포함하기를 <emphasis>원한다는</emphasis> 것을 고려하십시오. 만약 원래의 tarball이 손상되지 않았다면, 그 사람이 무엇인가 나쁜 짓을 하기 위하여 패키지를 변경하였는 지를 보기 위하여 diff.gz 를 통해 쉽게 검사를 할 수 있습니다. 그러나, 만약 tarball이 변경되었다면, 그 tarball과 원래의 소스 간의 차이를 점검하는 것이 필요 합니다.</para>
		
						<note><para>여러분은 여전히 그 소프트웨어의 저작자가 어떤 나쁜 것도 하지 않았다고 신뢰를 할 수 있지만, 그것은 원래의 소스가 변경되었는 여부에 관계없는 경우 입니다.</para></note></listitem>

				<listitem><para>.diff.gz 파일</para>
						
					<para>이미 존재하는 원래의 tarball로 변경을 반영하기 위해 대신에 .diff.gz 를 사용하는 것이 선택 사항이고, 이것은 원래의 tarball을 건드리는 것 없이 변경을 만드는 것을 쉽게 합니다.</para></listitem>
				
			</orderedlist>


			<para><emphasis role="bold">만약 다음 중 하나 또는 그 이상이 진실일 경우 원래의 tarball을 변경하는 것은 받아질 수 있습니다:</emphasis></para>

			<itemizedlist>
	
				<listitem><para>그것이 재배포할 수 없는 비자유 부분을 가지고 있고, 패키징 내에 그것을 기록 합니다. 자주 이러한 패키지는 이름 내에 "dfsg" (Debian Free Software Guidelines 의 약어) 를 사용하고(또는), 비자유 부분이 삭제 되었음을 표시하는 버전 매김을 합니다.</para></listitem>
					
				<listitem><para>저작자는 bzip2으로 압축된 소스만을 제공 합니다.</para>
					<itemizedlist>
						
						<listitem><para>단지, <application>bunzip2</application> 그 .tar.bz2 와 <application>gzip -9 </application> 그 결과 tar 를 하십시오.</para></listitem>
							
						<listitem><para>여러분이 제공하는 .tar 파일과 원래의 .tar 파일의 md5sums 은 반드시 일치하여야 합니다!</para></listitem>
	
						<listitem><para>실제로 debian/rules 에 get-orig-source 규칙을 제공 하는 것은 이 변환을 자동으로 합니다.</para></listitem>
					
					</itemizedlist>
				</listitem>
					
				<listitem><para>SVN에서 직접 가져오기</para>
					<itemizedlist>
						<listitem><para>debian/rules 에 get-orig-source 를 제공 합니다.</para></listitem>
					</itemizedlist>
				</listitem>
	
			</itemizedlist>

			<para><emphasis role="bold">다음은 원래의 tarball을 변경하는 사유가 <emphasis>아닙니다</emphasis>:</emphasis></para>
			
			<itemizedlist>
				
				<listitem><para>잘못된 디렉토리 레이아웃</para>
					
					<note><para><application>dpkg-source</application> 는 아주 유연하고, 심지어 다음의 경우에도 정확한 디렉토리 레이아웃을 생산하는 것을 관리 합니다:</para>
						
					<itemizedlist>
						
						<listitem><para>tarball 내의 디렉토리는 &lt;upstream&gt;-&lt;version&gt; 로 이름지어질 수 없습니다.</para></listitem>
				
						<listitem><para>tarball 내에 서브디렉토리가 없습니다.</para></listitem>
					</itemizedlist>
					</note>
			
				</listitem>
			
				<listitem><para>.diff.gz 작게 유지를 하려면 (예를 들어, autotools에 의해 만들어진 ) 파일들을 삭제하는 것이 필요 합니다. 삭제되어야 할 필요가 있는 모든 것들은 <application>clean</application> 규칙 내에서 지워져야 합니다. diff -u 로 .diff.gz 가 만들어지므로, diff.gz 에서 삭제된 파일을 볼 수 없게 됩니다.</para></listitem>
										
				<listitem><para>파일들은 변경되어야 할 필요가 있습니다. 변경이 필요한 파일들은 .diff.gz 로 가야만 합니다. 그것이 이것의 목적 입니다!</para></listitem>
				
				<listitem><para>파일의 잘못된 접근 권한. 이것을 하기 위해 <filename>debian/rules</filename> 를 사용할 수 있습니다.</para></listitem>
	
			</itemizedlist>
			
			
			<tip><para>.orig.tar.gz 이 이미 <filename>debian/</filename> dir을 포함하고 있다면 무엇을 해야 합니까?</para>
					
				<para>그것을 다시 패키지하지 마십시오. 여러분은 저작자에게 debian/ dir 을 삭제하는 것과 대신에 diff.gz 를 제공하도록 문의할 수 있습니다. 이것은 저작자의 작업을 검토하는 것을 쉽게 만들어 주고, 프로그램 소스에서 패키징을 구분할 수 있게 합니다.</para>
			</tip>
				
			<note><para>프로그램의 저작자와 연락하는 것은 언제나 좋은 생각이고 만약 여러분이 autoconf 문제나, 디렉토리 레이아웃, COPYRIGHT 파일 내의 오래된 Free Software Foundation 주소들을 고칠 수 있지만 그것이 여러분에게 불편할 때는 저작자에게 요청하고 그래서 여러분은 .diff.gz 내의 소스를 "패치"할 필요가 없게 됩니다.</para></note>
		
		</sect2>

		<sect2>
			<title>저작권 정보</title>

			<para><filename>debian/copyright</filename> 파일은 반드시 다음을 포함해야 합니다:</para>
			
			<itemizedlist>
				
				<listitem><para>소스 내의 <emphasis>모든</emphasis> 파일을 위한 사용허가 정보. 가끔씩 저작자가 소스 내의 몇 가지 파일을 위한 다른 사용허가 정보를 가지는 <filename>COPYING</filename> 파일에 라이센스를 넣기도 합니다.</para></listitem>

				<listitem><para>저작권 보유자와 연도</para></listitem>

				<listitem><para><filename>/usr/share/common-licenses</filename> 내에서 찾을 수 있는 하나의 사용허가가 아닌 한 <emphasis>전체</emphasis> 라이센스는 여러분이 사용허가의 서문을 포함시켜야 합니다.</para></listitem>

			</itemizedlist>
				
		</sect2>

	</sect1>

</chapter>

