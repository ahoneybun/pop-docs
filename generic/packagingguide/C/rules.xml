<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" 
        "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % globalent SYSTEM "../../../libs/global.ent">
%globalent;
<!ENTITY % cdo-C SYSTEM "../../../libs/cdo-C.ent">
%cdo-C;
<!ENTITY % pg-common SYSTEM "../pg-common.ent">
%pg-common;
<!ENTITY % xinclude SYSTEM "../../../libs/xinclude.mod">
%xinclude;
<!ENTITY language "en">
<!ENTITY ubuntu '<phrase>Ubuntu</phrase>'>
]>

<chapter>
<title>debian/rules</title>

  <sect1>
  <title>Introduction</title>

    <para>While packaging an application you will discover that debian/rules
file is one of the most importants maintainer scripts required for a perfect
package's build. This file it's simply a makefile, and learning make
structures, variables and constructions can help you to understand how to
modify and learn maintainer scripts like debian/rules too. Rules file can be
invoked by saying its name instead of launching make itself, thanks to the
starting line at the top of the file: #!/usr/bin/make -f.</para>

<para>A simple rule is made on a simple structure based on targets,
dependencies and commands. Here is what a simple rule looks like:</para>

<screen>
config.status: bar 
foo

Add here commands to configure the package.
./configure 
</screen>

<para>In our case:</para> 

         <orderedlist>

          <listitem><para><application>target</application> is "config.status"</para></listitem>

          <listitem><para><application>dependencies</application> are represented by "bar"</para></listitem>

	  <listitem><para><application>foo</application> and
<application>./configure</application> are the commands that will be executed,
in this case, to configure the package.</para></listitem>

         </orderedlist>

<para>The lines with the colon &quot; : &quot; in them are called dependency
lines. They determine whether the target has to be rebuilt. The Left side of
the colon is identified as the target itself of the dependency. Right side of
the colon got the sources needed to make the target. A dependency line says,
for example, that the target depends on a source file or a to another target as
in the previous example. Until configure target is launched, config.status is
not able to work as it depends directly from configure target specified above.
When this has been verified, rules file keep checking the next space under this
target where the developer will place every command is needed to
build/configure/clean the package.</para>

<para>The Makefile rules for building and installation can also use compilers
and related programs by running them via make variables so that the developer
can substitute them with other alternatives:</para>

<screen>
ar bison cc flex install ld ldconfig lex 
make makeinfo ranlib texi2dvi yacc 
</screen>

<para>Those programs can be called by using these variables while writing the makefile:</para>

<screen>
$(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX) 
$(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC) 
</screen>

</sect1>

<sect1>
<title>Make Variables</title>

<para>Other <application>make variables</application> are:</para>

<para>  <filename>LIB</filename> - this is the name of the library, also used
to construct the .a target (e.g lib$(LIB).a)</para>

<para>  <filename>$(LIB)DEPENDS_ON_LIBS </filename> - This is the list of
libraries that this library DIRECTLY depends on. Usually it should be ok
looking for #include fields checking if this lib directly depends on another
library.</para>

<para>  <filename>$(LIB)PUBLIC_HEADERS</filename> - the list of header files
contained within this library that should be copied when the library is built
or released.</para>

<para>  <filename>$(LIB)PRIVATE_HEADERS</filename> - the list of header files
contained within this library that should NOT be copied when the library is
built or released.</para>

<para>  <filename> $(LIB)SRCS</filename> - the list of source files contained
within this library.</para>

<para>  <filename>$(LIB)INC</filename> - the path used to search for include
files.</para>

<para>  <filename>$(LIB)DIR</filename> -  base directory for the
library</para>

<para>  <filename>$(LIB)HEADER_PREFIX</filename> - the prefix that should be
used when referencing a library header file using #include</para>

<para>  <filename>$(LIB)USER_FFLAGS</filename> - FORTRAN compiler flags</para>

<para>  <filename>$(LIB)USER_CFLAGS</filename> - C compiler flags</para>

<para>  <filename>$(LIB)USER_CXXFLAGS</filename> - C++ compiler flags</para>

<para>Environment variables used within all makefiles:</para>


<para>  <application>Flags :</application></para>

<para>  <filename>ARCH_CFLAGS</filename> - C compiler flags</para>

<para>  <filename>ARCH_CXXFLAGS</filename> - C++ compiler flags</para>

<para>  <filename>ARCH_FFLAGS</filename> - flags to the FORTRAN compiler</para>

<para>  <application>Compilers :</application>></para>

<para>  <filename>CXX</filename> - C++</para>

<para>  <filename>CC</filename> - C</para>

<para>  <filename>FF</filename> - FORTRAN</para>

<para>  <application>Other variables :</application></para>

<para>  <filename>RELEASE_DIR</filename> - it determines where where to release
an application when "release" target has been definied</para>

<para>  <filename>RM</filename> -  usually used to remove one or more files</para>

<para>  <filename>CP</filename> - usually used to copy one or more files</para>

<para>  <filename>USEPURIFY</filename> - if set to anything, then the purify
linker is used</para>

<para>  <filename>USEQUANTIFY</filename> - if set to anything, then the
quantify linker is used</para>

<para>  <filename>XRTHOME</filename> - used to find path for XRT authorization</para>

<para>The developer is able to choose from two other variables that will
semplify his work:</para>

<para><filename>$(CURDIR)</filename></para>

<para>This variable substitute the building folder (usually used in
debian/rules file), to avoid errors while building the final package.</para>

<para><filename>DESTDIR</filename></para>

<para>This variable defines which will be the destination directory to make
install applications files,for example, inside install target in
debian/rules.</para>

<para>Other informations about variables can be found here:
http://www.gnu.org/software/make</para>
</sect1>

<sect1>
<title>Target: Configure and config.status</title>

<para>Configure and config.status targets are really important, and usually if
you have a good knowledge on those you'll be able to troubleshoot problems in
an easier way. Config.status target depends obviously from configure and
contains all commands that should be executed in a proper configuration.  In
debian/rules case, the default field is set to:</para>

<screen>
./configure --host=$(DEB_HOST_GNU_TYPE) --build=$(DEB_BUILD_GNU_TYPE) --prefix=/usr --mandir=\$${prefix}/share/man --infodir=\$${prefix}/share/info CFLAGS="$(CFLAGS)" 
</screen>

<para>Every developer can decide to configure the package using his own
variables after ./configure command, to be able to decide where the package
will install manpages, documents, binary files and so on. Other commands listed
above can be used too. Common example is related to a &quot;permission
denied&quot; error (adding a configure target with chmod a+x as command wont
solve this problem) that happens while, during the build, rules file call for
configure rule. In our case we are able to add &quot;chmod a+x
./configure&quot; just above the execution of ./configure itself, -under-
&quot;# Add here commands to configure the package.&quot; line. The configure
and config.status variables only matter for a limited number of compiled
programs and debian/rules file is one of them.</para>

</sect1>

<sect1>
<title>Target: Build</title>

<para>Let's move to describe each other target inside debian/rules file
starting to understand what is, and why every rule is needed for a correct
package build:</para>

<para>build takes care to perform all the configuration and compilation of the
package. Usually this target is anticipated by configure/config one, that
allows to configure source files before building them. Usually quite all
applications contains their own configure script, that will be launched in
config.status target under commands sections anticipated by a comment
line:</para>

<screen>
Add here commands to configure the package.
</screen>

<para>Strictly related to build target are build-arch and build-indep, both of
them are optional and can be dropped if not needed.</para>

<para><application>Build-arch</application></para> 

<para>It takes care of configurating and compiling required for creating
architecture-dependant binary packages, if the Architecture section is
debian/control is not set to all.</para>

<para><application>Build-indep</application></para> 

<para>Similarly to build-arch perform the configuration/compilation required
for creating architecture-independent binary packages, if the Architecture
section in debian/control is set to all.</para>

<para><application>Binary target</application></para> 

<para>Takes care (must be invoked as root) of everything related to creating
the binary package produced from source files. Usually it's a target with no
commands to be specified, it's simply based on binary-arch and binary-indep
dependencies, listed here:</para>

<para><application>Binary arch</application></para> 

<para>Builds the binary packages which are specific to a particular
architecture. Depends on build and install targets.</para>

<para><application>Binary-indep</application></para> 

<para>Builds the binary packages which are -not- specific to a particular
architecture. Depends on build and install targets. Both the Binary-arch and
Binary-indep must exist, they *cannot* be dropped, also if one of them has
nothing to do with the package, a developer is currectly working on.</para>

</sect1>

<sect1>
<title>Target: Clean</title>

<para>Clean target usually got no dependencies, but mainly contains only
commands necessary to clean up the package after being built. When applying a
patch system, like dpatch is obligatory to add unpatch as direct dependency,
this will allow the clean process to de-apply changes provided by the patch
system previously added. Clean target is usefull also for deleting generated
manpages (or usually autogenerated config logs like config.status or config.log
itself) from the build process, if not they will be stored in both source and
debian folder.  Here is what a clean rule looks like:</para>

<screen>
clean: 
dh_testdir 
dh_testroot 
rm -f build-stamp 

Add here commands to clean up after the build process.
-$(MAKE) distclean 
-rm -f $(CURDIR)/foo.1 
-rm -f $(CURDIR)/config.log 
dh_clean 
</screen>

<para>Let's analyse clean target closely, explaining what is and what it does
every command listed there:</para>

<para><application>dh_testdir</application></para> 

<para>Checks whether you are in the right folder to build the debian package,
making sure that debian/control and others file the developer has specified
really exists in that folder.</para>

<para><application>dh_testroot</application></para> 

<para>Checks whether you are root as far as the package can be built only in
root-mode, otherwise you're suggested to use a fakeroot system specifying it
while running dpkg-buildpackage commmand. (e.g dpkg-buildpackage
-rfakeroot).</para>

<para><application>rm -f build-stamp</application></para> 

<para>Remove the generated files created by running make into sources folder,
where application's makefile resides.</para>

<para>After executing this commands, the developer will be free to add any
other command to clean up the package after comment:</para>

<screen>
Add here commands to clean up after the build process.
</screen>

<para>In our case, two commands have been specified (make distclean and
dh_clean are specified by default). Basically we can summarize them as it
follow:</para>

<para><application>make distclean</application></para> 

<para>It's intended to return the concerned subset or directory to its
pristine, or unbuilt state, removing all files potentially built by source's
Makefile. It should not be used prior to install target, otherwise it will
fail. (clean process won't stop)</para>

<para><application>rm -f $(CURDIR)/foo.1</application></para> 

<para>This command will delete the generated manpage created under binary-arch
commands by dh_installman (If source directory is named foo-1.0, $(CURDIR)
variable will take its place during build process).</para>

<para><application>rm -f $(CURDIR)/config.log</application></para> 

<para>This command will delete autogenerated logs created by launching
./configure command. It's safe to -not- have those files, to prevent confusing
builds. As its shown they can be safely removed in clean target, alwais using
previous folder variables. e.g $(CURDIR).</para>

<para><application>dh_clean</application></para> 

<para>This command (part of debhelper) is responsible for cleaning up after a
package has been built, removing build directories and other files like
debian/substvars, debian/files and any other files related to debhelper
command. (e.g debian/-.debhelper).</para>

<para>It's important to understand you won't find alwais this structure while
making a new package as far as each package has different practices, setups and
particolar needings.</para>

</sect1>

<sect1>
<title>Target: Install</title>

<para>Let's move to talk about the target responsible for installing
procedures, named install.  Here it is how install target looks like:</para>

<screen>
install: build 
dh_testdir 
dh_testroot 
dh_clean -k 
dh_installdirs 

Add here commands to install the package into debian/foo.
$(MAKE) DESTDIR=$(CURDIR)/debian/foo install 
</screen> 

<para>Install target depends on build target, explained above. Let's get closer
to the commands listed in the previous example:</para>

<para><application>dh_clean -k</application></para> 

<para>In this case, dh_clean specifies the -k option, that prevent debian/dirs
file to get deleted. This is necessary to be used anytime you have a
debian/rules that has 2 binary targets that build different .deb packages. (e.g
packaging libraries, one build target packages the shared libraries, other one
-dev package.)</para>

<para><application>dh_installdirs</application></para> 

<para>This command (part of debhelper) perform the creation of subdirectories
in package build directories.</para>

<para>Note: <application>dh_destdir</application> and
<application>dh_testroot</application> are explained above.</para>

<para>After executing this commands, the developer will be free to add any
other command to install the package after the specified comment:</para>

<screen>
Add here commands to install the package into debian/foo.
</screen>

<para>In our case, by default is specified that the package will be installed
inside debian/foo, taking foo as the name of the package we are creating. It
will make install all files previously configured by the
configure/config.status target and compiled by the build target into DESTDIR
variable, that can be modified by the developer to suit his needs. Like the
clean target, the folder that contains sources files need to be specified not
using the local uri, e.g /home/bar/foo/debian/foo but using the $(CURDIR)
variable, recognized universally by build systems like pbuilder.</para>

<para>Install target allows the developer to launch debhelper's scripts that
will install and place every file in the correct location. I suggest you to
check debhelper or dh_- scripts man page available by running man command in a
terminal followed by man page section (1-8) and application name (e.g man 1
dh_-).</para>

</sect1>

<sect1>
<title>Target: PHONY</title>

<para>Another important part of debian/rules file but generally of the whole
world of makefiles are PHONY targets; targets which don't actually create a
file, but do something.</para>

<para>You can have add "phony" targets to your debian/rules file too (usually
are placed by default as end line); targets which don't actually create a file,
but do something. These are created like normal targets: for instance, to add a
"all" target to our makefile we would add :</para>

<screen> 
all: foo 
</screen>

<para>Make sure that file "all" it's not your build directory, if not the rule
won't run correctly. So we can tell make that this is a phony target and should
be rebuilt always this is by using the target .PHONY. so, we can add to our
Makefile:</para>

<screen>
.PHONY: all 
</screen>

<para>In fact these rule's commands won't create any target file, but will be
executed every time the target comes up for remaking. Common example is the
clean one:</para>

<screen>
.PHONY : clean 
clean: 
rm -.h 
</screen>

<para>Once this has been definied, <application>make clean</application> will
run the commands with every file named
<application>clean</application>.</para>

</sect1>


<sect1>
<title>Usefull Links</title>

<para>If you liked this wiki page and you want to learn more about makefiles or
generally debian policies, I suggest you to look at these usefull links around
the web to intensify your future work on debian/rules file, but generally on
makefiles:</para>

       <orderedlist>

        <listitem><para>Gnu Make Official Guide: http://www.gnu.org/software/make/</para></listitem>

        <listitem><para>Packaging Policy: http://www.debian.org/doc/maint-guide/</para></listitem>

        <listitem><para>Debian Source Policy: http://www.debian.org/doc/debian-policy/ch-source.html</para></listitem>

       </orderedlist>

</sect1>

</chapter>
