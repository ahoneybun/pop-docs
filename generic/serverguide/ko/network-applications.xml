<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" 
	"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % globalent SYSTEM "../../../libs/global.ent">
%globalent;
<!ENTITY % genericent SYSTEM "../../libs/generic.ent">
%genericent;
<!ENTITY % cdo-C SYSTEM "../../../libs/cdo-C.ent">
%cdo-C;
<!ENTITY % gnome-menus-C SYSTEM "../../../ubuntu/libs/gnome-menus-C.ent">
%gnome-menus-C;
<!ENTITY % xinclude SYSTEM "../../../libs/xinclude.mod">
%xinclude;
<!ENTITY language "&EnglishAmerican;">
]>
<chapter id="networking" status="complete">
	<title>네트워킹</title>
  <para>네트워크는 연결된 장치 간에 정보를 공유하고 배포할 목적으로 실제 케이블 또는 무선 링크로 연결된 컴퓨터 시스템, 프린터, 그리고 관련되는 장비와 같은 두 개 이상의 장치로 구성 됩니다.</para>
  <para>우분투 서버 안내서의 이 영역은 네트워크 개념의 개괄적인 설명과 잘 알려진 네트워크 프로토콜과 서버 프로그램의 자세한 논의를 포함하는, 네트워킹에 속하는 일반적이고 특정한 정보를 제공 합니다.</para>
	<sect1 id="network-configuration" status="complete">
		<title>네트워크 설정</title>
          <para>우분투는 여러분의 네트워크 장치를 설정할 수 있는 몇 가지 그래픽 유틸리티를 제공 합니다. 이 문서는 서버 관리자를 위하여 작성되었고 명령어 라인에서 여러분의 네트워크를 관리하는 것에 중점 합니다.</para>
      <sect2 id="ethernet" status="complete">
        <title>이더넷</title> 
          <para>대부분 이더넷 설정은 <filename>/etc/network/interfaces</filename> 파일 하나에 중앙화 되었습니다. 만약 여러분이 이더넷 장치를 가지고 있지 않다면, 이 파일에는 오직 loopback 인터페이스만 보일 것이고, 그것은 다음과 비슷하게 보일 겁니다: <screen># This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback
address 127.0.0.1
netmask 255.0.0.0</screen> 만약 여러분이 오직 하나의 이더넷 장치, eth0를 가지고 있고, 그것이 DHCP 서버에서 설정을 가지고 부트 시에 자동으로 올라와야 한다면, 다음의 두 줄이 더해지는 것이 필요 합니다: <screen>auto eth0
iface eth0 inet dhcp</screen> 첫 번째 줄은 eth0 장치가 여러분이 부팅을 할 때 자동적으로 올라와야 한다는 것을 지정 합니다. 두 번째 줄은, 인터페이스 (<quote>iface</quote>) eth0는 IPv4 주소 체계를 (IPv6 장치를 위해서는 <quote>inet</quote> 를 <quote>inet6</quote> 로 대체함) 가지고 DHCP에서 자동적으로 그 장치의 설정을 가져야 한다는 것을, 의미 합니다. 여러분의 네트워크와 DHCP 서버가 올바르게 설정되었음을 가정하고, 이 기계의 네트워크는 올바르게 동작하기 위해 더 이상의 설정을 필요로 하지 않습니다. DHCP 서버는 기본 설정 게이트웨이(<application>route</application> 명령을 통하여 이행되는), 장치의 IP 주소(<application>ifconfig</application> 명령을 통하여 이행되는), 그리고 네트워크 상에서 사용되는 DNS 서버를(<filename>/etc/resolv.conf</filename> 파일에 이행되는) 제공 합니다.</para>
		<para>여러분의 이더넷 장치를 고정 IP 주소와 여러분에 맞는 설정값으로 설정을 하려면, 몇 가지 정보가 더 필요 합니다. eth1 장치에 192.168.0.2 IP 주소를, 일반적인 255.255.255.0 netmask와 함께 지정하기를 원한다고 생각해 봅니다. 여러분의 기본 설정 게이트웨이의 IP 주소는 192.168.0.1 입니다. <filename>/etc/network/interfaces</filename> 파일에 다음과 같이 입력을 합니다: <screen>iface eth1 inet static
	address 192.168.0.2
	netmask 255.255.255.0
	gateway 192.168.0.1</screen> 이 경우에는, <filename>/etc/resolv.conf</filename> 파일에 여러분의 DNS 서버를 수동으로 지정하는 것이 필요하고, 이것과 비슷할 겁니다: <screen>search mydomain.com
nameserver 192.168.0.1
nameserver 4.2.2.2</screen> <emphasis role="italics">search</emphasis> 지시자는 여러분의 네트워크 상의 이름을 해결하기 위한 시도를 할 때 mydomain.com을 호스트 이름 질의에 추가하게 됩니다. 예를 들어, 만약 여러분의 네트워크 도메인이 mydomain.com 이고, 여러분이 호스트 <quote>mybox</quote> 에 ping을 시도하면, 그 DNS 질의는 이름의 파악을 위하여 <quote>mybox.mydomain.com</quote> 으로 변경 됩니다. <emphasis role="italics">nameserver</emphasis> 지시자는 호스트 이름을 IP 주소로 해결하기 위하여 사용되는 DNS 서버를 지정 합니다. 만약 여러분 소유의 네임서버를 사용하면, 그것을 여기에 입력 하십시오. 그렇지 않다면, 여러분의 인터넷 서비스 제공자에게 사용할 우선(primary) 그리고 이차(secondary) DNS 서버를 문의하고, 그것들을 위에 보인 것과 같이 <filename>/etc/resolv.conf</filename> 파일에 입력 합니다.</para>
		<para>다이얼업 PPP 인터페이스, IPv6 네트워킹, VPN 장치, 기타 등등을 포함하는 많은 다른 설정들이 가능합니다. 더 많은 정보와 지원되는 선택 사항들은 <application>man 5 interfaces</application> 를 참조 하십시오. 기억해야 할 것은,  <filename>/etc/network/interfaces</filename> 파일은 <application>ifup</application>/<application>ifdown</application> 스크립트에 의하여 사용되고, 그것들은 다른 리눅스 배포판에서 사용되는 것보다 높은 수준의(역주:사용의 편의를 기했다는 의미) 설정 체계 입니다. <application>ifconfig</application>, <application>route</application>, 그리고 <application>dhclient</application> 와 같은 전통적이고, 낮은 수준의(역주:명령어 라인에 직접 입력해야 한다는 의미) 유틸리티는 여전히 ad hoc 설정을 위하여 사용 가능 합니다.</para>
      </sect2>
      <sect2 id="managing-dns-entries" status="complete">
          <title>DNS 항목 관리</title>
            <para>이 영역은 IP 주소를 호스트 이름으로 파악을 하고 또 그 반대로 알아내는데 사용하는 네임서버를 어떻게 설정하는지에 대한 설명을 합니다. 이것은 시스템을 하나의 네임 서버로 어떻게 구축하는지를 설명하지는 않습니다.</para>
            <para>DNS 항목을 관리하려면, 여러분은 <filename>/etc/resolv.conf</filename> 파일에서 DNS 이름을 추가, 편집 또는 삭제할 수 있습니다. <ulink url="../sample/resolv.conf">예제 파일</ulink>이 아래와 같이 주어집니다:</para>
<programlisting>
search com
nameserver 204.11.126.13
nameserver 64.125.134.133
nameserver 64.125.134.132
nameserver 208.185.179.218
</programlisting>
            
            <para><application>search</application> 키는 불완전한 호스트 이름에 더하여지는 문자를 지정 합니다. 여기에, 우리는 그것을 <application>com</application> 으로 언급하였습니다. 그러므로, 우리가 다음과 수행할 때: <command>ping ubuntu</command> 은 <command>ping ubuntu.com</command> 으로 해석되어 집니다.</para> 

            <para><application>nameserver</application> 키는 네임서버 IP 주소를 지정 합니다. 그것은 주어진 IP 주소 또는 호스트 이름을 해결하기 위하여 사용 됩니다. 이 파일은 복수 개의 nameserver 항목을 가질 수 있습니다. 네임서버들은 적힌 것과 같은 순서로 네트워크 질의에 사용 됩니다.</para>

            <warning>
            <para>만약 DNS 서버 이름이 동적으로 DHCP 또는 PPPOE (여러분의 ISP에서) 읽혀졌다면, 이 파일에 nameserver 항목을 추가하지 마십시오. 그것은 자동적으로 업데이트 됩니다.</para>
            </warning>

            <warning>
            <para>여러분이 <filename>/etc/resolv.conf</filename>에 변경한 것은 시스템을 재시작하면 지워지게 됩니다. 만약 이 변경을 영구적으로 만들고자 한다면, 여러분은 <application>resolvconf</application> 패키지를 설치하고 그 패키지가 제공하는 <filename>/etc/resolvconf/resolv.conf.d/base</filename> 파일 내의 DNS 정보를 업데이트해야만 합니다.</para>
            </warning>
        </sect2>
        <sect2 id="managing-hosts" status="complete">
          <title>호스트 관리</title>
            <para>호스트를 관리하기 위하여, 여러분은 <filename>/etc/hosts</filename> 파일에서 호스트를 추가, 편집 또는 삭제할 수 있습니다. 그 파일은 IP 주소와 그에 대응하는 호스트 이름을 가집니다. 여러분의 시스템이 호스트 이름으로 IP 주소를 해결하거나 IP 주소로 호스트 이름을 결정할 때, 그것은 네임서버를 사용하기 전에 <filename>/etc/hosts</filename> 파일을 참조 합니다. 만약 그 IP 주소가 <filename>/etc/hosts</filename> 파일 내에 열거되었다면, 네임서버는 사용되지 않습니다. 이 동작은 여러분이 위험을 감수하는 것을 전제로 <filename> /etc/nsswitch.conf</filename> 파일을 편집하는 것으로 변경될 수 있습니다.</para>

            <para>만약 여러분의 네트워크이 DNS에 나열되지 않은 IP 주소를 가지는 컴퓨터들을 가지고 있다면, 그것들을 <filename>/etc/hosts</filename> 파일에 추가하는 것을 권장 합니다.</para>
        </sect2>
    </sect1>
	<sect1 id="tcpip" status="complete">
		<title>TCP/IP</title>
          <para>Transmission Control Protocol and Internet Protocol (TCP/IP) 는 1970년대 후반에 Defense Advanced Research Projects Agency (DARPA) 에 의하여 개발된 프로토콜의 표준화된 규격이고 다른 종류의 컴퓨터와 컴퓨터 네트워크 간에 통신을 하기 위한 수단 입니다. TCP/IP 는 인터넷을 주도하는 힘이고, 그러므로 그것은 지구상의 네트워크 프로토콜 중에 가장 인기있는 규약 입니다.</para>
      <sect2 id="tcpip-introduction" status="complete">
        <title>TCP/IP 소개</title> 
          <para>TCP/IP의 두 가지 프로토콜 요소는 컴퓨터 네트워킹의 다른 측면을 다룹니다. <emphasis>Internet Protocol</emphasis>, TCP/IP의 "IP"는 네트워크 정보의 기본 단위로서 <emphasis role="italics">IP datagram</emphasis> 을 사용하는 네트워크 패킷 라우팅만을 다루는 접속이 없는 프로토콜 입니다. TCP/IP의 "TCP" 는 <emphasis> Transmission Control Protocol</emphasis> 이고, 네트워크 호스트들이 데이터 스트림을 교환하기 위하여 사용될 수 있는 접속을 이루기 위해 활성화 합니다. TCP는 또한 접속들 간에 자료가 한 네트워크 호스트에서 주고 받는 것과 마찬가지로 다른 네트워크 호스트에서 보내지는 것도 보장 합니다.</para>
          </sect2>
        <sect2 id="tcpip-configuration" status="complete">
          <title>TCP/IP 설정</title>
            <para>TCP/IP 프로토콜 설정은, 해당 설정 파일들을 편집하거나, 적당한 TCP/IP 설정 값을 네트워크 클라이언트에게 자동적으로 제공하기 위하여 사용하는 Dynamic Host Configuration Protocol (DHCP) 서버와 같은 솔루션을 적용하는 것에 의해, 반드시 지정되는 여러가지 요소로 구성 합니다. 이 설정 값들은 여러분의 우분투 시스템의 적절한 네트워크 동작의 편의를 위하여 반드시 정확하게 지정되어야 합니다.</para>
            <para>TCP/IP의 공통적인 설정 요소와 그들의 목적은 다음과 같습니다: <itemizedlist>
               <listitem>
                  <para><emphasis role="bold">IP address</emphasis> IP 주소는, 점으로 구분되는 네 개의 0부터 255까지의 십진수 범위의 숫자들이고, 각각의 네 숫자는 전체 주소를 위한 총 32 bits의 8 bits 주소를 표현하는, 유일한 식별자 입니다. 이러한 형식은 <emphasis>dotted quad notation</emphasis> 라 불립니다.</para>
               </listitem>
               <listitem>
                  <para><emphasis role="bold">Netmask</emphasis> 서브넷 마스크는 (또는 간략하게, <emphasis>netmask</emphasis>) 네트워크 상의 비트 마스크, 또는 네트워크에 중요한 IP 주소에서 <emphasis>subnetwork</emphasis> 에 중요한 비트를 구분하는 부분인 플랙의 집합 입니다. 예를 들어, 클래스 C 네트워크에서, 표준 netmask는 255.255.255.0 이고, IP 주소의 첫 3 바이트는 차폐하고 IP 주소의 마지막 바이트는 서브 네트워크 상의 호스트를 지정하기 위해 사용하도록 남겨지는 것을 허용 합니다.</para>
               </listitem>
               <listitem>
                  <para><emphasis role="bold">Network Address</emphasis> 네트워크 주소는 IP 주소의 네크워크 부분을 구성하는 바이트를 표현 합니다. 예를 들어, 클래스 A 네트워크 내의 12.128.1.2 호스트는 네트워크 주소로 12.0.0.0을 사용하고, 그 IP 주소의 첫 번째 바이트인 12가 그것을 표현 합니다 (네트워크 부분). 0으로 표시되는 남겨진 세 바이트는 가능한 호스트 값을 표시하기 위해서 입니다. 아주 일반적인 사적 그리고 라우팅을 할 수 없는 192.168.1.100과 같은 IP 주소를 사용하는 네트워크 호스트는 192.168.1.0의 네트워크 주소를 사용하는 것이고, 클래스 C 인 192.168.1 네트워크와 그 네트워크 상에서 가능한 모든 호스트를 위한 마지막 자리의 0을 지정하는 것 입니다.</para>
               </listitem>
               <listitem>
                  <para><emphasis role="bold">브로드캐스트 주소</emphasis> 브로드캐스트 주소는 특정 네트워크 호스트를 지정하는 대신에 주어진 서브네트워크 상의 모든 호스트들에게 일제히 네트워크 데이터가 보내지는 것을 허용하는 IP 주소 입니다. IP 네트워크를 위한 표준화된 일반적 브로드캐스트 주소는 255.255.255.255 이지만, 이 브로드캐스트 주소는 라우터에 의하여 막히기 때문에 인터넷 상의 모든 호스트로 브로드캐스트 메세지를 보내는데 사용할 수는 없습니다. 좀 더 적당한 브로드캐스트 주소는 특정 서브네트워크에 일치하도록 지정을 합니다. 예를 들어, 잘 알려진 사설 C 클래스 IP 네트워크, 192.168.1.0 상의 브로드캐스트 주소는 192.168.1.255로 설정되어야 합니다. 브로드캐스트 메세지는 Address Resolution Protocol (ARP) 와 Routing Information Protocol (RIP) 같은 네트워크 프로토콜에 의하여 일반적으로 생산이 됩니다.</para>
               </listitem>
               <listitem>
                  <para><emphasis role="bold">게이트웨이 주소</emphasis> 게이트웨이 주소는 특정 네트워크 또는 네트워크 상의 호스트로 접근하기 위하여 통해야 하는 IP 주소 입니다. 만약 한 네트워크 호스트가 같은 네트워크 상에 위치하지 않은 다른 네트워크 호스트와 통신을 하기를 원한다면, 하나의 <emphasis>게이트웨이</emphasis>를 반드시 사용하여야 합니다. 많은 경우에, 게이트웨이 주소는 같은 네트워크 상의 라우터의 주소가 되고, 인터넷 호스트와 같은 다른 네트워크 또는 호스트로 트래픽을 넘기는데도 사용이 됩니다. 게이트웨이 주소 설정 값은 반드시 정확하여야 하고, 그렇지 않다면 여러분의 시스템은 같은 네트워크 밖에 있는 어떠한 호스트로도 접근을 하는 것이 불가능 합니다.</para>
               </listitem>
               <listitem>
                  <para><emphasis role="bold">네임서버 주소</emphasis> 네임서버 주소는 도메인 네임 서비스(DNS)의 IP 주소를 나타내고, 네트워크 호스트 이름을 IP 주소로 알아내는 역할을 합니다. 네임서버 주소의 세 가지 수준이 있고, 그것을 중요도의 순서로 지정하면: <emphasis>우선(일차)</emphasis> 네임서버, <emphasis>이차</emphasis> 네임서버, 그리고 <emphasis>삼차</emphasis> 네임서버 입니다. 여러분의 시스템이 네트워크 호스트 이름으로 그들에 대응하는 IP 주소를 알아내기 위해서는, 여러분은 시스템의 TCP/IP 설정에 여러분이 사용할 수 있게 허가된 올바른 네임서버 주소를 반드시 지정을 해야 합니다. 많은 경우에 이 네임서버 주소는 여러분의 네트워크 서비스 제공자에 의해서 제공될 수 있고 제공되어 지지만, 많은 무료 그리고 공개적으로 접근이 가능한 4.2.2.1 에서 4.2.2.6 까지의 IP 주소를 가지는 Level3 (Verizon) 서버와 같은 네임서버들이 사용가능 합니다.</para>
                     <tip>
                        <para>IP 주소, 넷마스크, 네트워크 주소, 브로드캐스트 주소, 그리고 게이트웨이 주소는 전형적으로 <filename>/etc/network/interfaces</filename> 파일 내에 해당 지시자를 사용하여 지정 됩니다. 네임서버 주소는 <filename>/etc/resolv.conf</filename> 파일 내에 <emphasis>nameserver</emphasis> 지시자를 통해 일반적으로 지정 됩니다. 더 많은 정보는, 터미널 프롬프트에서 다음의 명령을 사용하여, <filename>interfaces</filename> 또는 <filename>resolv.conf</filename> 를 위한 시스템 지침서를 읽어 보십시오:</para>
                     </tip>
                    <para><filename>interfaces</filename> 를 위한 시스템 매뉴얼 페이지는 다음의 명령으로 접근 합니다:</para>
                    <para>
<screen>
<command>man interfaces</command>
</screen>
                    </para>
                    <para><filename>resolv.conf</filename> 를 위한 시스템 매뉴얼 페이지는 다음의 명령으로 접근 합니다:</para>
                    <para>
<screen><command>man resolv.conf</command></screen>
                    </para>
               </listitem>
            </itemizedlist></para>
        </sect2>
        <sect2 id="ip-routing" status="complete">
          <title>IP 라우팅</title>
            <para>IP 라우팅은 네트워크 데이터가 보내지는 TCP/IP 네트워크 상에서 경로를 지정하고 찾기 위한 수단 입니다. 라우팅은 보내는 곳에서 받는 곳으로 네트워크 데이터 패킷을 전달하기 위한 지시를 위하여 <emphasis>routing tables</emphasis> 의 집합을 사용하고, 종종 <emphasis>routers</emphasis> 라고 알려진 네트워크 상의 많은 중간 지점을 경유 합니다. IP 라우팅의 두 가지 주요 형태가 있습니다: <emphasis>Static Routing(정적 라우팅)</emphasis> 과 <emphasis>Dynamic Routing(동적 라우팅)</emphasis></para>
            <para>
            Static routing involves manually adding IP routes to the system's routing table, and this is usually
            done by manipulating the routing table with the <application>route</application> command. Static routing enjoys
            many advantages over dynamic routing, such as simplicity of implementation on smaller networks, 
            predictability (the routing table is always computed in advance, and thus the route is precisely the 
            same each time it is used), and low overhead on other routers and network links due to the lack of a
            dynamic routing protocol.  However, static routing does present some disadvantages as well.  For example,
            static routing is limited to small networks and does not scale well.  Static routing also fails completely
            to adapt to network outages and failures along the route due to the fixed nature of the route. 
            </para>
            <para>동적 라우팅은 보낸 곳에서 받는 곳까지 복수의 가능한 IP 라우트를 가지는 규모카 큰 네트웨크에 의존하고, 동적 라우팅이 가능하도록 라우팅 테이블의 자동 조정을 처리하는 Router Information Protocol (RIP) 과 같은 특별한 라우팅 프로토콜을 사용 합니다. 동적 라우팅은 정적 라우팅에 비해 여러가지 장점을 가집니다. 휼륭한 확장성, 네트워크 라우터의 실패와 중단에 적응하는 능력 등이 장점 입니다. 추가하여, 라우터가 다른 라우터의 존재와 가능한 경로를 스스로 배우기 때문에, 라우팅 테이블의 수작업 설정을 줄여 줍니다. 이 특성은 또한 작업자의 오류로 인한 라우팅 테이블의 실수가 일어나는 가능성을 제거 합니다. 하지만, 동적 라우팅은 완벽하지 않고, 계층적으로 복잡함과 라우터 통신의 추가적인 네트워크 오버헤드(최종 사용자에게는 직접적으로 이득을 주지않고 네트워크의 밴드위드를 소모하는)와 같은 단점을 가집니다.</para>
        </sect2>
        <sect2 id="tcp-and-udp" status="complete">
          <title>TCP와 UDP</title>
            <para>TCP는 접속 기반 프로토콜이고, 에러 교정과 <emphasis>flow control</emphasis> (흐름 제어)로 알려진 데이터의 배달을 보장하는 것을 제공 합니다. 흐름 제어는 데이터 스트림의 흐름이 중단되는 것이 필요한 때와, 예를 들어, 데이타의 완전하고 정확한 배달을 확신하기 위하여, <emphasis>collisions</emphasis> 과 같은 문제들로 인하여 재전송을 해야하는 이전의 보내진 패킷을 결정합니다. TPC는 전형적으로 데이타베이스 트랜잭션과 같은 중요한 정보를 교환하는 데에 사용되어 집니다.</para>
            <para>한편, User Datagram Protocol (UDP)는, <emphasis>connectionless</emphasis></para>
        </sect2>
        <sect2 id="icmp" status="complete">
          <title>ICMP</title>
            <para>Internet Control Messaging Protocol (ICMP)는 Request For Comments (RFC) #792에 정의된 바와 같이 Internet Protocol (IP)의 확장이고, 제어, 에러 그리고 정보 메세지를 포함하는 네트워크 패킷을 지원 합니다. ICMP는 <application>ping</application> 유틸리티와 같은 네트워크 프로그램에서 사용되고, 네트워크 호스트 또는 장치의 사용 가능함을 결정할 수 있습니다. ICMP에 의해 되돌려지는 몇 가지 에러 메세지의 예는 네트워크 호스트와 라우터와 같은 장치 모두에게 유용하고, <emphasis>Destination Unreachable</emphasis> 과 <emphasis>Time Exceeded</emphasis> 를 포함 합니다.</para>
        </sect2>
        <sect2 id="daemons" status="complete">
          <title>데몬</title>
            <para>데몬은 전형적으로 백그라운드에서 계속적으로 실행되는 그리고 다른 프로그램에서 데몬이 제공하는 기능을 위한 요청을 기다리는 특별한 시스템 응용 프로그램 입니다. 많은 데몬들은 네트워크 중심이고, 우분투 시스템 상의 백그라운드에서 수행되는 많은 수의 데몬들은 네트워크와 관련된 기능을 제공 합니다. 이러한 네트워크 데몬의 몇 가지 예는 웹 서버 기능을 제공하는 <emphasis>Hyper Text Transport Protocol Daemon</emphasis> (httpd), 보안 원격 로그인 쉘과 파일 전송 능력을 제공하는 <emphasis>Secure SHell Daemon</emphasis> (sshd), 그리고 이메일 서비스를 제공하는 <emphasis>Internet Message Access Protocol Daemon</emphasis> (imapd) 등을 포함 합니다.</para>
        </sect2>
    </sect1>
	<sect1 id="firewall-configuration" status="review">
		<title>방화벽 설정</title>
          <para>리눅스 커널은 <emphasis>Netfilter</emphasis> 서브 시스템을 포함하고, 이것은 여러분 서버로 오는 또는 경유하는 네트워크 트래픽을 조작하거나 운명을 결정하는데 사용 됩니다. 모든 현대적인 리눅스 방화벽 솔루션은 패킷을 걸러내기 위하여 이 시스템을 사용 합니다.</para>
        <sect2 id="firewall-introduction" status="review">
          <title>방화벽 소개</title>
            <para>커널의 패킷 필터링 시스템은 그것을 관리하기 위한 사용자 공간의 인터페이스가 없이 시스템 관리자가 약간의 작업을 하는 것이 필요 합니다. 이것은 iptables의 목적 입니다. 패킷이 여러분의 서버에 도착할 때, 패킷은 iptables를 통하여 사용자 공간에서 패킷에 제공되는 규칙에 근거하여 패킷의 수용, 조작 또는 거절을 위한 Netfilter 서브 시스템을 거치게 됩니다. 그러므로, iptables는, 만약 여러분이 그것에 익숙하다면, 여러분의 방화벽을 관리하기 위하여 필요한 전부이고, 작업을 단순화하기 위한 많은 프론트엔드들이 있습니다.</para>
        </sect2>
        <sect2 id="ip-masquerading" status="review">
          <title>IP 마스커레이딩</title>
            <para>IP 마스커레이딩(Masquerading:가장)의 목적은 여러분의 네트워크 상의 사설, 라우팅이 안되는 IP 주소를 가진 기계들이 IP의 가장을 통하여 인터넷을 접근하는 것을 허용하기 위해서 입니다. 여러분의 사설 네트워크에서 인터넷을 목적지로 하는 트래픽은 반드시, 그 요청을 만든 기계로 경로가 되돌아갈 수 있는 응답들을 위하여, 조작되어져야 합니다. 이것을 하기 위하여, 커널은 반드시 각각의 패킷의 <emphasis>source</emphasis> IP 어드레스를 변경하고, 그러므로 응답은 인터넷에서 사용 가능하지 않은 요청을 만든 사설 IP 주소 대신에 변경된 것에 따라 다시 되돌아오게 됩니다. 리눅스는 기계가 속하는 접속과 되돌와오는 패킷을 적절하게 재경로하는 것을 추적하기 위하여 <emphasis>접속 추적</emphasis> (conntrack)을 사용 합니다. 그러므로 여러분의 사설 네트워크를 떠난 트래픽은 여러분의 우분투 게이트웨이 기계로 향할 때 "가장"이 됩니다. 이 절차는 인터넷 접속 공유로 마이크로소프트의 문서에서는 알려져 있습니다.</para>
			<para>이것은 하나의 iptables 규칙을 가지고 완수할 수 있고, 여러분의 네트워크 설정에 따라 약간 다를 수 있습니다: <screen>sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/16 -o ppp0 -j MASQUERADE</screen> 위의 명령은 여러분의 사설 주소 공간이 192.168.0.0/16 이고 인터넷을 사용하는 장치가 ppp0 라고 가정을 합니다. 문법은 다음과 같이 나누어질 수 있습니다: <itemizedlist>
				  <listitem><para>-t nat -- nat 테이블로 가기 위한 규칙</para></listitem>
				  <listitem><para>-A POSTROUTING -- POSTROUTING chain에 덧붙이는(-A) 규칙</para></listitem>
				  <listitem><para>-s 192.168.0.0/16 --  지정된 주소 공간에서 향하는 트래픽에 적용하는 규칙</para></listitem>
				  <listitem><para>-o ppp0 -- 지정된 네트워크 장치를 통하여 경유하도록 스케쥴된 트래픽에 적용하는 규칙</para></listitem>
				  <listitem><para>-j MASQUERADE -- 위에 설명된 대로 이 규칙에 일치하는 트래픽은 조작되기 위한 MASQUERADE 타켓으로 "jump" (-j)</para></listitem>
			  </itemizedlist></para>
			<para>필터 테이블 (대부분 또는 모든 패킷 필터링이 일어나는 기본 설정 테이블) 내의 각 체인은 ACCEPT <emphasis>정책</emphasis> 을 기본값으로 갖지만, 만약 여러분이 게이트웨이 장치에 추가로 방화벽을 설정한다면, DROP 또는 REJECT 정책을 지정할 수 있고, 그 경우에는 여러분의 가장된 트래픽은 위의 규칙이 동작을 하기 위하여 FORWARD 체인을 통하는 것이 허용되어야 합니다: <screen>sudo iptables -A FORWARD -s 192.168.0.0/16 -o ppp0 -j ACCEPT↵
sudo iptables -A FORWARD -d 192.168.0.0/16 -m state --state ESTABLISHED,RELATED -i ppp0 -j ACCEPT</screen> 위의 명령은 여러분의 로컬 네트워크에서 인터넷으로 가는 모든 접속과 그 접속에 관련되는 모든 트래픽이 위의 규칙을 시작한 (즉 여러분의) 기계로 되돌아오는 것을 허용 합니다.</para>
        </sect2>
        <sect2 id="firewall-tools" status="review">
          <title>도구</title>
            <para>두려운 iptables의 지식이 없이도 완전하게 방화벽을 구축할 수 있도록 도와주는 여러가지 도구들이 있습니다. GUI로 편하게 사용할 수 있는 것은, <application>Firestarter</application> 가 아주 유명하고 사용하기도 쉽고, <application>fwbuilder</application> 는 매우 강력하고 Checkpoint FireWall-1과 같은 상업용 방화벽을 사용해 본 시스템 관리자에게 익숙하게 보일 겁니다. 평범한 텍스트 설정 파일을 가지는 명령어 라인 도구를 선호한다면, <application>Shorewall</application> 은 어떠한 네트워크를 위해서도 우수한 방화벽을 설정할 수 있도록 도와주는 매우 강력한 솔루션 입니다. 만약 여러분의 네트워크가 비교적 간단하거나, 또는 네트워크를 가지고 있지 않다면, <application>ipkungfu</application> 를 사용하면 따로 설정하는 것 없이 설치시 바로 동작하는 방화벽을 제공할 것이고, 좀더 발전된 방화벽을 설정하는 것은 간단하고 문서화가 잘 된 설정 파일을 편집하는 것으로 쉽게 만들 수 있습니다. 또다른 흥미로운 도구는 <application>fireflier</application> 이고, 데스크탑 방화벽 프로그램으로 고안된 것 입니다. 이것은 서버 (fireflier-server) 와 여러분이 선택하는 GUI 클라이언트 (GTK 또는 QT) 로 구성되고, 윈도우즈를 위한 많은 유명한 상호작용 방화벽과 같이 동작을 합니다.</para>
        </sect2>
        <sect2 id="firewall-logs" status="review">
          <title>로그</title>
            <para>방화벽 로그는 공격, 방화벽 규칙의 문제 파악, 그리고 여러분 네트워크 상의 비정상적인 행동을 알아낼 수 있는 필수적인 것 입니다. 여러분은 반드시 방화벽 설정에 로그가 만들어지도록 로그 규칙을 포함시키고, 로그 규칙은 어떠한 적용된 끝내기 규칙 (타겟을 가지고 ACCEPT, DROP, 또는 REJECT와 같이 패킷의 운명을 결정하는 규칙) 전에 반드시 오도록 해야 합니다. 예를 들어: <screen>sudo iptables -A INPUT -m state --state NEW -p tcp --dport 80 -j LOG --log-prefix "NEW_HTTP_CONN: "</screen> 로컬 기계에서 포트 80 번의 요청은 dmesg 내의 로그로 만들어지고 다음과 같이 보일 겁니다:</para>
			<para>
			  <programlisting>[4304885.870000] NEW_HTTP_CONN: IN=lo OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=58288 DF PROTO=TCP SPT=53981 DPT=80 WINDOW=32767 RES=0x00 SYN URGP=0</programlisting>
			</para>
			<para>위의 로그는 또한 <filename>/var/log/messages</filename>, <filename>/var/log/syslog</filename>, 그리고 <filename>/var/log/kern.log</filename> 파일에도 나타납니다. 이 동작은 <filename>/etc/syslog.conf</filename> 파일을 적당하게 편집하거나, <application>ulogd</application> 를 설치/설정하고 LOG 대신에 ULOG 타켓을 사용하는 것으로 변경될 수 있습니다.  <application>ulogd</application> 데몬은 사용자 공간의 서버이고 특별히 방화벽을 위한 커널에서 오는 로깅 지시를 듣고, 여러분이 원하는 어떠한 파일, 또는 심지어 <application>PostgreSQL</application> 과 <application>MySQL</application> 데이타베이스로 기록을 할 수 있습니다. 방화벽 로그를 알아보기 쉽게 꾸미는 것은 <application>fwanalog</application>, <application> fwlogwatch</application>, 또는 <application>lire</application> 같은 로그 분석 도구를 사용하는 것으로 간단해 질 수 있습니다.</para>
        </sect2>
    </sect1>
	<sect1 id="openssh-server" status="complete">
		<title>OpenSSH 서버</title>
      <sect2 id="openssh-introduction">
        <title>소개</title> 
           <para>
            This section of the Ubuntu &sg-title; introduces a powerful collection of tools
            for the remote control of networked computers and transfer of data between networked 
            computers, called <emphasis>OpenSSH</emphasis>. You will also learn
            about some of the configuration settings possible with the OpenSSH server application and
            how to change them on your Ubuntu system. 
          </para>
          <para>OpenSSH는 원겨으로 컴퓨터를 조종하거나 컴퓨터 간의 파일을 전송하기 위한 Secure Shell (SSH) 프토토콜 도구들의 자유롭게 사용할 수 있는 버전 입니다. 이러한 기능을 가지는 전통적인 도구들로는, <application>telnet</application> 이나 <application>rcp</application> 가 있지만, 보안이 적용되지 않고 사용될 때 사용자의 암호를 들여다 볼수 있는 텍스트로 전송 합니다. OpenSSH는, 이러한 전통적인 도구들을 효과적으로 대체하는, 서버 데몬과 보안, 암호화된 원격 조종과 파일 전송 동작 기능을 가지는 클라이언트 도구들을 제공 합니다.</para>
          <para>OpenSSH 서버 구성 요소는, <application>sshd</application> 이고, 어떠한 클라이언트 도구이던 클라이언트 접속을 위하여 끊임없이 듣습니다. 접속 요청이 일어났을 때, <application>sshd</application> 는 연결하는 클라이언트 도구의 종류에 따라 올바른 접속을 만듭니다. 예를 들어, 원격 컴퓨터가 <application>ssh</application> 클라이언트 프로그램을 가지고 접속을 한다면, 그 OpenSSH 서버는 인증 후에 원격 조종 세션을 만듭니다. 만약 원격 사용자가 <application>scp</application> 를 가지고 OpenSSH 서버를 연결하면, 그 OpenSSH 서버 데몬은 인증 후에 서버와 클라이언트 간에 안전한 파일 복사를 시작 합니다. OpenSSH는 일반 암호, 공개 키, 그리고 <application>Kerberos</application> 티켓을 포함하는 여러가지 인증 방법을 사용할 수 있습니다.</para>
          </sect2>
        <sect2 id="openssh-installation">
        <title>설치</title>
        <para>OpenSSH 클라이언트와 서버 프로그램의 설치는 간단 합니다. 우분투 시스템에 OpenSSH 클라이언트 프로그램을 설치하려면, 다음의 명령을 터미널 프롬프트에서 사용 합니다:</para>
           <para>
<screen>
<command>sudo apt-get install openssh-client</command>
</screen>
           </para>
        <para>OpenSSH 서버 프로그램과 관련되는 지원 파일을 설치하려면, 다음의 명령을 터미널 프롬프트에서 사용 합니다:</para>
           <para>
<screen>
<command>sudo apt-get install openssh-server</command>
</screen>
           </para>
        </sect2>
        <sect2 id="openssh-configuration">
          <title>설정</title>
            <para>여러분은 OpenSSH 서버 프로그램, <application>sshd</application>, 의 기본 동작을 <filename>/etc/ssh/sshd_config</filename> 파일을 편집하는 것으로 설정할 수 있습니다. 이 파일에서 사용되는 설정 지시자에 대한 정보는, 터미널 프롬프트에서 다음의 명령을 입력하여 해당 매뉴얼 페이지를 보십시오:</para>
               <para>
<screen>
<command>man sshd_config</command>
</screen>
               </para>
            <para><application>sshd</application> 설정 파일에는 통신 설정과 인증 모드 등을 조종하기 위한 많은 지시자들이 있습니다. 다음은 <filename>/etc/ssh/ssh_config</filename> 파일을 편집하는 것으로 변경할 수 있는 설정 지시자들의 예 입니다.</para>
            <tip>
               <para>설정 파일을 편집하기 전에, 원래의 파일을 복사본을 만들고 쓰기에서 그것을 보호해야만 합니다. 그래서 원래의 설정을 참고로 그리고 필요한 경우 재사용할 수 있습니다.</para>
               <para><filename>/etc/ssh/sshd_config</filename> 파일을 복사하고 쓰기에서 그것을 보호하려면, 터미널 프롬프트에서 다음의 명령을 입력 합니다:</para>
	    </tip>
               <para>
<screen>
<command>sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.original</command>
<command>sudo chmod a-w /etc/ssh/sshd_config.original</command>
</screen>
               </para> 
            <para>다음은 여러분이 변경할 수 있는 설정 지시자의 예 입니다:</para>
           <itemizedlist>
               <listitem>
               <para>여러분의 OpenSSH가 기본 설정된 TCP 포트 22 대신에 TCP 포트 2222를 사용하게 하려면, 다음과 같이 Port 지시자를 변경 합니다:</para>
               <para>Port 2222</para>
               </listitem>
	<listitem>
            <para><application>sshd</application> 가 공개 키 기반의 로그인 신뢰서를 허용하게 하려면, 간단히 이 줄을 더하거나 변경 합니다:</para>
               <para>PubkeyAuthentication yes</para>
            <para><filename>/etc/ssh/sshd_config</filename> 파일 내에 있고, 만약 이미 있다면, 그 줄의 주석처리 해제하는 것을 확신 하십시오.</para>
            </listitem>
            <listitem>
             <para>여러분의 OpenSSH 서버가 선-로그인 배너로 <filename>/etc/issue.net</filename> 파일의 내용을 표시하게 만드려면, 간단히 이 줄을 더하거나 변경 합니다:</para>
               <para>Banner /etc/issue.net</para>
               <para><filename>/etc/ssh/sshd_config</filename> 파일 내에 있습니다.</para>
             </listitem>
             </itemizedlist>
	    <para><filename>/etc/ssh/sshd_config</filename> 파일에 변경을 만든 후에, 그 파일을 저장하고, 변경의 효과를 가지려면 다음 명령을 터미널 프롬프트에서 사용하여 <application>sshd</application> 서버 프로그램을 재시작 합니다:</para>
               <para>
<screen>
<command>sudo /etc/init.d/ssh restart</command>
</screen>
               </para>
		<warning>
                           <para><application>sshd</application> 를 위한 많은 다른 설정 지시자는 여러분의 필요에 맞게 그 서버 프로그램의 동작을 변경하는 것을 위하여 사용가능 합니다. 그러나, 만약 여러분이 서버를 접근할 수 있는 오직 한 가지 방법이 <application>ssh</application> 이고, <filename>/etc/ssh/sshd_config</filename> 파일을 통해 <application>sshd</application> 를 설정하는데 실수를 하였다면, 서버를 재시작할 때 잠겨지거나 <application>sshd</application> 서버가 부정확한 설정 지시자 때문에 시작하는 것이 거부될 수 있음을 조언 합니다. 그러므로 원격 서버 상의 이 파일을 편집할 때는 정말로 조심스럽게 하시기 바랍니다.</para>
                        </warning>
        </sect2>
   <sect2 id="openssh-references" status="complete">
      <title>참조</title>
      <para>
      <ulink url="http://www.openssh.org/">OpenSSH 웹사이트</ulink>
      </para>
      <para>
      <ulink url="https://wiki.ubuntu.com/AdvancedOpenSSH">진보한 OpenSSH 위키 페이지</ulink>
      </para>
   </sect2>
     </sect1>
	<sect1 id="ftp-server" status="complete">
        <title>FTP 서버</title> 
            <para>파일 전송 프로토콜 (FTP)는 컴퓨터들 간에 파일을 올리고 내려받기 위한 TCP 프로토콜 입니다. FTP는 클라이언트/서버 모델로 동작을 합니다. 서버 구성 요소는 <emphasis>FTP 데몬</emphasis>으로 불립니다. 그것은 원격지 클라이언트에서의 FTP 요청을 계속적으로 듣습니다. 요청이 접수될 때, 그것은 로그인을 관리하고 접속을 만들어 줍니다. 세션이 지속되는 동안 그것은 FTP 클라이언트에서 보내지는 어떠한 명령도 실행을 합니다.</para>
            <para>FTP 서버로 접근하는 것은 다음의 두 가지 방법으로 관리할 수 있습니다:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>익명</para>
                </listitem>
                <listitem>
                    <para>인증</para>
                </listitem>
            </itemizedlist>
            <para>익명 모드에서는, 원격 클라이언트는 "anonymous" 또는 "ftp" 로 불리는 기본 설정 사용자 계정을 사용하고 암호는 이메일 주소를 보내는 것으로 FTP 서버를 접근할 수 있습니다. 인증 모드에서는, 사용자는 반드시 계정과 암호를 가지고 있어야 합니다. 사용자는 FTP 서버 디렉토리와 파일을 로그인 시에 사용되는 계정을 위하여 지정된 접근 권한에 따라 접근할 수 있습니다. 일반적인 규칙으로, FTP 데몬은 FTP 서버의 루트 디렉토리를 감추고 FTP 홈 디렉토리로 그것을 바꿉니다. 이것은 파일 시스템의 여타 부분도 원격 세션에게는 감춥니다.</para>
            <sect2 id="vsftpd-ftp-server-installation" status="complete">
                <title>vsftpd - FTP 서버 설치</title>
                    <para>vsftpd 는 우분투에서 사용할 수 있는 FTP 데몬 입니다. 이것은 설치, 설정, 그리고 관리하기가 쉽습니다. <application>vsftpd</application> 를 설치하려면 다음의 명령을 실행 합니다: <screen> <command>sudo apt-get install vsftpd</command> </screen></para>

                </sect2>
            <sect2 id="vsftpd-ftp-server-configuration" status="complete">
                <title>vsftpd - FTP 서버 설정</title>
                <para>기본 설정된 값을 변경하기 위하여 vsftpd 설정 파일, <filename>/etc/vsftpd.conf</filename> 을 편집할 수 있습니다. 기본 설정은 오직 익명 FTP 만이 허용 됩니다. 만약 이 선택 사항을 비 사용하려면, 다음의 줄을 반드시 변경하여야 합니다: <programlisting>
anonymous_enable=YES
</programlisting> to <programlisting>
anonymous_enable=NO
</programlisting> 기본 설정 값으로, 로컬 시스템(FTP 서버가 실행되는 시스템) 사용자는 FTP 서버로 로그인 하는 것이 허용되지 않습니다. 이 설정 값을 변경하려면, 다음 줄의 주석을 해제하여야만 합니다: <programlisting>
#local_enable=YES
</programlisting> 기본 설정으로, 사용자는 FTP 서버에서 파일을 내려받는 것은 허용이 되지만, FTP 서버로 파일을 올리는 것은 허용되지 않습니다. 이 설정 값을 변경하려면, 다음 줄의 주석을 해제하여야만 합니다: <programlisting>
#write_enable=YES
</programlisting> 비슷하게, 기본 설정으로, 익명 사용자는 FTP 서버로 파일을 업로드하는 것이 허용되지 않습니다. 이 설정 값을 변경하려면, 다음 줄의 주석을 해제하여야만 합니다: <programlisting>
#anon_upload_enable=YES
</programlisting> 설정 파일은 많은 설정 파라미터들로 이루어 집니다. 각각의 파라미터에 대한 정보는 그 설정 파일 내에 사용가능 합니다. 다른 방법으로는, <command>man 5 vsftpd.conf</command> 하여 각 파라미터의 자세한 것을 man 페이지에서 참조 하십시오.</para>
                <para><application>vsftpd</application> 를 설정했으면 데몬을 시작할 수 있습니다. <application>vsftpd</application> 데몬을 시작하려면 다음의 명령을 실행 합니다: <screen> <command>sudo /etc/init.d/vsftpd start</command> </screen></para>
				<note><para>설정 파일에 기본 설정된 것은 보안의 사유를 위하여 지정된 것임을 주의 하십시오. 위의 변경된 각각은 시스템을 덜 보안적으로 할 수 있으므로, 그것들이 꼭 필요한 경우에만 변경을 하십시오.</para></note>
                </sect2>
    </sect1>
	<sect1 id="network-file-system" status="complete">
		<title>네트워크 파일 시스템 (NFS)</title>
          <para>NFS는 네트워크 상의 다른 사람과 디렉토리와 파일을 공유하는 시스템을 허용 합니다. NFS를 사용하는 것으로, 사용자와 프로그램은 원격지 시스템 상의 파일을 로컬 파일을 사용하는 것과 거의 비슷하게 접근할 수 있습니다.</para>

          <para>NFS가 제공하는 가장 주목할 만한 혜택의 몇 가지는 다음과 같습니다:</para>

          <itemizedlist>
          <listitem>
      <para>로컬 워크스테이션은 공통적으로 사용되는 데이터가 단일 기계에 저장되고 네트워크 상의 다른 것을 여전히 접근할 수 있기 때문에 보다 적은 디스크 공간을 사용 합니다.</para>
          </listitem>
          <listitem>
      <para>사용자가 모든 네트워크 기계들에 분리된(각각의) 홈 디렉토리를 가질 필요가 없습니다. 홈 디렉토리는 NFS 서버 상에 만들어질 수 있고 네트워크를 통하여 사용할 수 있습니다.</para>
          </listitem>
          <listitem>

      <para>플로티 디스크, CDROM 드라이브, 그리고 USB 드라이브와 같은 저장 장치들은 네트워크 상의 다른 기계에 의하여 사용될 수 있습니다. 이것은 네트워크 전체의 탈착실 미디어 드라이브의 숫자를 줄일지도 모릅니다.</para>
          </listitem>
          </itemizedlist>

      <sect2 id="nfs-installation" status="complete">
        <title>설치</title>
      
          <para>NFS 서버를 설치하기 위하여 다음의 명령을 터미널 프롬프트에서 입력 합니다:</para>
          <para>
<screen>
<command>sudo apt-get install nfs-kernel-server</command>
</screen>
          </para>
      </sect2>
      <sect2 id="nfs-configuration" status="complete">
        <title>설정</title>
          <para><filename>/etc/exports</filename> 파일에 디렉토리를 추가하는 것으로 내보낼 디렉토리를 설정할 수 있습니다. 예는:</para>
          <para>
<screen>
/ubuntu *(ro,sync,no_root_squash)
/home *(rw,sync,no_root_squash)
</screen>
          </para>

          <para>호스트 이름 형식의 하나를 *로 대체할 수 있습니다. 호스트 이름 정의를 가능한 지정하여 원하지 않는 시스템이 NFS 마운트를 접근할 수 없도록 합니다.</para>

          <para>NFS 서버를 시작하기 위하여, 다음의 명령을 터미널 프롬프트에서 실행할 수 있습니다:</para>
          <para>
<screen>
<command>sudo /etc/init.d/nfs-kernel-server start</command>
</screen>
          </para>
      </sect2>
      <sect2 id="nfs-client-configuration" status="complete">
        <title>NFS  클라이언트 설정</title>
          <para>다른 기계에서 공유된 NFS 디렉토리를 마운트하려면 <application>mount</application> 명령을 사용하고, 터미널 프롬프트에서 다음의 명령과 비슷하게(각자의 경우에 맞게) 명령을 입력 합니다:</para>
          <para>
<screen>
<command>sudo mount example.hostname.com:/ubuntu /local/ubuntu</command>
</screen>
</para>
      <warning>
      <para>마운트 위치 디렉토리 <filename>/local/ubuntu</filename> 반드시 있어야 합니다. <filename>/local/ubuntu</filename> 디렉토리 내에는 파일 또는 서브 디렉토리가 없어야만 합니다.</para>
      </warning>

      <para>다른 기계에서 NFS 공유를 마운트하는 다른 방법은 <filename>/etc/fstab</filename> 파일에 한 줄을 더하는 것 입니다. 그 줄은 NFS 서버의 호스트 이름, 내보내지는 서버 상의 디렉토리, NFS 공유가 마운트되는 로컬 기계 상의 디렉토리를 반드시 기술 합니다.</para>

      <para><filename>/etc/fstab</filename> 파일 내의 그 줄을 위한 일반적인 문법은 다음과 같습니다:</para>
      
      <para>
<programlisting>
example.hostname.com:/ubuntu /local/ubuntu nfs rsize=8192,wsize=8192,timeo=14,intr
</programlisting>
      </para>
      </sect2>
      <sect2 id="nfs-references" status="complete">
        <title>참조</title>
				<para><ulink url="http://nfs.sourceforge.net/">리눅스 NFS에 대해 자주하는 질문</ulink></para>
      </sect2>
    </sect1>
	<sect1 id="dhcp" status="complete">
		<title>동적 호스트 설정 프로토콜 (DHCP)</title>
            <para>동적 호스트 설정 프로토콜 (DHCP) 는, 각각의 네트워크 호스트를 수작업으로 설정하는 것과는 반대로, 서버에서 자동으로 호스트 컴퓨터에 설정값을 지정할 수 있도록 해주는 네트워크 서비스 입니다. 설정된 컴퓨터는 DHCP 클라이언트가 되고 DHCP 서버에서 받은 설정값을 조작할 수 없고, 그 설정은 컴퓨터의 사용자에게 투명 합니다.</para>
            <para>DHCP 서버에 의하여 DHCP 클라이언트로 제공되는 가장 공통적인 설정은 다음과 같습니다:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>IP 주소와 넷마스크</para>
                </listitem>
                <listitem>
                    <para>DNS</para>
                </listitem>
                <listitem>
                    <para>WINS</para>
                </listitem>
            </itemizedlist>
            <para>그러나, DHCP 서버는 다음과 같은 설정 값도 또한 공급을 할 수 있습니다:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>호스트 이름</para>
                </listitem>
                <listitem>
                    <para>도메인 이름</para>
                </listitem>
                <listitem>
                    <para>기본 설정 게이트웨이</para>
                </listitem>
                <listitem>
                    <para>시간 서버</para>
                </listitem>
                <listitem>
                    <para>인쇄 서버</para>
                </listitem>
            </itemizedlist>
            <para>DHCP 사용의 장점은 네트워크가 변경될 때 입니다. 예를 들어, DNS 서버의 주소가 변경되었을 때, DHCP 서버에서만 그 변경이 필요하고, 모든 네트워크 호스트는 DHCP 클라이언트가 DHCP 서버를 읽는 다음 시점에 재 설정됩니다. 이 장점에 더하여, 네트워크에 새로운 컴퓨터를 통합하는 것도 또한 쉽고, IP 주소의 사용 가능성을 점검할 필요가 없습니다. IP 주소의 할당 시 충돌이 일어나는 것도 또한 줄어듭니다.</para>
            <para>DHCP 서버는 다음의 두 가지 방법을 사용하여 설정 값을 제공할 수 있습니다:</para>
            <variablelist>
                <varlistentry>
                    <term>맥 어드레스</term>
                    <listitem>
                        <para>이 방법은, 네트워크로 연결되는 각각의 네트워크 카드의 유일한 하드웨어 주소를 식별하기 위하여 DHCP를 사용하는 것과, DHCP 클라이언트가 네트워크 장치를 사용하는 DHCP 서버로의 요청을 만드는 매번 일정한 설정을 공급하는 것을, 수반 합니다.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>어드레스 풀</term>
                    <listitem>
                        <para>이 방법은, 동적으로 그리고 먼저 오는 것이 먼저 수행되는 기본으로 설정 속성이 공급되는 DHCP 클라이언트에서 IP 주소의 풀 (때때로 한계 또는 범위로 불리는)을 지정하는 것을 수반 합니다. DHCP 클라이언트가 지정한 기간 동안 네트워크 상에 더 이상 있지 않을 때, 설정은 만료되고 다른 DHCP 클라이언트에 의해 사용되도록 주소 풀로 되돌려집니다.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>우분투는 DHCP 서버와 클라이언트 모두를 제공 합니다. 서버는 <application>dhcpd</application> (dynamic host configuration protocol daemon) 입니다. 우분투와 함께 제공되는 클라이언트는 <application>dhclient</application> 이고 요구되는 모든 컴퓨터에 설치되고 자동으로 설정 됩니다. 두 프로그램 모두 설치와 설정이 쉽고 시스템이 부팅할 때 자동적으로 시작 됩니다.</para>
      <sect2 id="dhcp-installation" status="complete">
        <title>설치</title>
          <para>터미널 프롬프트에서, <application>dhcpd</application> 를 설치하기 위하여 다음의 명령을 입력 합니다:</para>
          <para>
<screen>
<command>sudo apt-get install dhcpd</command>
</screen>
          </para>
          <para>여러분은 다음의 출력을 보게 되고, 그것은 다음에 무엇을 해야하는지를 설명 합니다:</para>
          <screen>
Please note that if you are installing the DHCP server for the first
time you need to configure. Please stop (/etc/init.d/dhcp
stop) the DHCP server daemon, edit /etc/dhcpd.conf to suit your needs
and particular configuration, and restart the DHCP server daemon
(/etc/init.d/dhcp start).

You also need to edit /etc/default/dhcp to specify the interfaces dhcpd
should listen to. By default it listens to eth0.

NOTE: dhcpd's messages are being sent to syslog. Look there for
diagnostics messages.

Starting DHCP server: dhcpd failed to start - check syslog for diagnostics.  </screen>
      </sect2>
      <sect2 id="dhcp-configuration" status="complete">
        <title>설정</title>
            <para>설치를 끝내는 오류 메세지는 약간 혼란을 줄 수 있는데, 다음의 절차를 수행해서 그 서비스를 설정 하십시오:</para>
            <para>아주 일반적으로, 여러분은 IP 주소를 불규칙적으로 지정하는 것을 원할 수 있습니다. 이것은 다음과 같이 설정하는 것으로 마칠 수 있습니다:</para>
            <screen>
# Sample /etc/dhcpd.conf
# (add your comments here) 
default-lease-time 600;
max-lease-time 7200;
option subnet-mask 255.255.255.0;
option broadcast-address 192.168.1.255;
option routers 192.168.1.254;
option domain-name-servers 192.168.1.1, 192.168.1.2;
option domain-name "mydomain.org";

subnet 192.168.1.0 netmask 255.255.255.0 {
range 192.168.1.10 192.168.1.100;
range 192.168.1.150 192.168.1.200;
} </screen>
            <para>이것은 DHCP 서버가 클라이언트에 192.168.1.10-192.168.1.100 또는 192.168.1.150-192.168.1.200 범위 내의 한 IP 주소를 주는 결과를 가집니다. 그 주소는, 만약 클라이언트가 특정한 시간 간격을 요청하지 않는다면, 600 초 동안 대여되는 IP 주소 입니다. 한편, 최대한 (허용되는) 대여 기간은 7200 초 입니다. 서버는 또한 클라이언트가 서브넷 마스크로 255.255.255.0, 브로트캐스트 주소로 192.168.1.255, 라우터/게이트웨이 주소로 192.168.1.254, 그리고 DNS 서버로 192.168.1.1과 192.168.1.2를 사용할 것을 "충고" 합니다.</para>
            <para>만약 여러분의 윈도우즈 클라이언트를 위하여 WINS 서버를 지정할 필요가 있다면, 에를 들어, netbios-name-servers 옵션을 포함하는 것이 필요 합니다.</para>
            <screen>
option netbios-name-servers 192.168.1.1; </screen>
            <para>Dhcpd 설정 값은 DHCP 미니-하우투에서 취해졌고, 그것은 <ulink url="http://www.tldp.org/HOWTO/DHCP/index.html">여기</ulink>에서 찾을 수 있습니다.</para>
      </sect2>
      <sect2 id="dhcp-references" status="complete">
        <title>참조</title>
          <para>
            <ulink url="http://www.dhcp-handbook.com/dhcp_faq.html">DHCP에 대해 자주하는 질문</ulink>
          </para>
      </sect2>
    </sect1>
	<sect1 id="dns" status="complete">
		<title>도메인 네임 서비스 (DNS)</title>
            <para>Domain Name Service (DNS) is an Internet service that maps IP addresses and fully
                qualified domain names (FQDN) to one another. In this way, DNS alleviates the need to
                remember IP addresses. Computers that run DNS are called
                <emphasis>name
                servers</emphasis>. Ubuntu ships with <application>BIND</application> (Berkley
                Internet Naming Daemon), the most common program used for maintaining a name
                server on Linux.</para>
            <!-- things to do: IPv6-->
      <sect2 id="dns-installation" status="complete">
        <title>설치</title>
          <para>터미널 프롬프트에서, <application>dns</application>를 설치하기 위하여 다음의 명령을 입력 합니다:</para>
          <para>
<screen>
<command>sudo apt-get install bind</command>
</screen>
          </para>
      </sect2>
      <sect2 id="dns-configuration" status="complete">
        <title>설정</title>
          <para>DNS 설정 파일들은 <filename>/etc/bind</filename> 디렉토리에 저장 됩니다. 주요 설정 파일은 <filename>/etc/bind/named.conf</filename> 이고, 기본 설정 파일의 내용은 아래와 같이 보여집니다:</para>

          <para>
<programlisting>
// This is the primary configuration file for the BIND DNS server named.
//
// Please read /usr/share/doc/bind/README.Debian for information on the 
// structure of BIND configuration files in Debian for BIND versions 8.2.1 
// and later, *BEFORE* you customize this configuration file.
//

include "/etc/bind/named.conf.options";

// reduce log verbosity on issues outside our control
logging {
	category lame-servers { null; };
	category cname { null; };
};

// prime the server with knowledge of the root servers
zone "." {
        type hint;
        file "/etc/bind/db.root";
};

// be authoritative for the localhost forward and reverse zones, and for
// broadcast zones as per RFC 1912

zone "localhost" {
        type master;
        file "/etc/bind/db.local";
};

zone "127.in-addr.arpa" {
        type master;
        file "/etc/bind/db.127";
};

zone "0.in-addr.arpa" {
        type master;
        file "/etc/bind/db.0";
};

zone "255.in-addr.arpa" {
        type master;
        file "/etc/bind/db.255";
};

// add local zone definitions here
include "/etc/bind/named.conf.local";
</programlisting>
          </para>

          <para><application>include</application> 줄은 DNS 선택 사항을 가지는 파일 이름을 지정 합니다. 그 선택 사항 파일 내의 <application>directory</application> 줄은 파일을 어디서 볼 수 있는지 DNS에 알려 줍니다. BIND의 모든 파일은 이 디렉토리를 상대 경로로 사용 합니다.</para>

          <para>
          The file named <filename>/etc/bind/db.root</filename> 
          describes the root name servers in the world. The servers
          change over time, so the
          <filename>/etc/bind/db.root</filename> file must be maintained
          now and then.
          </para>

          <para><application>zone</application> 영역은 마스터 서버를 지정하고, 언급된 파일 태그로 파일에 저장 됩니다. 모든 zone 파일은 세 가지 자원 자료(RRs): SOA RR, NS RR과 PTR RR을 포함 합니다. SOA는 Start of Authority의 축약어 입니다. "@" 는 발생점을 의미하는 특별한 이름 표기 입니다. NS는 네임 서버 자원 자료 입니다. PTR은 도메인 네임 포인터 입니다. DNS 서버를 시작하기 위하여, 터미널 프롬프트에서 다음의 명령을 실행 합니다:</para>
           <para>
<screen>
<command>sudo /etc/init.d/bind start</command>
</screen>
           </para>
          <para>상세한 것은 참조 편에 언급된 문서를 참고할 수 있습니다.</para>
      </sect2>
      <sect2 id="dns-references" status="complete">
        <title>참조</title>
          <para>
            <ulink url="http://www.tldp.org/HOWTO/DNS-HOWTO.html">DNS HOWTO</ulink>
          </para>
      </sect2>
    </sect1>
	<sect1 id="cups" status="complete">
		<title>CUPS - 인쇄 서버</title>
          <para>
            The primary mechanism for Ubuntu printing and print services is the 
			<emphasis role="bold">Common UNIX Printing System</emphasis> (CUPS). 
			This printing system is a freely available, portable printing layer 
			which has become the new standard for printing in most Linux 
			distributions.
          </para>
          <para>CUPS는 인쇄 작업과 대기소를 관리하고, 표준 인터넷 인쇄 프로토콜(IPP)를 사용하여 네트워크 출력을 제공하고, 도트매트릭스부터 레이저까지의 굉장히 큰 범위의 프린터들과 그리고 많은 상호 간의 출력을 지원 합니다. CUPS는 또한 PostScript Printer Description (PPD) 과 네트워크 프린터의 자동 감지를 지원하고, 단순한 웹 기반의 설정과 관리 도구를 가지고 있습니다.</para>
      <sect2 id="cups-installation" status="complete">
        <title>설치</title>
          <para>여러분의 우분투 컴퓨터에 CUPS를 설치하려면, 간단하게 <application>apt-get</application> 명령을 <application>sudo</application> 로 사용하고 첫 번째 파라미터로 설치하고자 하는 패키지를 줍니다. 하나의 완전한 CUPS 설치는 많은 패키지 의존성을 가지지만, 같은 명령어 라인에 그것들을 모두 지정할 수도 있습니다. CUPS를 설치하기 위하여 다음의 명령을 터미널 프롬프트에서 입력 하십시오:</para>
          <para>
<screen>
<command>sudo apt-get install cupsys cupsys-client</command>
</screen>
          </para>
          <para>사용자 암호의 인증되면, 패키지는 내려받아지고 에러없이 설치되어집니다. 설치가 마무리될 때, CUPS 서버는 자동적으로 실행됩니다. 문제가 있고 그것을 확인하려면, <filename>/var/log/cups/error_log</filename>에 있는 에러 로그 파일을 통해 CUPS 서버 오류를 접근할 수 있습니다. 만약 그 에러 로그가 여러분이 직면한 문제를 파악하기 위한 충분한 정보를 보여주지 않는다면, CUPS 로그를 더 자세히 출력하도록 하는 것은 위에 언급된 설정 파일 내의 <emphasis role="bold">LogLevel</emphasis> 지시자를 "debug" 또는 심지어 "debug2"로 변경하는 것에 의하여 증가할 수 있고, 그러면 모든 것을 기록 합니다. 기본 설정된 값은 "info" 입니다. 만약 이 변경을 만들었다면, 여러분의 문제를 해결한 후에, 로그 파일이 너무 크게 되는 것을 막기 위하여 다시 원래의 설정 값으로 되돌리는 것을 기억 하십시오.</para>
      </sect2>
      <sect2 id="cups-configuration" status="complete">
        <title>설정</title>
          <para>Common UNIX Printing System 서버의 동작은 <filename>/etc/cups/cupsd.conf</filename> 파일 내에 포함된 지시자를 통하여 설정 됩니다. CUPS 설정 파일은 아파치 HTTP 서버를 위한 주요 설정 파일과 같은 문법을 따르므로 아파치 설정 파일을 편집하는데 익숙한 사용자들은 CUPS 설정 파일을 편집할 때 쉽다고 느낄 수 있습니다. 처음으로 변경하기를 원하는 설정 값의 몇 가지는 여기에 보여 집니다.</para>
          <tip>
               <para>설정 파일을 편집하기 전에, 원래의 파일의 복사본을 만들고 쓰기에서 그것을 보호해야만 합니다. 그래서 여러분은 원래의 설정을 참조하거나 그리고 필요한 경우 재사용 할 수 있습니다.</para>
               <para><filename>/etc/cups/cupsd.conf</filename> 파일을 복사하고 쓰기에서 그것을 보호하려면, 터미널 프롬프트에서 다음의 명령을 입력 합니다:</para>
               </tip>
               <para>
<screen>
<command>sudo cp /etc/cups/cupsd.conf /etc/cups/cupsd.conf.original</command>
<command>sudo chmod a-w /etc/cups/cupsd.conf.original</command>
</screen>
               </para>
          <itemizedlist>
                <listitem>
                <para><emphasis role="bold">ServerAdmin</emphasis>: CUPS 서버의 지정된 시스템 관리자의 이메일 주소를 설정하기 위한 것이고, 간단히 <filename>/etc/cups/cupsd.conf</filename> 설정 파일을 여러분이 선호하는 텍스트 에디터로 편집하기 위하여 열고, <emphasis role="italics">ServerAdmin</emphasis> 줄을 적절하게 수정을 합니다. 예를 들어, 여러분이 CUPS 서버의 시스템 관리자이고, 이메일 주소가 'bjoy@somebigco.com' 이면, 아래에 보이는 것과 같이 ServerAdmin 줄을 수정 합니다:</para>
                <para>
<screen>
ServerAdmin bjoy@somebigco.com
</screen>
                </para>
                </listitem>
          </itemizedlist>
                <para>CUPS 서버 설정 파일 내의 설정 지시자에 대한 더 많은 예제는, 터미널 프롬프트에서 다음의 명령을 입력하여 관계된 시스템 매뉴얼 페이지를 읽어 보십시오:</para>
               <para>
<screen>
<command>man cupsd.conf</command>
</screen>
               </para>
                               <note>
                <para><filename>/etc/cups/cupsd.conf</filename> 설정 파일에 변경을 만드는 어느 때에나, 터미널 프롬프트에서 다음의 명령을 입력하여 CUPS 서버를 재시작 하는 것이 필요 합니다:</para>
                </note>
                <para>
<screen>
<command>sudo /etc/init.d/cupsys restart</command>
</screen>
                </para>
	<para>CUPS 서버를 위한 몇 가지 다른 설정은 <filename>/etc/cups/cups.d/ports.conf</filename> 파일에 되어 있습니다:</para>
          <itemizedlist>
                <listitem>
                <para><emphasis role="bold">Listen</emphasis>: 우분투 기본 설정에 의하여, CUPS 서버의 설치는 오직 <emphasis>127.0.0.1</emphasis> IP 주소의 루프백 인터페이스만을 듣습니다. CUPS 서버가 실제 네트워크 어댑터의 IP 주소를 듣게 지시하려면, 여러분은 반드시 호스트 이름 또는 IP 주소 중의 하나, 또는 선택적으로, IP 주소/포트 쌍을 Listen 지시자에 추가해야 합니다. 예를 들어, 로컬 네트워크 상의 CUPS 서버의 IP 주소가 <emphasis role="italics">192.168.10.250</emphasis> 이고 이 서브 네트워크 상의 다른 시스템에서 그것을 사용할 수 있도록 만들기를 원한다면, <filename>/etc/cups/cups.d/ports.conf</filename> 파일을 편집하기 위하여 열고, 아래와 같이 Listen 지시자를 추가 합니다:</para>
                <para>
<screen>
Listen 127.0.0.1:631 # existing loopback Listen
Listen /var/run/cups/cups.sock # existing socket Listen
Listen 192.168.10.250:631 # Listen on the LAN interface, Port 631 (IPP)
</screen>
                </para>
                <para>위의 예에서, 만약 여러분이 <application>cupsd </application>가 루프백 인터페이스를 듣는 것을 원하지 않고 Local Area Network(LAN)의 이더넷 인터페이스만을 듣게하려고 한다면, 루프백 주소 (127.0.0.1)을 주석 처리하거나 삭제할 수 있습니다. 루프백을 포함하여, 특정 호스트 이름이 경계를 긋는 모든 네트워크 인터페이스를 듣게 만드려면, 아래와 같이 호스트 이름 <emphasis>socrates</emphasis> 를 위하여 Listen 항목을 만들 수 있습니다:</para>
                <para>
<screen>
Listen socrates:631 # Listen on all interfaces for the hostname 'socrates'
</screen>
                </para> 
				<para>또는 Listen 지시자는 제외하고 대신에 <emphasis>Port</emphasis> 를 사용하여 다음과 같이 할 수 있습니다:</para>
<para>
<screen>
Port 631 # Listen on port 631 on all interfaces
</screen>
</para>
                </listitem>
	</itemizedlist>

      </sect2>
      <sect2 id="cups-references" status="complete">
        <title>참조</title>
        <para>
        <ulink url="http://www.cups.org/">CUPS 웹사이트</ulink>
        </para>
        </sect2>
    </sect1>
	<sect1 id="httpd" status="complete">
		<title>HTTPD - 아파치2 웹 서버</title>
      <para>Apache is the most commonly used Web Server on Linux systems. Web Servers are used
          to serve Web Pages requested by client computers. Clients typically request and view
          Web Pages using Web Browser applications such as <application>Firefox</application>,
              <application>Opera</application>, or <application>Mozilla</application>.</para>
      <para>사용자는 웹 서버를 가리키기 위하여 완전히 지정된 도메인 이름(FQDN)과 요구되는 자원의 경로를 가지는 Uniform Resource Locator (URL) 을 입력 합니다. 예를 들어, <ulink url="&ubuntu-web;">우분투 웹사이트</ulink>의 홈 페이지를 보려고 한다면, 사용자는 오직 FQDN 만을 입력할 것 입니다. <ulink url="&ubuntu-paidsupport;">비용지불 지원</ulink>에 특정 정보를 요청하려면, 사용자는 FQDN에 경로를 추가하여 입력 합니다.</para>
      <para>웹 페이지를 전송하기 위하여 사용되는 가장 일반적인 프로토콜은 Hyper Text Transfer Protocol (HTTP) 입니다. Secure Sockets Layer 상의 Hyper Text Transfer Protocol (HTTPS) 와 파일을 업로드 또는 다운로드 하기 위한 File Transfer Protocol (FTP) 같은 프로토콜들도 또한 지원 됩니다.</para>
      <para>아파치 웹 서버는 <application>MySQL</application> 데이타베이스 엔진, HyperText Preprocessor (<application>PHP</application>) 스크립트 언어, 그리고 <application>Python</application>과 <application>Perl</application>과 같은 다른 인기있는 스크립트 언어들과 함께 종종 사용되어 집니다. 이런 설정을 LAMP (Linux, Apache, MySQL 과 Perl/Python/PHP)라 명명하고, 이것은 웹 기반의 프로그램을 개발하고 이행하기 위한 강력하고 튼튼한 플랫폼을 구성 합니다.</para>
<sect2 id="http-installation" status="complete">
  <title>설치</title>
                  <para>아파치2 웹 서버는 우분투 리눅스에서 사용 가능합니다. 아파치2를 설치하려면:</para>
          <procedure><step>
                	  <para>터미널 프롬프트에서 다음의 명령을 입력 합니다: <screen>
<command>sudo apt-get install apache2</command>
</screen></para>
			</step>
	    </procedure>
      </sect2>
      <sect2 id="http-configuration" status="complete">
        <title>설정</title>
          <para>아파치는 일반 텍스트 설정 파일 내에 <emphasis>지시자</emphasis>를 넣는 것으로 설정이 됩니다. 주 설정 파일은 <filename>apache2.conf</filename> 입니다. 추가하여, 다른 설정 파일들은 <emphasis>Include</emphasis> 지시자를 사용하여 더해질 수 있고, 많은 설정 파일을 포함하기 위하여 와일드카드를 사용할 수 있습니다. 어떠한 지시자도 이러한 설정 파일들에 놓여질 수 있습니다. 주 설정 파일의 변경은 아파치2가 시작 또는 재시작될 때만 인식이 됩니다.</para>

          <para>서버는 또한 <emphasis>TypesConfig</emphasis> 지시자에 의해 정해지는 파일 이름과 그리고 기본으로 <filename>mime.types</filename>인 mime 문서 종류를 가지는 파일을 읽을 수 있습니다.</para>

          <para>기본 아파치2 설정 파일은 <filename>/etc/apache2/apache2.conf</filename> 입니다. 아파치2 서버를 설정하기 위하여 이 파일을 편집할 수 잇습니다. 포트 번호, 문서 루트, 모듈, 로그 파일, 가상 호스트, 기타 등등을 설정할 수 있습니다.</para>
        <sect3 id="http-basic-settings" status="complete">
          <title>기본적인 설정</title>
            <para>이 영역은 아파치2 서버의 필수적인 설정 파라미터를 설명 합니다. 더 자세한 것은 <ulink url="http://httpd.apache.org/docs/2.0/">아파치2 문서</ulink>를 참조 합니다.</para>

             <itemizedlist>

             <listitem><para>아파치2는 가상 호스트에 친근한 기본 설정과 함께 제공 됩니다. 그것은, 하나의 기본 설정 가상 호스트를 (<emphasis>VirtualHost</emphasis> 지시자를 사용하여) 가지고 설정되어 있고, 변경되거나 만약 하나의 사이트를 가지고 있다면 그대로 사용할 수도 있으며, 여러 개의 사이트를 가지고 있다면 추가적인 가상 호스트를 위한 예제 양식으로 사용될 수도 있습니다. 그대로 사용을 하면, 기본 설정된 가상 호스트는 여러분의 기본 사이트로 동작하거나, 또는 사이트 사용자가 여러분이 지정한 사이트의 <emphasis>ServerName</emphasis> 지시자와 그들이 입력한 URL이 일치되는 않는 경우를 볼 수 있습니다. 기본 설정 가상 호스트를 변경하려면, <filename>/etc/apache2/sites-available/default</filename> 파일을 편집 합니다. 만약 새로운 가상 호스트나 사이트를 설정하기를 원한다면, 같은 디렉토리 내로 여러분이 선택한 이름을 가지고 그 파일을 복사 합니다. 예를 들어, <command>sudo cp /etc/apache2/sites-available/default /etc/apache2/sites-available/mynewsite</command>  아래에 기술하는 몇 가지 지시자들을 사용하여 새로운 사이트를 설정하기 위하여 그 새로운 파일을 편집 합니다.</para></listitem>

             <listitem><para><emphasis>ServerAdmin</emphasis> 지시자는 서버의 시스템 관리자를 위한 이메일 주소를 광고하기 위하여 지정 합니다. 기본 설정값은 webmaster@localhost 입니다. 이것은, 만약 여러분이 그 서버의 시스템 관리자라면, 여러분에게로 배달될 수 있는 이메일 주소로 변경되어야 합니다. 만약 여러분의 웹 사이트가 문제를 가지고 있다면, 아파치2는 그 문제를 보고하기 위하여 이 이메일 주소를 가지는 에러 메세지를 보여줍니다. /etc/apache2/sites-available 내의 사이트 설정 파일에서 이 지시자를 찾으십시오.</para></listitem>

             <listitem><para><emphasis>Listen</emphasis> 지시자는 아파치2가 들어야하는, 포트, 그리고 선택 사항으로 IP 주소를 지정 합니다. 만약 IP 주소가 지정되지 않았다면, 아파치2는 서버가 실행되는 기계에 지정된 모든 IP 주소를 듣습니다. Listen 지시자를 위한 기본 설정값은 80 입니다. 오직 여러분의 루프백 인터페이스를 듣게하기 위하여 이것을 127.0.0.1:80으로 변경하고 그러면 서버는 인터넷으로는 사용할 수 없고, 듣고자 하는 포트를 변경하기 위하여 (예를 들어) 81로 지정할 수도 있고, 또는 보통의 동작을 위하여 있는 그대로 나두기도 합니다. 이 지시자를 위한 <filename>/etc/apache2/ports.conf</filename> 파일에서 지시자를  찾고 변경할 수 있습니다.</para></listitem>

			 <listitem><para><emphasis>ServerName</emphasis>은 선택사항입니다. 이 부분은 웹사이트에 접근할 수 있는 FQDN을 지정하는 역할을 합니다. 기본 가상 호스트에는 설정하둔 ServerName이 없기 때문에 다른 가상 호스트에서 사용하는 ServerName이 아닌 FQDN은 모두 기본 가상 호스트로 연결됩니다. ubunturocks.com이라는 도메인 이름을 구했을 때, 가상 호스트 설정 파일에 있는 ServerName의 값으로 ubunturocks.com을 입력하십시오. ServerName은 앞에서 만든 가상 호스트 파일(<filename>/etc/apache2/sites-available/mynewsite</filename>)에 넣으십시오. <tip><para>www를 앞에 붙이는 것을 당연하게 생각하는 사용자들도 많기 때문에 www.ubunturocks.com를 통해서도 웹사이트에 접근할 수 있게 설정하고 싶어할 수도 있습니다. 이 때 <emphasis>ServerAlias</emphasis>를 사용하면 됩니다. ServerAlias에 와일드카드를 사용할 수도 있습니다. 예를 들어, <command>ServerAlias *.ubunturocks.com</command>를 입력하면 .ubunturocks.com으로 끝나는 주소를 아무거나 사용하여 웹사이트에 접근할 수 있게 됩니다.</para></tip></para></listitem>

			 <listitem><para><emphasis>DocumentRoot</emphasis>는 웹사이트를 구성하는 파일들을 아파치가 찾을 때 사용하는 위치입니다. 기본값은 /var/www입니다. 아직은 /var/www에 아무런 웹사이트가 없지만, <filename>/etc/apache2/apache2.conf</filename>에 있는 <emphasis>RedirectMatch</emphasis>의 주석을 풀면 연결 요청이 /var/www/apache2-default로 연결되어 아파치2의 기본 웹사이트를 볼 수 있게 됩니다. 서버의 가상호스트 파일에 있는 이 값을 바꾸고, 필요한 경우에는 그 디렉토리를 변경하는 것은 잊지 마십시오.</para></listitem>
            </itemizedlist>

			<tip><para>아파치는 /etc/apache2/sites-available 디렉토리를 직접 파싱하지 <emphasis role="bold">않습니다</emphasis>. /etc/apache2/sites-enabled에 있는 심볼릭 링크는 "접근할 수 있는" 사이트를 가리킬 뿐입니다. a2ensite (Apache2 Enable Site) 프로그램을 사용하여 <command>sudo a2ensite mynewsite</command>를 입력하여 필요한 심볼릭 링크를 만들 수 있습니다. 이 때 mynewsite는 새로 연결할 사이트의 설정 파일 <filename> /etc/apache2/sites-available/mynewsite</filename>입니다. 비슷한 방법으로 a2dissite를 사용하여 사이트의 연결을 해제할 수도 있습니다.</para></tip>

        </sect3>
        <sect3 id="default-settings" status="complete">
          <title>기본 설정</title>
            <para>이 부분은 아파치2의 기본 설정을 설명합니다. 예를 들어, 가상호스트를 추가할 경우 그 가상호스트에서는 그 호스트를 위해 설정한 값이 우선순위를 가집니다. 가상호스트를 위해 설정한 값이 없을 때 기본값을 사용합니다.</para>

            <itemizedlist>
            <listitem>
            <para><emphasis>DirectoryIndex</emphasis>는 사용자가 디렉토리명 끝에 /(슬래시)를 지정하여 디렉토리의 목록을 보고자 할 때 서버에서 기본으로 제공하는 페이지를 지정합니다.</para>

             <para>예를 들어, 사용자가 http://www.example.com/this_directory/라는 페이지를 요청한다면, 사용자가 볼 수 있는 페이지에 몇 가지가 있습니다. 우선, DirectoryIndex 페이지가 있을 경우에는 그 페이지를 보게 됩니다. 이 페이지가 없고, Indexes 옵션이 설정되어있다면 서버에서 생성한 디렉토리 목록을 보게 됩니다. 마지막으로 DirectoryIndex 페이지도 없고 Indexes 옵션도 설정이 안 되어있으면 Permission Denied 페이지를 보게 됩니다. 즉, 사용자의 요청이 들어오면 서버는 우선 DirectoryIndex에 설정된 파일 중에서 가장 먼저 발견하는 파일을 사용자에게 제공합니다. DirectoryIndex에 있는 파일이 하나도 없고, Indexes 옵션이 설정되어 있다면 서버는 HTML 형식으로 그 디렉토리에 있는 하위 디렉토리와 파일의 목록을 생성해서 사용자에게 제공합니다. <filename>/etc/apache2/apache2.conf</filename>에 있는 DirectoryIndex의 기본값은 "index.html index.cgi index.pl index.php index.xhtml"입니다. 사용자가 요청한 디렉토리에 앞의 파일 중 하나가 있다면 아파치2는 이 중 가장 앞의 것을 사용자에게 제공합니다.</para>
            </listitem>

            <listitem>
            <para><emphasis>ErrorDocument</emphasis> 지시자는 특정한 에러 사건을 위하여 사용할 수 있도록 아파치를 위한 파일을 지정하는 것을 허용 합니다. 예를 들어, 사용자가 요청한 자원이 존재하지 않으면, 404 에러가 일어나고, 아파치2 기본 설정에 따라, <filename>/usr/share/apache2/error/HTTP_NOT_FOUND.html.var </filename> 파일이 보여지게 됩니다. 그 파일은 서버의 DocumentRoot에 없고, /error 디렉토리를 /usr/share/apache2/error/ 로의 요청으로 재지정하는 <filename>/etc/apache2/apache2.conf</filename> 내의 Alias 지시자가 있습니다. 기본 설정된 ErrorDocument 지시자들의 목록을 보려면, 이 명령을 사용 합니다: <command>grep ErrorDocument /etc/apache2/apache2.conf</command></para>
            </listitem>


            <listitem>
            <para>기본 설정에 의하여, 서버는 /var/log/apache2/access.log 파일로 전송 로그를 기록 합니다. <emphasis>CustomLog</emphasis> 지시자를 가지고 가상 호스트 설정 파일 내의 사이트당 이것을 변경하거나, 또는 <filename> /etc/apache2/apache2.conf</filename>에 지정된 기본 설정된 것을 제외시킬 수 있습니다. 또한 <emphasis>ErrorLog</emphasis> 지시자를 통하여 에러가 기록되는 파일로 지정할 수도 있습니다. 이 경우의 기본 설정은 <filename>/var/log/apache2/error.log</filename> 입니다. <emphasis>LogLevel</emphasis> (기본 설정은 "경고")과 <emphasis>LogFormat</emphasis> (기본 설정은 <filename> /etc/apache2/apache2.conf</filename>를 보십시오)도 역시 지정할 수 있습니다.</para>
            </listitem>

            <listitem>
            <para>몇 가지 선택 사항은 서버당 설정이기 보다는 디렉토리당 지정이 됩니다. Option은 이러한 지시자들 중의 하나 입니다. Directory 부분은 XML 비슷하게 태크로 묶여지고, 그래서 다음과 비슷합니다: <screen><command>&lt;Directory /var/www/mynewsite&gt;
				...
			&lt;/Directory&gt;</command></screen> Options 지시자는 Directory 부분 내에 하나 또는 그 이상의 다음의 값들을 가지고 (다른 것들과 함께), 공백으로 구분 됩니다:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para><emphasis role="bold">ExecCGI</emphasis> - CGI 스크립트의 실행을 허용 합니다. 만약 이 선택사항이 선택되지 않았다면 CGI 스크립트는 수행될 수 없습니다. <tip><para>대부분의 파일은 CGI 스크립트로서 실행이 되어서는 안됩니다. 이것은 매우 위험할 수 있습니다. CGI 스크립트는 여러분의 DocumentRoot 밖의 다른 디렉토리 내에 저장되어야만 하고, 오직 이 디렉토리만이 ExecCGI 옵션을 가져야 합니다. 이것은 기본 설정이고, CGI 스크립트를 위한 기본 위치는 /usr/lib/cgi-bin 입니다.</para></tip></para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Includes</emphasis> - 서버 측의 includes를 허용 합니다. 서버 측 includes는 <emphasis> include</emphasis> 파일들로 HTML 파일을 허용 합니다. 이것은 일반적인 선택 사항이 아닙니다. 더 많은 정보는 <ulink url="http://httpd.apache.org/docs/2.0/howto/ssi.html">아파치2 SSI 하우투</ulink>를 보십시오.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">IncludesNOEXEC</emphasis> - 서버측 includes를 허용하지만, CGI 스크립트 내의 #exec과 #include 명령을 사용하지 못하도록 합니다.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Indexes</emphasis> - 요청된 디렉토리내에 DirectoryIndex가 (index.html과 같은) 없다면, 디렉토리 내용물의 형식화된 목록을 보여 줍니다.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Multiview</emphasis> - 컨텐츠에 따라 복수개의 보기를 지원 합니다. 이 선택 사항은 보안상의 이유로 기본 설정으로는 사용하지 못하도록 되었습니다. <ulink url="http://httpd.apache.org/docs/2.0/mod/mod_negotiation.html#multiviews">이 선택 사항에 대한 아파치2 문서</ulink>를 보십시오.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">SymLinksIfOwnerMatch</emphasis> - 만약 타켓 파일 또는 디렉토리가 링크와 같은 소유자를 가졌다면 오직 심볼릭 링크를 따릅니다.</para>
                </listitem>
            </itemizedlist>

            </listitem>
            </itemizedlist>
        </sect3>
        <sect3 id="virtual-hosts-settings" status="complete">

          <title>가상 호스트 설정</title>
            <para>가상 호스트는 같은 기계를 다른 IP 주소, 다른 호스트 이름, 또는 다른 포트로 실행할 수 있도록 합니다. 예를 들어, 같은 웹 서버에서 가상 호스트를 사용하여 http://www.example.com 과 http://www.anotherexample.com 을 실행할 수 있습니다. 이 선택 사항은 기본 설정 가상 호스트와 IP 기반 가상 호스트를 위한 &lt;VirtualHost&gt; 지시자와 대응 합니다. 이름 기반의 가상 호스트는 &lt;NameVirtualHost&gt; 지시자와 대응 합니다.</para>

			<para>하나의 가상 호스트를 위한 지시자의 집합은 그 특정 가상 호스트에만 적용이 됩니다. 만약 서버 전체로 지시자가 지정이 되고 가상 호스트 설정 내에 정의가 안되었다면, 기본 설정 값이 사용 됩니다. 예를 들어, 웹마스터 이메일 주소를 지정할 수 있고 각각의 가상 호스트를 위한 개별적인 이메일 주소를 설정하지 않을 수도 있습니다.</para>
 
 			<para>가상 호스트를 위하여 루트 문서를 (index.html과 같은) 가지는 디렉토리는 DocumentRoot 지시자로 지정을 합니다. 기본 설정된 DocumentRoot는 <filename>/var/www</filename> 입니다.</para>

			<para>
			The ServerAdmin directive within the VirtualHost stanza is the email address used in the 
			footer of error pages if you choose to show a footer with an email address on the error pages.
			</para>

        </sect3>
        <sect3 id="server-settings" status="complete">
          <title>서버 설정</title>
            <para>이 영역은 어떻게 기본적인 서버 설정을 하는지를 설명 합니다.</para>
                    <para><emphasis role="bold">LockFile</emphasis> - LockFile 지시자는 서버가 USE_FCNTL_SERIALIZED_ACCEPT 또는 USE_FLOCK_SERIALIZED_ACCEPT 중의 하나로 컴파일 되었을 때 사용되는 lockfile의 경로를 지정 합니다. 그것은 반드시 로컬 디스크에 저장되어야 합니다. NFS 공유 상에 로그 디렉토리가 위치하지 않는 한 기본 설정된 값으로 나두십시오. 이 경우라면, 오직 root에 의해서만 읽을 수 있는 디렉토리로 로컬 디스크 상의 위치를 기본 설정 값으로 변경 합니다.</para>

					<para><emphasis role="bold">PidFile</emphasis> - PidFile 지시자는 서버가 프로세스 ID (pid)를 기록하는 파일을 지정 합니다. 이 파일은 반드시 root에 의해서만 읽혀질 수 있어야 합니다. 많은 경우에, 이 지시자는 기본 설정값으로 남겨져야 합니다.</para>

<para><emphasis role="bold">User</emphasis> - User 지시자는 요청을 대답하기 위하여 서버에 의해 사용되는 사용자 아이디를 지정 합니다. 이 설정은 서버의 접근을 결정 합니다. 이 사용자가 접근할 수 없는 파일은 또한 여러분의 웹 사이트 방문자도 접근할 수 없습니다. User를 위하여 기본 설정된 값은 www-data 입니다.</para>
            <warning>
            <para>여러분이 하는 것을 정확히 알지 않는 한, User 지시자를 root로 지정하지 마십시오. User로 root를 사용하는 여러분의 웹 서버에 거대한 보안 구멍을 만들게 됩니다.</para>
            </warning>
 <para>Group 지시자는 User 지시자와 비슷합니다. Group은 서버가 요청을 대답하는 그룹을 지정 합니다. 기본 설정된 그룹은 또한 www-data 입니다.</para>

        </sect3>
        <sect3 id="apache-modules" status="complete">
          <title>아파치 모듈</title>
              <para>아파치는 모듈 방식의 서버 입니다. 이것은 핵심 서버에는 가장 기본적인 기능만을 포함하는 것을 의미 합니다. 확장되는 기능은 아파치로 올려질 수 있는 모듈을 통하여 사용 가능 합니다. 기본 설정으로, 모듈의 기본적인 집합은 컴파일 시에 서버에 포함 됩니다. 만약 서버가 동적으로 올려지는 모듈을 사용하도록 컴파일 되었다면, 모듈은 분리하여 컴파일 될 수 있고, LoadModule 지시자를 사용하여 어느 때나 추가될 수 있습니다. 그렇지 않다면, 아파치는 모듈을 추가하거나 삭제하도록 반드시 재 컴파일 되어야 합니다. 우분투는 아파치2가 동적 모듈의 올림을 허용하도록 컴파일 하였습니다. 설정 지시자들은 &lt;IfModule&gt; 블럭 내에 특정 모듈의 존재를 넣는 것으로 조건적으로 포함될 수 있습니다. 여러분은 추가적인 아파치2 모듈을 설치할 수 있고 웹 서버와 함께 사용을 할 수 있습니다. 아파치2 모듈은 <application>apt-get</application> 명령을 사용하여 추가할 수 있습니다. 예를 들어, MYSQL 인증을 위한 아파치2 모듈을 설치하려면, 다음의 명령을 터미널 프롬프트에서 실행을 합니다:</para>
                
                <para>
<screen>
<command>sudo apt-get install libapache2-mod-auth-mysql</command>
</screen>
                </para>
                <para>모둘을 설치한 후, 그 모듈은 <filename>/etc/apache2/mods-available</filename> 디렉토리 내에 있게 됩니다. 모둘을 사용 가능하게 하는 것은 <application>a2enmod</application> 명령을 사용할 수 있습니다. 모듈을 사용 가능하게 하면, 그 모듈은 <filename>/etc/apache2/mods-enabled</filename> 디렉토리 내에 있게 됩니다.</para>
        </sect3>
      </sect2>
      <sect2 id="https-configuration" status="complete">
        <title>HTTPS 설정</title>
          <para><application>mod_ssl</application> 모듈은 아파치2 서버에 중요한 - 통신을 암호화 하는 기능을 더합니다. 그러므로, SSL 암호화를 사용하여 여러분의 브라우저가 통신을 할 때, https:// 접두 주소가 브라우저 주소 막대 내의 Uniform Resource Locator (URL)의 시작에 사용 됩니다.</para>

          <para><application>mod_ssl</application> 모듈은 <application>apache2-common</application> 패키지 내에 있습니다. 이 패키지가 설치되어 있다면, 터미널 프롬프트에서 다음의 명령을 실행하여 <application>mod_ssl</application> 모듈을 활성화 할 수 있습니다:</para>

          <para>
<screen>
<command>sudo a2enmod ssl</command>
</screen>
          </para>
        <sect3 id="certificates-and-security" status="complete">
          <title>인증서와 보안</title>
            <para>여러분의 안전한 서버를 만들기 위하여, 공개와 사적 키 쌍을 만들기 위한 공개 키 암호화를 사용 합니다. 대부분의 경우에, 여러분의 공개 키를 포함하는 인증 요청, 여러분 회사의 이름 등의 증명, 그리고 인증 기관(CA)에 지불하는 비용을 보냅니다. CA는 인증 요청과 여러분의 식별을 확인한 후 보안 서버를 위하여 인증서를 보내게 됩니다.</para>
             <para>다른 방법으로, 여러분 스스로 자가-사인한 인증서를 만들 수 있습니다. 그러나, 자가-사인 인증서는 대부분의 현업 환경에서는 사용하지 말아야 함을 주의 하십시오. 자가-사인 인증서는 사용자의 웹브라우저에 의해 자동적으로 받아들여지지 않습니다. 사용자는 웹브라우저에 의하여 인증서를 받아들이고 보안 연결을 만들기 위한 질문을 받게 됩니다.</para>

             <para>자가-사인 인증서 또는 여러분이 선택한 CA에서 사인한 인증서를 가진 후에, 그것을 보안 서버에 설치하는 것이 필요 합니다.</para>
        </sect3>
        <sect3 id="types-of-certificates" status="complete">
          <title>인증서의 종류</title>
            <para>보안 서버를 동작하게 하려면 키와 인증서가 필요 합니다. 이것은 자가-사인한 인증서를 만들거나 또는 CA-사인 인증서를 구매하여야 하는 것을 의미 합니다. CA-사인 인증서는 여러분의 서버에 두 가지 중요한 능력을 제공 합니다:</para>

            <itemizedlist>
            <listitem>
            <para>웹브라우저들은 (대개) 사용자에게 묻는 것 없이 자동적으로 인증서와 만들어진 보안 연결을 인식 합니다.</para>
            </listitem>
            <listitem>
            <para>CA가 사인된 인증을 발행하였을 때, 그것은 웹 페이지를 브라우저에 제공하는 단체의 식별을 보장 합니다.</para>
            </listitem>
            </itemizedlist>

            <para>SSL을 지원하는 대부분의 웹 브라우저는 그들이 자동적으로 받아들이는 인증한 CA의 목록을 가집니다. 만약 브라우저가 목록 내에 인증된 CA를 가지지 않은 인증서를 만나게 되면, 브라우저는 사용자에게 접속을 허용할 것인지 또는 거절할 것인지를 물어보게 됩니다.</para>
            <para>여러분은 보안 서버를 위하여 자가-사인된 인증서를 만들 수 있지만, 자가-사인된 인증서는 CA-사인된 인증서와 같은 기능을 제공하지 않음을 알고있어야 합니다. 자가-사인된 인증서는 대부분의 웹 브라우저에 의해 자동적으로 인식되지 않고, 자가-사인된 인증서는 웹 사이트를 제공하는 단체의 식별에 대한 염려를 위한 어떤 보증도 제공하지 않습니다. CA-사인된 인증서는 보안 서버를 위한 이 두 가지의 중요한 능력을 제공 합니다. CA에서 인증서를 받는 절차는 아주 쉽습니다. 빠른 개괄적인 것은 다음과 같습니다:</para>

            <orderedlist>
            <listitem>
               <para>사적 그리고 공개 암호 키 쌍을 만듭니다.</para>
            </listitem>
            <listitem>
                 <para>공개 키에 근거하여 인증서 요청을 만듭니다. 인증서 요청은 여러분의 서버와 그것을 호스팅하는 회사에 대한 정보를 가집니다.</para>
            </listitem>
            <listitem>
                 <para>인증서 요청을, 여러분의 인적 사항을 제공하는 문서와 함께 CA로 보냅니다. 우리는 여러분에게 어떤 인증 기관을 선택할 지를 이야기할 수 없습니다. 여러분의 결정은 아마 여러분의 과거 경험, 친구나 동료의 경험, 또는 순전히 금전상의 요인에 근거할 겁니다.</para>

                    <para>CA를 결정하였다면, 그들에게서 어떻게 인증서를 얻을 수 있는지를 그들이 제공한 지시에 따르는 것이 필요 합니다.</para>
            </listitem>
            <listitem>
               <para>CA가 여러분이 정말로 요청을 한 사람임을 만족하게 되면, 그들은 디지털 인증서를 여러분에게 보냅니다.</para>
            </listitem>
            <listitem>
               <para>이 인증서를 여러분의 보안 서버에 설치하고, 보안 트랜잭션을 관리하기 시작 합니다.</para>
            </listitem>
            </orderedlist>

            <para>CA에서 인증서를 받던지 또는 여러분 스스로 자가-사인 인증서를 만들던지, 첫 번째 단계는 키를 만드는 것 입니다.</para>
        </sect3>
        <sect3 id="generating-a-csr" status="complete">
          <title>Certificate Signing Request (CSR) 만들기</title>
            <para>인증서 서명 요청 (CSR)을 만드려면, 여러분 소유의 키를 만들어야만 합니다. 키를 만들기 위하여 터미널 프롬프트에서 다음의 명령을 수행할 수 있습니다:</para>

            <para>
<screen>
<command>openssl genrsa -des3 -out server.key 1024</command>
</screen>
            </para>
<programlisting>
Generating RSA private key, 1024 bit long modulus
.....................++++++
.................++++++
unable to write 'random state'
e is 65537 (0x10001)
Enter pass phrase for server.key:
</programlisting>

        <para>이제 여러분의 암호 문구를 입력 합니다. 최선의 보안을 위하여, 그것은 최소한 8자리 문자여야 합니다. -deb3을 지정하는 경우 최소한의 길이는 4자리 문자 입니다. 그것은 숫자 그리고/또는 구두점을 포함하고 사전내의 단어여서는 안됩니다. 암호 문구는 대소문자 구별을 하는 것을 기억 하십시오.</para>

        <para>확인을 위하여 암호 문구를 재 입력 합니다. 그것을 정확히 재 입력한 후, 서버 키는 만들어지고 <filename>server.key</filename> 파일로 저장이 됩니다.</para>

        <warning>
        <para>또한 여러분의 보안 웹 서버를 암호 구문 없이 실행시킬 수 있습니다. 이것은 보안 웹 서버를 시작하는 매 번마다 암호 구문을 입력할 필요가 없으므로 편리합니다. 하지만, 그것은 굉장히 안전하지 못한 방법이고 보안 키의 절충은 서버의 절충과 마찬가지의 의미 입니다.</para>
        </warning>

        <para>어떤 경우에는, 구문 생성에서 -des3 스위치는 떼는 것 또는 터미널 프롬프트에서 다음의 명령을 수행하는 것으로 암호 구문 없이 보안 웹 서버를 실행하는 것을 선택할 수 있습니다:</para>

        <para>
<screen>
<command>openssl rsa -in server.key -out server.key.insecure</command>
</screen>
        </para>
        <para>위의 명령을 실행하면, 그 insecure 키는 <filename>server.key.insecure</filename> 파일에 저장 됩니다. 여러분은 이 파일을 암호 구문 없이 CSR을 생성할 때 사용할 수 있습니다.</para>

        <para>CSR을 만드려면, 터미널 프롬프트에서 다음의 명령을 실행 합니다:</para>

        <para>
<screen>
<command>openssl req -new -key server.key -out server.csr</command>
</screen>
        </para>

        <para>암호 구문을 입력하도록 물어 봅니다. 만약 여러분이 정확한 암호 구문을 입력하면, 회사 이름, 사이트 이름, 이메일 ID 등을 입력하도록 물어 봅니다. 이러한 모든 사항을 입력한 후에, 여러분의 CSR은 만들어지고 그것은 <filename>server.csr</filename> 파일에 저장 됩니다. 이 CSR 파일을 이 후의 절차를 위하여 CA로 보낼 수 있습니다. CAN은 이 CSR 파일을 사용하고 인증서를 발행 합니다. 다른 한편으로는, 여러분은 이 CSR을 사용하여 자가-사인 인증서를 만들 수도 있습니다.</para>

        </sect3>
        <sect3 id="creating-a-self-signed-certificate" status="complete">
          <title>자가-사인 인증서 만들기</title>
            <para>자가-사인 인증서를 만들기 위하여, 터미널 프롬프트에서 다음의 명령을 실행 합니다:</para>

            <para>
<screen>
<command>openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt</command>
</screen>
            </para>

            <para>위의 명령은 여러분이 암호 구문을 입력하도록 물어 봅니다. 정확한 암호 구문이 입력된 후, 여러분의 인증서가 만들어지고 그것은 <filename>server.crt</filename> 파일에 저장 됩니다.</para>
        <warning>
        <para>만약 여러분의 보안 서버가 현업 환경에서 사용이 된다면, 아마도 CA가 사인한 인증서가 필요할 겁니다. 자가-사인한 인증서를 사용하는 것은 권장되지 않습니다.</para>
        </warning>
        </sect3>
        <sect3 id="installing-the-certificate" status="complete">
          <title>인증서 설치</title>

            <para>키 파일 <filename>server.key</filename>와 인증서 파일 <filename>server.crt</filename> 또는 여러분의 CA에서 발행한 인증서 파일을 터미널 프롬프트에서 다음의 명령들을 수행하여 설치할 수 있습니다:</para>
            <para>
<screen>
<command>sudo cp server.crt /etc/ssl/certs</command>
<command>sudo cp server.key /etc/ssl/private</command>
</screen>
            </para>
            <para><filename>/etc/apache2/sites-available/default</filename> 파일 또는 여러분의 보안 가상 호스트를 위한 설정 파일에 다음의 네 줄을 추가하여야 합니다. <emphasis>VirtualHost</emphasis> 부분에 그것을 넣습니다. 그것은 <emphasis>DocumentRoot</emphasis> 줄 밑에 놓여집니다:</para>
<programlisting>
SSLEngine on
SSLOptions +FakeBasicAuth +ExportCertData +CompatEnvVars +StrictRequire

SSLCertificateFile /etc/ssl/certs/server.crt
SSLCertificateKeyFile /etc/ssl/private/server.key
</programlisting>
          
            <para>HTTPS는 포트 번호 443을 듣습니다. <filename>/etc/apache2/ports.conf</filename> 파일에 다음의 줄을 추가하여야 합니다:</para>
<programlisting>
Listen 443
</programlisting>

        </sect3>
        <sect3 id="accessing-the-server" status="complete">
          <title>서버에 접근하기</title>
            <para>여러분의 인증서를 설치한 후에, 웹 서버를 재 시작하여야 합니다. 터미널 프롬프트에서 다음의 명령을 실행하여 웹 서버를 재 시작할 수 있습니다:</para>
            <para>
<screen><command>sudo /etc/init.d/apache2 restart</command> </screen>
            </para>
        <note><para>여러분은 반드시 그 암호 구문을 기억해야 하고 보안 웹 서버가 시작되는 매 번마다 암호 구문을 입력 합니다.</para></note>

            <para>암호 구문을 입력하도록 물어 봅니다. 정확한 암호 구문을 입력한 후에, 보안 웹 서버는 시작 됩니다. 여러분의 웹 브라우저 주소   란에서 https://your_hostname/url/ 형식으로 입력하여 보안 서버 페이지를 접근 합니다.</para>

        </sect3>
      </sect2>
      <sect2 id="http-references" status="complete">
        <title>참조</title>
          <para>
          <ulink url="http://httpd.apache.org/docs/2.0/">아파치2 문서</ulink>
          </para>
          <para>
          <ulink url="http://www.modssl.org/docs/">Mod SSL 문서</ulink>
          </para>
      </sect2>
    </sect1>

	<sect1 id="php5" status="complete">
		<title>PHP5 - Scripting Language</title>
      <para>PHP is a general-purpose scripting language suited for Web
      development. The PHP script can be embedded into HTML. This
      section explains how to install and configure PHP5 in Ubuntu
      System with Apache2 and MySQL.</para>
      <para> This section assumes you have installed and configured
      Apache 2 Web Server and MySQL Database Server. You can refer to
      Apache 2 section and MySQL sections in this document to install and
      configure Apache 2 and MySQL respectively.</para>

<sect2 id="php5-installation" status="complete">
  <title>설치</title>
      <para>The PHP5 is available in Ubuntu Linux. </para>
      
      <procedure><step><para>
      To install PHP5 you
      can enter the following command in the terminal prompt:

<screen>
<command>sudo apt-get install php5-common php5 libapache2-mod-php5</command>
</screen>
</para>

      <para>You can run PHP5 scripts from command line. to run PHP5 scripts 
      from command line you should install
      <application>php5-cgi</application> package. To install
      <application>php5-cgi</application> you can enter the following
      command in the terminal prompt:
<screen>
<command>sudo apt-get install php5-cgi</command>
</screen>
</para>
      <para>To use <application>MySQL</application> with PHP5 you should install
      <application>php5-mysql</application> package. To install
      <application>php5-mysql</application> you can enter the following
      command in the terminal prompt:
<screen>
<command>sudo apt-get install php5-mysql</command>
</screen>
</para>
      <para>Similarly, to use <application>PostgreSQL</application> with PHP5 you should install
      <application>php5-pgsql</application> package. To install
      <application>php5-pgsql</application> you can enter the following
      command in the terminal prompt:
<screen>
<command>sudo apt-get install php5-pgsql</command>
</screen>
      </para>
			</step>
	    </procedure>
      </sect2>
      <sect2 id="php5-configuration" status="complete">
        <title>설정</title>
          <para>
          Once you install PHP5, you can run PHP5 scripts from your web
          browser. If you have installed
          <application>php5-cgi</application> package, you can run PHP5
          scripts from your command prompt.
          </para>

          <para>
          By default, the Apache 2 Web server is configured to run PHP5
          scripts. In other words, the PHP5 module is enabled in Apache2
          Web server automatically when you install the module. Please
          verify if the files
          <filename>/etc/apache2/mods-enabled/php5.conf</filename> and
          <filename>/etc/apache2/mods-enabled/php5.load</filename>
          exist. If they do not exists, you can enable the module using
          <command>a2enmod</command> command.
          </para>

          <para>Once you install PHP5 related packages and enabled PHP5
          Apache 2 module, you should restart Apache2 Web server to run
          PHP5 scripts. You can run the following command at a terminal
          prompt to restart your web server:
<screen><command>sudo /etc/init.d/apache2 restart</command> </screen>
          </para>
      </sect2>
      <sect2 id="php5-testing" status="complete">
        <title>테스팅</title>
          <para>To verify your installation, you can run following PHP5
          phpinfo script:
          </para>
<programlisting>
&lt;?php
print_r (phpinfo());
?&gt;
</programlisting>
          <para>
          You can save the content in a file
          <filename>phpinfo.php</filename> and place it
          under <command>DocumentRoot</command> directory of Apache2 Web
          server. When point your browser to
          <filename>http://hostname/phpinfo.php</filename>, it would
          display values of various PHP5 configuration parameters.
      </para>
      </sect2>
    </sect1>
	
	<sect1 id="squid" status="complete">
		<title>Squid - 프락시 서버</title>
          <para>Squid는 완전한 기능을 갖춘 웹 프락시 캐쉬 서버 프로그램이고 Hyper Text Transport Protocol (HTTP), File Transfer Protocol (FTP), 그리고 다른 인기있는 네트워크 프로토콜들을 위한 프락시와 캐쉬 서비스를 제공 합니다. Squid는 Secure Sockets Layer (SSL) 요청의 캐슁과 프락싱 그리고 Domain Name Server (DNS) 조회의 캐슁을 이행할 수 있고, 투명한 캐슁을 수행 합니다. 또한, Squid는 Internet Cache Protocol (ICP), Hyper Text Caching Protocol (HTCP), Cache Array Routing Protocol (CARP), 그리고 Web Cache Coordination Protocol (WCCP) 프로토콜과 같은 다양한 종류의 캐슁 프로토콜을 지원 합니다.</para>
          <para>Squid 프락시 캐쉬 서버는 다양한 프락시와 캐슁 서버의 요구에 맞는 훌륭한 솔루션이고, 광범위하고 조직적인 접근 조종 기능과 Simple Network Management Protocol (SNMP)를 통하여 아주 중요한 것들의 감시 기능을 제공하므로 지점 사무실에서 부터 기업 수준의 네트워크 까지로 확장할 수 있습니다. 전용의 Squid 프락시, 또는 캐슁 서버로 하나의 컴퓨터를 선택하였을 때, Squid는 성능을 향상시키기 위하여 메모리 내의 캐쉬를 관리하므로 많은 양의 실제 메모리를 가지도록 시스템을 설정 합니다.</para>
      <sect2 id="squid-installation" status="complete">
        <title>설치</title>
          <para>터미널 프롬프트에서, Squid 서버를 설치하기 위하여 다음의 명령을 입력 합니다:</para>
          <para>
<screen>
<command>sudo apt-get install squid squid-common</command>
</screen>
          </para>
      </sect2>
      <sect2 id="squid-configuration" status="complete">
        <title>설정</title>
          <para>Squid는 <filename>/etc/squid/squid.conf</filename> 설정 파일 내의 지시자를 편집하는 것으로 설정 딥니다. 다음의 예는 Squid 서버의 동작에 영향을 주기 위하여 변경될 수 있는 몇 가지의 지시자들을 보여 줍니다. 더 깊은 Squid의 설정에 대한 것은, 참조 영역을 보십시오.</para>
             <tip>
               <para>설정 파일을 편집하기 전에, 원래의 파일의 복사본을 만들고 그것을 쓰기에서 보호해야만 합니다. 그래서 참조로서 원래의 설정값을 가질 수 있고, 필요한 경우 재 사용할 수 있습니다.</para>
               <para>터미널 프롬프트에서 다음의 명령을 입력하여 <filename>/etc/squid/squid.conf</filename> 파일을 복사하고 그것을 쓰기에서 보호 합니다:</para>
	     </tip>
               <para>
<screen>
<command>sudo cp /etc/squid/squid.conf /etc/squid/squid.conf.original</command>
<command>sudo chmod a-w /etc/squid/squid.conf.original</command>
</screen>
               </para> 
	        <para>
           <itemizedlist>
               <listitem>
                  <para>Squid 서버가 기본 설정된 TCP 포트 3128 대신에 TCP 포트 8888을 듣게 지정하려면, 다음과 같이 http_port 지시자를 변경 합니다:</para>
                  <para>http_port 8888</para>
               </listitem>
	            <listitem>
                  <para>Squid 서버에 특정 호스트 이름을 주기 위하여 visible_hostname 지시자를 변경 합니다. 이 호스트 이름은 꼭 그 컴퓨터의 호스트 이름일 필요는 없습니다. 이 예에서는 그것은 <emphasis>weezie</emphasis>로 지정 되었습니다.</para>
                  <para>visible_hostname weezie</para>
               </listitem>
               <listitem>
                  <para>다시 한번, Squid 접근 조종을 사용하여, 특정 Internet Protocol (IP) 주소들을 가지는 사용자들만이 Squid에 의해 프락시된 인터넷 서비스가 사용 가능하도록 설정할 수 있습니다. 예를 들어, 192.168.42.0/24 서브 네트워크의 사용자들에 의해서만 접근할 수 있는 것을 보입니다:</para>
                  <para>다음을 여러분의 <filename>/etc/squid/squid.conf</filename> 파일의 ACL 영역의 <emphasis role="bold">가장 아래</emphasis>에 추가 합니다:</para>
                  <para>acl fortytwo_network src 192.168.42.0/24</para>
                  <para>그런 다음, <filename>/etc/squid/squid.conf</filename> 파일의 http_access 영역의 <emphasis role="bold">가장 위</emphasis>에 다음을 추가 합니다:</para>
                  <para>http_access allow fortytwo_network</para>
               </listitem>
               <listitem>
                  <para>Squid의 훌륭한 접근 조종 기능을 사용하여, 여러분의 오직 정규 업무 시간 동안에만 Squid에 의하여 프락시된 인터넷 서비스가 사용 가능하도록 설정할 수 있습니다. 예를 들어, 월요일부터 금요일까지, 오전 9시에서 오후 5시 동안 근무하는 사업장의 직원들이 10.1.42.0/42 서브 네트워크를 사용하는 경우의 접근법을 보입니다.</para>
                  <para>다음을 여러분의 <filename>/etc/squid/squid.conf</filename> 파일의 ACL 영역의 <emphasis role="bold">가장 아래</emphasis>에 추가 합니다:</para>
                  <para>acl biz_network src 10.1.42.0/24 acl biz_hours time M T W T F 9:00-17:00</para>
                  <para>그런 다음, <filename>/etc/squid/squid.conf</filename> 파일의 http_access 영역의 <emphasis role="bold">가장 위</emphasis>에 다음을 추가 합니다:</para>
                  <para>http_access allow biz_network biz_hours</para>
               </listitem>
          </itemizedlist>
          </para>
          <note>
	  <para><filename>/etc/squid/squid.conf</filename> 파일에 변경을 만든 후에는, 그 파일을 저장하고 변경의 효과를 가지도록 터미널 프롬프트에서 다음의 명령을 입력하여 <application>squid</application> 서버 프로그램을 재 시작 합니다:</para>
          </note>
          <para>
<screen>
<command>sudo /etc/init.d/squid restart</command>
</screen>
          </para>
      </sect2>
      <sect2 id="squid-references" status="complete">
      <title>참조</title>
      <para>
      <ulink url="http://www.squid-cache.org/">Squid 웹사이트</ulink>
      </para>
      </sect2>
    </sect1>
	<sect1 id="version-control-system" status="complete">
		<title>버전 관리 시스템</title>
          <para>버전 관리는 정보의 변경을 관리하는 예술적인 작업 입니다. 그것은, 소프트웨어에 적은 변경을 만들고 다음 날에 그 변경을 취소하는 데 그들의 시간을 사용하는 전형적인 프로그래머들을 위하여 오랫 동안 아주 중요한 도구이어 왔습니다. 그러나, 버전 관리의 유용함은 소프트웨어 개발 세상의 범주를 훨씬 넘어 확장되고 있습니다. 어느 곳에서든 여러분은 사람들이 종종 정보를 변경하는 것을 컴퓨터를 사용하여 관리하는 것을 볼 수 있을 겁니다. 거기에 버전 관리를 위한 필요가 있습니다.</para>
<para>
          </para>
      <sect2 id="subversion" status="complete">
        <title>Subversion</title>
          <para>Subversion 은 오픈소스 버전 관리 시스템 입니다. Subversion을 사용하여, 소스 파일과 문서의 이력을 기록할 수 있습니다. 그것은 시간에 걸쳐 파일과 디렉토리를 관리 합니다. 파일의 트리는 중앙 저장소로 놓여집니다. 저장소는 보통의 파일 서버와 매우 비슷하지만, 이제껏 만들어진 파일과 디렉토리의 모든 변경을 기억하고 있습니다.</para>
        <sect3 id="subversion-installation" status="complete">
          <title>설치</title>
            <para>HTTP 프로토콜을 사용하여 Subversion 저장소를 접근하기 위해, 여러분은 반드시 웹 서버를 설치하고 설정하여야 합니다. 아파치2는 Subversion과 잘 동작하는 것이 증명 되었습니다. 아파치2를 설치하고 설정하기 위하여 아파치2 영역 내의 HTTP 부 영역을 참조 하십시오. HTTPS 프로토콜을 사용하여 Subversion 저장소에 접근하려면, 반드시 여러분의 아파치2 웹 서버 내에 디지털 인증서를 설치하고 설정하여야 합니다. 디지털 인증서를 설치하고 설정하기 위하여 아파치2 영역 내의 HTTPS 부 영역을 참조 하십시오.</para>
						<para>Subversion은 설치하려면, 터미널 프롬프트에서 다음의 명령을 실행 합니다:</para>
	    <para>
<screen>
<command>sudo apt-get install subversion libapache2-svn</command>
</screen>
	    </para>

        </sect3>
        <sect3 id="subversion-configuration" status="complete">
          <title>서버 설정</title>
            <para>이 절차는 위에서 언급된 패키지가 여러분의 시스템에 설치된 것으로 간주 합니다. 이 영역은 Subversion 저장소를 어떻게 만들고 프로젝트를 접근할 수 있는지를 설명 합니다.</para>
			<sect4 id="create-svn-repos" status="complete">
				<title>Subversion 저장소 만들기</title>
<para>Subversion 저장소는 터미널 프롬프트에서 다음의 명령을 사용하여 만들 수 있습니다:</para>

        <para>
<screen>
<command>svnadmin create /path/to/repos/project</command>
</screen>
        </para>
			</sect4>

        </sect3>
        <sect3 id="access-methods" status="complete">
          <title>접근 방법</title>
<para>Subversion 저장소는 로컬 디스크 상의 많은 다른 방법들 또는 다양한 네트워크 프로토콜을 통하여 접근(체크아웃)될 수 있습니다. 그러나, 하나의 저장소 위치는 언제나 URL 입니다. 다음 표는 어떻게 다른 URL 체계를 사용가능한 접근 방법으로 대치할 수 있는지를 기술 합니다.</para>
				<table><title>접근 방법</title>

					<tgroup cols="2">
						<colspec colname="1"/>
						<colspec colname="2"/>
						<thead>
							<row>
								<entry><para>Schema</para></entry>
								<entry><para>Access Method</para></entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><para>file://</para></entry>
								<entry><para>직접 저장소 접근 (로컬 디스크 상)</para></entry>
							</row>
							<row>
								<entry><para>http://</para></entry>
								<entry><para>Subversion을 인식하는 아파치2 웹 서버로 WebDAV를 통하여 접근</para></entry>
							</row>
							<row>
								<entry><para>https://</para></entry>
								<entry><para>http://와 같으나, SSL 암호화를 사용</para></entry>
							</row>
							<row>
								<entry><para>svn://</para></entry>
								<entry><para>svn를 사용하는 서버로 Subversion 프토토콜을 통하여 접근</para></entry>
							</row>
							<row>
								<entry><para>svn+ssh://</para></entry>
								<entry><para>svn://와 같으나, SSH 터널을 사용</para></entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<para>이 영역에서는, 모든 접근 방법을 위하여 Subversion을 어떻게 설정하는 지를 보일 겁니다. 여기서는, 그 기초를 다룹니다. 좀 더 고급의 사용예에 대한 자세한 것은, <ulink url="http://svnbook.red-bean.com/">svn 책</ulink>을 참고 하십시오.</para>
			<sect4 id="direct-repos-access" status="complete">
				<title>직접 저장소 접근 (file://)</title>
<para>이것은 모든 접근 방법 중의 가장 단순한 것 입니다. 이것은 Subversion 서버의 프로세스가 실행 중인 것을 필요로 하지 않습니다. 이 접근 방법은 같은 기계에서 Subversion을 접근할 때 사용 됩니다. 명령의 문법은, 터미널 프롬프트에서, 다음과 같이 입력 합니다:</para>

        <para>
<screen>
<command>svn co file:///path/to/repos/project</command>
</screen>
        </para>
  <para>또는</para>
	<para>
<screen>
<command>svn co file://localhost/path/to/repos/project</command>
</screen>
        </para>
	<note>
		<para>만약 호스트 이름을 지정하지 않았다면, 세 개의 슬래쉬 (///)가 있습니다. 두 개는 프로토콜을 위한 것이고 (이 경우는 file), 마지막 하나는 경로를 나타내는 슬래쉬 입니다. 만약 호스트 이름을 지정한다면, 반드시 두 개의 슬래쉬(//)를 사용 합니다.</para>
	</note>
		<para>저장소의 접근 권한은 파일 시스템의 접근 권한에 의존 합니다. 만약 사용자가 읽기/쓰기 접근 권한을 가지고 있다면, 그 저장소에서 체크아웃을 하고 저장소로 커밋을 할 수 있습니다.</para>
			</sect4>
			<sect4 id="access-via-webdav" status="complete">
				<title>WebDAV 프로토콜을 사용하여 접근 (http://)</title>
<para>WebDAV 프로토콜을 사용하여 Subversion 저장소를 접근하기 위하여, 여러분은 반드시 아파치2 웹 서버를 설정하여야 합니다. 반드시 다음의 예를 여러분의 <filename>/etc/apache2/apache2.conf</filename> 파일에 추가 합니다:</para>

	<programlisting> &lt;Location /svn&gt;
  DAV svn
  SVNPath /path/to/repos
  AuthType Basic
  AuthName "Your repository name"
  AuthUserFile /etc/subversion/passwd
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
  Require valid-user
  &lt;/LimitExcept&gt;
  &lt;/Location&gt; </programlisting>
  <para>다음에, <filename>/etc/subversion/passwd</filename> 파일을 반드시 만듭니다. 이 파일은 사용자 인증의 상세한 것을 가집니다. 예를 들어 사용자를 추가하는 것과 같이 항목을 추가하려면, 터미널 프롬프트에서 다음의 명령을 사용할 수 있습니다:</para>
	<para>
<screen>
<command>htpasswd2 /etc/subversion/passwd user_name</command>
</screen>
        </para>
	<para>이 명령은 여러분이 암호를 입력하도록 물어 봅니다. 암호를 입력한 후, 그 사용자는 더해 집니다. 이제, 다음의 명령을 실행하여 저장소를 접근할 수 있습니다:</para>
        <screen><command>svn co http://servername/svn</command></screen>
	<warning>
		<para>암호는 일반 텍스트로 전송 됩니다. 만약 암호를 훔쳐보는 것을 걱정한다면, SSL 암호화를 사용할 것을 권고 합니다. 자세한 것은, 다음 부분을 참고 하십시오.</para>
	</warning>
			</sect4>
			<sect4 id="access-via-webdav-with-ssl" status="complete">
				<title>SSL 암호화와 함께 WebDAV 프로토콜을 사용하여 접근 (https://)</title>
					<para>SSL 암호화와 함께 WebDAV 프로토콜(https://)을 사용하여 Subversion 저장소를 접근하는 것은 http://를 사용하는 것과 비슷하나 차이점은, 여러분은 반드시 아파치2 웹 서버에 디지털 인증서를 설치하고 설정하여야 합니다.</para>

					<para>디지털 인증서는 Verisign과 같은 인증 기관에서 발행된 것을 설치할 수 있습니다. 다른 방법으로는, 여러분이 스스로 사인한 인증서를 설치할 수도 있습니다.</para>
					<para>이 절차는 여러분의 아파치2 웹 서버에 디지털 인증서를 설치하고 설정하였다고 간주 합니다. 이제, Subversion 저장소를 접근하기 위하여, 윗 부분을 참조 하십시오! 접근 방법은 정확히 똑같고, 단지 프로토콜이 다릅니다. 여러분은 반드시 Subversion 저장소를 접근하기 위하여 https://를 사용하여야 합니다.</para>

			</sect4>
			<sect4 id="access-via-custom-protocol" status="complete">
				<title>Subversion 프로토콜을 사용하여 접근 (svn://)</title>
					<para>Subversion 저장소가 만들어진 후, 여러분은 접근 조종을 설정할 수 있습니다. 접근 조종을 설정하기 위하여 <filename> /path/to/repos/project/conf/svnserve.conf</filename> 파일을 편집할 수 있습니다. 예를 들어, 인증을 설정하는 것은, 그 설정 파일의 다음 줄들을 주석 해제 합니다:</para>
					<programlisting># [general]
# password-db = passwd</programlisting>

					<para>위의 줄들을 주석 해제한 후에, passwd 파일에 사용자 목록을 관리할 수 있습니다. 그러므로, 같은 디렉토리 내의 <filename>passwd </filename> 파일을 편집하기 위하여 열고 새로운 사용자를 추가 합니다. 문법은 다음과 같습니다:</para>
					<programlisting>username = password</programlisting>
					<para>더 자세한 것은, 그 파일을 참조 하십시오.</para>

					<para>이제, svn:// 프로토콜을 사용하여, 같은 기계 또는 다른 기계에 있는 Subversion 저장소를 접근하고, svnserve 명령을 사용하여 svn 서버를 실행할 수 있습니다. 문법은 다음과 같습니다:</para>
					<programlisting>$ svnserve -d --foreground -r /path/to/repos
# -d -- daemon mode
# --foreground -- run in foreground (useful for debugging)
# -r -- root of directory to serve

For more usage details, please refer to:
$ svnserve --help</programlisting>

					<para>이 명령이 수행된 후, Subversion은 기본 설정 포트 (3690)을 듣기 시작 합니다. 프로젝트 저장소를 접근하려면, 터미널 프롬프트에서 다음의 명령을 반드시 실행하여야 합니다:</para>
					<para>
<screen>
<command>svn co svn://hostname/project project --username user_name</command>
</screen>
                                        </para>
					<para>서버 설정에 따라, 암호를 물어 봅니다. 인증이 된 후, Subversion 저장소에서 코드를 체크 아웃 합니다. 로컬 복사본과 프로젝트 저장소를 동기화 하는 것은, <command>update</command> 부 명령을 실행 합니다. 그 명령의 문법은, 다음과 같이 터미널 프롬프트에서 입력 합니다:</para>
					<para>
<screen>
<command>cd project_dir ; svn update</command>
</screen>
                                        </para>
					<para>각각의 Subversion 부 명령을 사용하는 것에 대한 더 자세한 것은, 매뉴얼을 참조 하십시오. 예를 들어, co (checkout) 명령에 대한 것을 배우려면, 터미널 프롬프트에서 다음의 명령을 실행 합니다:</para>
                    <para><screen><command>svn co help</command></screen></para>

			</sect4>
			<sect4 id="access-via-custom-protocol-with-ssl" status="complete">
				<title>SSL 암호화와 함께 Subversion 프로토콜을 사용하여 접근 (svn+ssh://)</title>
					<para>설정과 서버 절차는 svn:// 접근 방법 내의 것과 같습니다. 자세한 것은, 위의 영역을 참조 하십시오. 이 절차는 여러분이 위의 절차를 따라왔고 <application>svnserve</application> 명령을 사용하여 Subversion 서버을 실행하였다고 간주 합니다.</para>

					<para>또한 그 기계에 ssh 서버가 실행 중이고 들어오는 접속을 허용하는 중이라는 것도 가정 합니다. 확인을 하려면, ssh를 사용하여 그 기계에 로그인을 시도해 보십시오. 만약 로그인을 할 수 있으면, 모든 것은 완벽 합니다. 만약 로그인을 할 수 없다면, 더 진행하기 전에 그것을 먼저 고치십시오.</para>

					<para>svn+ssh:// 프로토콜은 SSL 암호화와 함께 Subversion 저장소를 접근하기 위하여 사용 됩니다. 자료 전송은 이 방법을 사용하여 암호화 됩니다. 프로젝트 저장소를 접근하려면 (예를 들어 체크 아웃으로), 여러분은 반드시 다음의 명령 문법을 사용하여야 합니다:</para>
                                        <para>
<screen>
<command>svn co svn+ssh://hostname/var/svn/repos/project</command>
</screen>
                                        </para>

					<note><para>이 접근 방법을 사용하여 Subversion 저장소를 접근하려면 반드시 완전한 경로명을 (/path/to/repos/project) 사용하여야 합니다.</para></note>
					<para>서버 설정에 따라, 암호를 물어 봅니다. 반드시 ssh 통하여 로그인 할 때 사용하는 암호를 입력 합니다. 인증이 된 후, Subversion 저장소에서 코드를 체크 아웃 합니다.</para>
			</sect4>
			</sect3>

      </sect2>
      <sect2 id="cvs-server" status="complete">
        <title>CVS 서버</title> 
          <para>CVS는 버전 관리 시스템 입니다. 소스 파일의 이력을 기록하기 위하여 그것을 사용할 수 있습니다.</para>
        <sect3 id="cvs-installation" status="complete">
          <title>설치</title>
            <para>터미널 프롬프트에서, <application>cvs</application> 를 설치하기 위하여 다음의 명령을 입력 합니다: <screen>
<command>sudo apt-get install cvs</command>
</screen> <application>cvs</application> 를 설치한 후에, cvs 서버를 시작하고 중지하려면 <application>xinetd</application> 를 설치하여야 합니다. 프롬프트에서, <application>xinetd</application> 를 설치하기 위하여 다음의 명령을 입력 합니다: <screen>
<command>sudo apt-get install xinetd</command>
</screen></para>
        </sect3>
        <sect3 id="cvs-configuration" status="complete">
          <title>설정</title>
            <para>여러분이 cvs를 설치한 후, 저장소는 자동적으로 초기화 됩니다. 기본 설정으로, 저장소는 <application>/var/lib/cvs</application> 디렉토리 밑에 있습니다. 다음 명령을 실행하는 것으로 그 경로를 변경할 수 있습니다: <screen>
<command>cvs -d /your/new/cvs/repo init</command>
</screen> 초기화된 저장소가 설정된 후, 여러분은 CVS 서버를 시작하기 위하여 <application>xinetd</application>를 설정할 수 있습니다. 다음 줄들을 <filename> /etc/xinetd/cvspserver</filename> 파일로 복사할 수 있습니다.<programlisting>
service cvspserver
{
     port = 2401
     socket_type = stream
     protocol = tcp
     user = root
     wait = no
     type = UNLISTED
     server = /usr/bin/cvs
     server_args = -f --allow-root /var/lib/cvs pserver
     disable = no
}
</programlisting>

<note>
<para>만약 기본 지정된 저장소 (<application>/var/lib/cvs</application>) 디렉토리를 변경하였다면 그 저장소를 편집하는 것을 확신 하십시오.</para>
</note> <application>xinetd</application>를 설정한 후에 다음 명령을 실행하는 것으로 cvs 서버를 시작할 수 있습니다: <screen>
<command>sudo /etc/init.d/xinetd start</command>
</screen></para>
            <para>다음의 명령을 수행하여 CVS 서버가 실행 중인 것을 확인할 수 있습니다:</para>

            <para>
<screen>
<command>sudo netstat -tap | grep cvs</command>
</screen>
            </para>

            <para>이 명령을 실행할 때, 여러분은 다음 줄 또는 그와 유사한 것을 보아야 합니다:</para>

<programlisting>
tcp 0 0 *:cvspserver *:* LISTEN 
</programlisting>

        <para>이제 여기서 여러분은 사용자를 더하고, 새로운 프로젝트를 더하며, 그 CVS 서버를 관리하는 것을 계속할 수 있습니다.</para>
        <warning>
<para>CVS는 OS 설치와는 무관하게 사용자를 추가할 수 있습니다. 아마도 가장 쉬운 것은 CVS를 위하여 리눅스 사용자를 사용하는 것이지만, 이것은 가능한 보안의 문제를 가지고 있습니다. 자세한 것은 CVS 매뉴얼을 참조 하십시오.</para>
        </warning>

        </sect3>
        <sect3 id="cvs-add-projects" status="complete">
          <title>프로젝트 더하기</title>
            <para>이 부분에서는 CVS 저장소에 어떻게 새 프로젝트를 추가하는 지를 설명 합니다. 디렉토리를 만들고 그 디렉토리에 필요한 문서와 소스 파일을 더합니다. 이제, 다음 명령을 실행하여 프로젝트를 CVS 저장소에 추가 합니다: <screen>
<command>cd your/project</command>
<command>cvs import -d :pserver:username@hostname.com:/var/lib/cvs -m "Importing my project to CVS repository" . new_project start</command>
</screen>

<tip>
<para>여러분은 CVS 루트 디렉토리를 저장하기 위하여 CVSROOT 환경 변수를 사용할 수 있습니다. CVSROOT 환경 변수가 export 되면, 위의 cvs 명령에 -d 옵션을 주는 것을 피할 수 있습니다.</para>
</tip> <emphasis>new_project</emphasis> 스트링은 벤더 태그이고 <emphasis>start</emphasis>는 릴리스 태그입니다. 이 문맥에서는 그것들은 아무 목적을 갖지 않지만, CVS가 그것들을 요구하므로, 반드시 나타내어야 합니다. <warning>
<para>새로운 프로젝트를 추가할 때, 여러분이 사용하는 CVS 사용자는 반드시 CVS 저장소 <application>/var/lib/cvs</application>) 의 쓰기 권한을 가져야 합니다. 기본 설정으로, <application>src</application> 그룹은 그 CVS 저장소로의 쓰기 권한을 가지고 있습니다. 그러므로, 여러분은 그 사용자를 이 그룹에 추가할 수 있고, 그런 후 그 사용자는 CVS 저장소 내의 프로젝트를 관리할 수 있습니다.</para>
</warning></para>
        </sect3>
      </sect2>
      <sect2 id="version-control-ref" status="complete">
        <title>참조</title> 
				<para><ulink url="http://subversion.tigris.org/">Subversion 홈 페이지</ulink></para>
				<para><ulink url="http://svnbook.red-bean.com/">Subversion 책</ulink></para>
				<para><ulink url="http://ximbiot.com/cvs/manual/cvs-1.11.21/cvs_toc.html">CVS 매뉴얼</ulink></para>
      </sect2>
    </sect1>
	<sect1 id="databases" status="complete">
		<title>데이타베이스</title>
          <para>우분투는 두 가지 데이타베이스 서버를 제공 합니다. 그것들은: <itemizedlist spacing="compact">
                <listitem>
                    <para><application><trademark>MySQL</trademark></application></para>
                </listitem>
                <listitem>
                    <para><application>PostgreSQL</application></para>
                </listitem>
            </itemizedlist> 메인 저장소에서 사용 가능 합니다. 이 영역은 이 데이타베이스 서버들을 어떻게 설치하고 설정하는 지를 설명 합니다.</para>
      <sect2 id="mysql" status="complete">
        <title>MySQL</title>
          <para>MySQL은 빠르고, 멀티쓰레드, 복수 사용자, 그리고 견고한 SQL 데이타베이스 서버 입니다. 이것은 대량의 소프트웨어 이행에 포함되는 것과 마찬가지로 중요한 임무와 부하가 많은 현업 시스템을 위하여 사용 됩니다.</para>

        <sect3 id="mysql-installation" status="complete">
          <title>설치</title>
            <para>MySQL을 설치하기 위하여, 터미널 프롬프트에서 다음 명령을 실행 합니다:</para>

            <para>
<screen>
<command>sudo apt-get install mysql-server mysql-client</command>
</screen>
            </para>

            <para>설치가 마쳐진 후, MySQL 서버는 자동적으로 시작 됩니다. MySQL 서바가 실행 중인지를 점검하려면 터미널 프롬프트에서 다음의 명령을 실행할 수 있습니다:</para>

            <para>
<screen>
<command>sudo netstat -tap | grep mysql</command>
</screen>
            </para>

            <para>이 명령을 실행할 때, 여러분은 다음 줄 또는 그와 유사한 것을 보아야 합니다:</para>

<programlisting>
tcp 0 0 localhost.localdomain:mysql *:* LISTEN -
</programlisting>
	<para>만약 서버가 올바르게 실행 중이 아니라면, 그것을 시작하기 위하여 다음의 명령을 입력할 수 있습니다:</para>
            <para>
<screen>
<command>sudo /etc/init.d/mysql restart</command>
</screen>
        </para>

        </sect3>
        <sect3 id="mysql-configuration" status="complete">
          <title>설정</title>
            <para>기본 설정으로, 관리자의 암호는 지정되지 않았습니다. MySQL을 설치한 후, 첫 번째로 여러분이 반드시 해야하는 것은 MySQL 관리자의 암호를 설정하는 것 입니다. 이것을 하기 위하여, 다음의 명령을 실행 합니다:</para>
            <para>
<screen>
<command>sudo mysqladmin -u root password newrootsqlpassword</command>
</screen>
            </para>
            <para>
<screen>
<command>sudo mysqladmin -p -u root -h localhost password newrootsqlpassword</command>
</screen>
            </para>

            <para>로그 파일, 포트 번호 등의 기본적인 값을 설정하기 위하여 <filename>/etc/mysql/my.cnf</filename> 파일을 편집할 수 있습니다. 더 자세한 것은 <filename>/etc/mysql/my.cnf</filename> 파일을 참조 하십시오.</para>
        </sect3>
      </sect2>
      <sect2 id="postgresql" status="complete">
        <title>PostgreSQL</title> 
          <para>PostgreSQL은 전통적인 상업용 데이타베이스 시스템의 기능에 차세대 DBMS 시스템에서 찾을 수 있는 개선을 포함하는 객체-관계형 데이타베이스 시스템 입니다.</para>
        <sect3 id="postgresql-installation" status="complete">
          <title>설치</title>
            <para>PostgreSQL를 설치하기 위하여, 명령 프롬프트에서 다음의 명령을 실행 합니다:</para>

            <para>
<screen>
<command>sudo apt-get install postgresql</command>
</screen>
            </para>

            <para>설치가 마쳐지면, 비록 기본 설정이 유용하기는 하지만, 여러분의 필요에 따라 PostgreSQL 서버를 설정할 수 있습니다.</para>
            
        </sect3>
        <sect3 id="postgresql-configuration" status="complete">
          <title>설정</title>
            <para>기본 설정으로, TCP/IP를 통한 접속은 사용할 수 없습니다. PostgreSQL는 복수 클라이언트 인증 방법을 지원 합니다. 기본 설정으로, IDENT 인증 방법이 사용 됩니다. <ulink url="http://www.postgresql.org/docs/8.1/static/admin.html"> PostgreSQL 관리자 안내서</ulink>를 참조 하십시오.</para>
            
            <para>다음의 논의는 여러분이 TCP/IP 접속을 사용하기를 원하고 클라이언트 인증을 위하여 MD5 방법을 사용한다고 가정 합니다. PostgreSQL 설정 파일은 <filename>/etc/postgresql/&lt;version&gt;/main</filename> 디렉토리 내에 저장 됩니다. 예를 들어, PostgreSQL 7.4를 설치한다면, 설정 파일은 <filename>/etc/postgresql/7.4/main</filename> 디렉토리 내에 저장 됩니다.</para>
            
            <tip>
            <para><application>ident</application> 인증을 설정하기 위하여, <filename>/etc/postgresql/7.4/main/pg_ident.conf</filename> 파일에 항목을 추가 합니다.</para>
            </tip>

            <para>TCP/IP 접속을 사용하기 위하여, <filename>/etc/postgresql/7.4/main/postgresql.conf</filename> 파일을 편집 합니다.</para>

            <para><emphasis>#tcpip_socket = false</emphasis> 줄에 위치하고 그것을 <emphasis>tcpip_socket = true</emphasis> 로 변경 합니다. 만약 여러분이 무엇을 하는지를 알고 있다면, 모든 다른 파라미터들도 또한 편집할 수 있습니다! 자세한 것은, 그 설정 파일 또는 PostgreSQL 문서를 참조 하십시오.</para>

            <para>기본 설정으로, 사용자 보증은 <emphasis>MD5</emphasis> 클라이언트 인증을 위하여 지정될 수 없습니다. 그러므로, 우선 <emphasis>trust</emphasis> 클라이언트 인증을 사용하도록 PostgreSQL 서버를 설정하고, 데이타베이스로 연결하고, 암호를 설정하고, <emphasis>MD5</emphasis> 클라이언트 인증을 사용하도록 설정을 바꾸는 것이 필요 합니다. <emphasis>trust</emphasis> 클라이언트 인증을 활성화 하려면, <filename>/etc/postgresql/7.4/main/pg_hba.conf</filename> 파일을 편집 합니다.</para>

            <para><emphasis>ident</emphasis> 와 <emphasis>MD5</emphasis> 클라이언트 인증을 사용하는 모든 있는 줄들을 주석 처리하고 다음 줄을 추가 합니다:</para>
<programlisting>
local all postgres trust sameuser
</programlisting>

            <para>그런 후, PostgreSQL 서버를 시작하기 위하여 다음 명령을 실행 합니다:</para>
            <para>
<screen>
<command>sudo /etc/init.d/postgresql start</command>
</screen>
            </para>
            <para>PostgreSQL 서버가 성공적으로 시작된 후, 기본 설정된 PostgreSQL 템플릿 데이타베이스에 접속하기 위하여 터미널 프롬프트에서 다음의 명령을 실행 합니다:</para>

            <para>
<screen>
<command>psql -U postgres -d template1</command>
</screen>
            </para>
            <para>위의 명령은 사용자 <emphasis>postgres</emphasis>로써 PostgreSQL 데이타베이스 <emphasis>template1</emphasis> 로 접속 합니다. PostgreSQL 서버로 접속하면, 여러분은 SQL 프롬프트를 보게 됩니다. <emphasis role="italics">postgres</emphasis> 사용자의 암호를 설정하기 위하여 <application>psql</application> 프롬프트에서 다음의 SQL 명령을 실행할 수 있습니다.</para>

            <para>
<screen>
<command>template1=# ALTER USER postgres with encrypted password 'your_password';</command>
</screen>
            </para>
            <para>암호를 설정한 후에, <emphasis>MD5</emphasis> 인증을 사용하기 위하여 <filename>/etc/postgresql/7.4/main/pg_hba.conf</filename> 파일을 편집 합니다:</para>
            <para>최근에 추가된 <emphasis role="italics">trust</emphasis> 줄을 주석 처리하고 다음 줄을 추가 합니다:</para>

<programlisting>
local all postgres md5 sameuser
</programlisting>
            <warning>
            <para>위의 설정은 어떠한 의미로도 완전하지 않습니다. 더 많은 파라미터를 설정하기 위해서는 <ulink url="http://www.postgresql.org/docs/8.1/static/admin.html"> PostgreSQL 관리자 안내서</ulink> 를 참조 하십시오.</para>
            </warning>
        </sect3>
      </sect2>
    </sect1>
	<sect1 id="email-services" status="complete">
		<title>이메일 서비스</title>
          <para>네트워크 또는 인터넷 상에서 한 사람에서 부터 다른 사람으로 이메일을 가지는 과정은 많은 시스템이 함께 동작하는 것과 관련 됩니다. 각각의 시스템은 과정이 동작하기 위하여 반드시 올바르게 설정되어야 합니다. 보내는 사람은 <emphasis>Mail User Agent</emphasis> (MUA) 또는 이메일 클라이언트를 사용하고, 메세지를 보내기 위하여 하나 또는 여러 개의 <emphasis>Mail Transfer Agents</emphasis> (MTA) 를 통과하며, 마지막으로, 받는 사람의 메일박스에 배달을 하기 위하여 <emphasis>Mail Delivery Agent</emphasis> (MDA) 를 거치게 됩니다. 그리고, 메일은 보통 POP3 또는 IMAP 서버를 통하여 받는 사람의 이메일 클라이언트에 의해 읽혀지게 됩니다.</para>
      <sect2 id="postfix" status="complete">
        <title>Postfix</title>
          <para><application>Postfix</application> 는 우분투에서 기본 설정된 Mail Transfer Agent (MTA) 입니다. 이것은 빠르고 관리와 보안을 하기가 수월 합니다. 그리고 MTA 인 <application>sendmail</application> 과 호환이 됩니다. 이 영역은 <application>postfix</application> 를 어떻게 설치하고 설정하는 지를 설명 합니다. 또한 그것을 보안 연결을 (안전하게 이메일을 보내기 위한) 사용하는 SMTP 서버로서 어떻게 만드는 지를 설명 합니다.</para>
        <sect3 id="postfix-installation" status="complete">
          <title>설치</title>
            <para><application>postfix</application>를 SMTP-AUTH와 Transport Layer Security (TLS)과 함께 설치하기 위하여, 다음의 명령을 실행 합니다: <screen>
<command>sudo apt-get install postfix</command>
</screen> 설치 과정 중에 물어보는 질문에 간단히 엔터키를 누르고, 설정은 다음 단계에서 보다 자세히 마쳐지게 됩니다.</para>
        </sect3>
        <sect3 id="postfix-configuration" status="complete">
          <title>기본적인 설정</title>
            <para><application>postfix</application> 를 설정하기 위하여, 다음 명령을 실행 합니다: screen&gt;
<command>sudo dpkg-reconfigure postfix</command>
</para>
            <note>
            <para>mail.example.com 는 여러분의 메일 서버 호스트 이름으로 대체 합니다.</para>
            </note>
	 </sect3>
        <sect3 id="postfix-smtp-authentication" status="complete">
          <title>SMTP 인증</title>
            <para>다음 단게는 SMTP AUTH를 위하여 SASL을 사용하도록 <application>postfix</application>를 설정하는 것 입니다. 설정 파일을 직접 편집하는 대신에, 모든 <application>postfix</application> 파라미터를 설정하기 위하여 <command>postconf</command> 명령을 사용할 수 있습니다. 설정 파라미터들은 <filename>/etc/postfix/main.cf</filename> 파일 내에 저장 됩니다. 나중에 만약 여러분이 특정 파라미터를 재 설정하기를 원한다면, 그 명령을 실행하거나 또는 그 파일을 수작업으로 변경할 수 있습니다.</para>
	<procedure>
		<step><para>SASL saslauthd)을 사용하여 SMTP AUTH를 하도록 Postfix를 설정 합니다: <screen>
postconf -e 'smtpd_sasl_local_domain ='
postconf -e 'smtpd_sasl_auth_enable = yes'
postconf -e 'smtpd_sasl_security_options = noanonymous'
postconf -e 'broken_sasl_auth_clients = yes'
postconf -e 'smtpd_recipient_restrictions = permit_sasl_authenticated,permit_mynetworks,reject_unauth_destination'
postconf -e 'inet_interfaces = all'
</screen> <filename>/etc/postfix/sasl/smtpd.conf</filename> 파일을 열고 그 파일의 마지막에 다음 줄들을 더합니다: <screen>
pwcheck_method: saslauthd
mech_list: plain login
</screen></para>
		</step>
		<step><para>다음, TLS를 위한 전자 인증서를 설정 합니다. 질문들을 물어볼 때, 다음의 지시를 따르고 적절하게 대답 합니다. <screen>
openssl genrsa -des3 -rand /etc/hosts -out smtpd.key 1024
chmod 600 smtpd.key
openssl req -new -key smtpd.key -out smtpd.csr
openssl x509 -req -days 3650 -in smtpd.csr -signkey smtpd.key -out smtpd.crt
openssl rsa -in smtpd.key -out smtpd.key.unencrypted
mv -f smtpd.key.unencrypted smtpd.key
openssl req -new -x509 -extensions v3_ca -keyout cakey.pem -out cacert.pem -days 3650
sudo mv smtpd.key /etc/ssl/private/
sudo mv smtpd.crt /etc/ssl/certs/
sudo mv cakey.pem /etc/ssl/private/
sudo mv cacert.pem /etc/ssl/certs/
</screen></para>
		<note><para>여러분은 인증 기관에서 디지털 인증서를 가질 수 있습니다. 다른 방법으로는, 스스로 인증서를 만들 수 있습니다. 더 자세한 것은 <xref linkend="creating-a-self-signed-certificate"/> 를 참조 하십시오.</para></note>
		</step>
		<step><para>들어오는 이메일과 나가는 이메일 모두에 TLS 암호화를 적용하도록 Postfix를 설정하려면:  <screen>
postconf -e 'smtpd_tls_auth_only = no'
postconf -e 'smtp_use_tls = yes'
postconf -e 'smtpd_use_tls = yes'
postconf -e 'smtp_tls_note_starttls_offer = yes'
postconf -e 'smtpd_tls_key_file = /etc/ssl/private/smtpd.key'
postconf -e 'smtpd_tls_cert_file = /etc/ssl/certs/smtpd.crt'
postconf -e 'smtpd_tls_CAfile = /etc/ssl/certs/cacert.pem'
postconf -e 'smtpd_tls_loglevel = 1'
postconf -e 'smtpd_tls_received_header = yes'
postconf -e 'smtpd_tls_session_cache_timeout = 3600s'
postconf -e 'tls_random_source = dev:/dev/urandom'
postconf -e 'myhostname = mail.example.com'
</screen></para>
		</step>
		</procedure>
            <note>
            <para>명령을 모두 실행하고 나면 <application>postfix</application>를 위한 SMTP AUTH의 설정이 모두 끝납니다. <application>postfix</application>에서 이어서 TLS에서 사용할 인증서를 직접 서명하여 설정합니다.</para>
            </note>
            <para>이때 <filename>/etc/postfix/main.cf</filename>와 <ulink url="../sample/postfix_configuration">this</ulink>이 같아보여야 합니다.</para>
		<para>Postfix의 초기 설정이 이제 끝났습니다. Postfix 데몬을 시작하려면 <screen><command>sudo /etc/init.d/postfix start</command></screen>을 실행하십시오. 이제 <application>postfix</application> 데몬이 무사히 설치되었으며, 설정이 끝나고 이제 실행중입니다. <application>Postfix</application>는 <ulink url="ftp://ftp.isi.edu/in-notes/rfc2554.txt">RFC2554</ulink>에서 정의한 SMTP AUTH를 지원하며, <ulink url="ftp://ftp.isi.edu/in-notes/rfc2222.txt">SASL</ulink>를 따르고 있습니다. 하지만 SMTP를 사용기 위해서는 SASL 인증도 설정해야 합니다.</para>
	</sect3>
	<sect3 id="sasl">
	  <title>SASL 설정하기</title>
            <para>
            The
            <application>libsasl2</application>,
            <application>sasl2-bin</application> and
            <application>libsasl2-modules</application> are necessary to
            enable SMTP AUTH using SASL. You can install these applications if
            you have not installed them already.
<screen>
<command>sudo apt-get install libsasl2 sasl2-bin</command>
</screen>
	    </para>
	    <para>SASL를 제대로 사용하기 위해서는 수정해야 할 것이 몇 가지 있습니다. <application>Postfix</application>는 <filename>/var/spool/postfix</filename> 내에 chroot된 상태로 동작하기 때문에, <application>SASL</application> 역시 그 chroot된 환경 내에서 동작할 수 있도록 설정해야합니다(<filename>/var/run/saslauthd</filename> 대신에 <filename>/var/spool/postfix/var/run/saslauthd</filename>가 됩니다). 다음 명령을 입력하십시오: <screen>
<command>mkdir -p /var/spool/postfix/var/run/saslauthd</command>
<command>rm -rf /var/run/saslauthd</command>
</screen></para>
	    <para><application>saslauthd</application>을 작동시키려면, <filename>/etc/default/saslauthd</filename> 을 편집하기 위하여 열고, START 변수를 변경하거나 추가 합니다. <application>saslauthd</application> 이 가짜 root 환경에서 실행되도록 설정하기 위해서는, PWDIR, PIDFILE과 PARAMS 변수를 더합니다. 마지막으로, MECHANISMS 변수를 여러분이 좋아하는 곳으로 설정 합니다. 그 파일을 다음과 비슷하게 보일 겁니다: <programlisting>
# This needs to be uncommented before saslauthd will be run
# automatically
START=yes

PWDIR="/var/spool/postfix/var/run/saslauthd"
PARAMS="-m ${PWDIR}"
PIDFILE="${PWDIR}/saslauthd.pid"

# You must specify the authentication mechanisms you wish to use.
# This defaults to "pam" for PAM support, but may also include
# "shadow" or "sasldb", like this:
# MECHANISMS="pam shadow"

MECHANISMS="pam"
</programlisting></para>
<note>
<para>만약 여러분이 좋아한다면, <emphasis role="strong">shadow</emphasis>를 <emphasis role="strong">pam</emphasis> 대신에 사용할 수 있습니다. 이것은 MD5 해쉬된 암호 전송을 사용하고 완전하게 안전 합니다. 인증을 하기 위하여 필요한 사용자 이름과 암호는 여러분이 사용하는 서버 시스템의 사용자의 그것들이 됩니다.</para>
</note>
        <para>다음은, <filename>/var/spool/portfix/var/run/saslauthd</filename>의 dpkg "state"를 업데이트 합니다. saslauthd init script는 적당한 접근 권한과 소유권을 가지고 없는 디렉토리를 만들기 위하여 이 설정을 사용 합니다: <screen>
<command>dpkg-statoverride --force --update --add root sasl 755 /var/spool/postfix/var/run/saslauthd</command>
</screen></para>
        </sect3>
        <sect3 id="postfix-testing" status="complete">
          <title>테스팅</title>
            <para>SMTP AUTH 설정을 마쳤습니다. 이제는 그것을 시작하고 설정을 테스트할 시간 입니다. SASL 데몬을 시작하기 위하여 다음의 명령을 실행할 수 있습니다: <screen><command>sudo /etc/init.d/saslauthd start</command></screen> SMTP-AUTH과 TLS가 적절하게 동작하는 지를 보려면, 다음의 명령을 실행 합니다: <screen><command>telnet mail.example.com 25</command></screen> 여러분이 postfix 메일 서버로 접속을 만들고 난 후, <screen>ehlo mail.example.com</screen> 을 입력하고 만약 다음의 줄들을 다른 것과 보게 된다면, 모든 것은 완전하게 동작하는 것 입니다. <command>quit</command>를 입력하여 종료 하십시오. <programlisting>
250-STARTTLS
250-AUTH LOGIN PLAIN
250-AUTH=LOGIN PLAIN
250 8BITMIME
</programlisting></para>
        </sect3>
      </sect2>
      <sect2 id="exim4" status="complete">
        <title>Exim4</title>
          <para>
            <application>Exim4</application> is another Message Transfer
            Agent (MTA) developed at the University of Cambridge for use
            on Unix systems connected to the internet. Exim can be
            installed in place of <application>sendmail</application>,
            although the configuration of
            <application>exim</application> is quite different to
            that of <application>sendmail</application>.
          </para>
        <sect3 id="exim4-installation" status="complete">
          <title>설치</title>
            <para><application>exim4</application>를 설치하기 위하여, 다음 명령을 실행 합니다: <screen>
<command>sudo apt-get install exim4 exim4-base exim4-config</command>
</screen></para>
        </sect3>
        <sect3 id="exim4-configuration" status="complete">
          <title>설정</title>
            <para><application>exim4</application>를 설정하기 위하여, 다음 명령을 실행 합니다: <screen>
<command>sudo dpkg-reconfigure exim4-config</command>
</screen> 사용자 인터페이스가 보여질 겁니다. 사용자 인터페이스는 여러분이 많은 파라미터를 설정할 수 있도록 합니다. 예를 들어, <application>exim4</application> 설정 파일은 여러 개의 파일들로 나누어 집니다. 만약 여러분이 그것들을 한 파일로 갖기를 원한다면 이 사용자 인터페이스에서 적절하게 설정할 수 있습니다.</para>

            <para>사용자 인터페이스에서 여러분이 설정한 모든 파라미터들은 <filename>/etc/exim4/update-exim4.conf.conf</filename> 파일에 저장됩니다. 만약 재설정을 하고자 한다면, 설정 마법사를 재 실행하거나 여러분이 좋아하는 편집기를 사용하여 이 파일을 손수 편집합니다. 여러분이 설정한 후에, 주 설정 파일을 생성하기 위하여 다음 명령을 실행할 수 있습니다: <screen>
<command>sudo update-exim4.conf</command>
</screen> 주 설정 파일은 만들어지고 그것은 <filename>/var/lib/exim4/config.autogenerated</filename> 에 저장됩니다. <warning>
            <para>언제든, 여러분은 주 설정 파일, <filename>/var/lib/exim4/config.autogenerated</filename>을 수작업으로 편집하지 않습니다. 그것은 <command>update-exim4.conf</command>를 실행할 때마다 자동적으로 업데이트 됩니다.</para>
            </warning> 여러분은 <application>exim4</application> 데몬을 시작하기 위하여 다음 명령을 실행할 수 있습니다. <screen>
<command>sudo /etc/init.d/exim4 start</command>
</screen>
            <emphasis role="strong">TODO:</emphasis> 이 부분에서는 exim4에 SMTP AUTH 설정하는 것을 다루어야 합니다.</para>
        </sect3>
      </sect2>
      <sect2 id="dovecot-server" status="complete">
        <title>Dovecot 서버</title> 
          <para><application>Dovecot</application> 은 보안 우선을 염두에 두고 쓰여진 Mail Delivery Agent 입니다. 이것은 mbox 와 Maildir 같은 주요 메일박스 형식을 지원 합니다. 이 영역은 imap 또는 pop3 서버로서 Dovecot을 어떻게 설정하는 지를 설명 합니다.</para>
        <sect3 id="dovecot-installation" status="complete">
          <title>설치</title>
            <para><application>dovecot</application> 설치하기 위하여, 명령 프롬프트에서 다음 명령을 실행 합니다: <screen>
<command>sudo apt-get install dovecot-common dovecot-imapd dovecot-pop3d</command>
</screen></para>
        </sect3>
        <sect3 id="dovecot-configuration" status="complete">
          <title>설정</title>
            <para><application>dovecot</application>을 설정하기 위하여, <filename>/etc/dovecot/dovecot.conf</filename> 파일을 편집할 수 있습니다. 여러분이 사용하고자 하는 프로토콜을 선택할 수 있고, 그것은 pop3, pop3s (pop3 secure), imap 그리고 imaps (imap secure)이 될 수 있습니다. 이 프로토콜에 대한 설명은 이 안내서의 범위 밖 입니다. 더 많은 정보는, wikipedia의 다음 글을, <ulink url="http://en.wikipedia.org/wiki/POP3">POP3</ulink> 와 <ulink url="http://en.wikipedia.org/wiki/Internet_Message_Access_Protocol">IMAP</ulink>, 참고 하십시오.</para>

            <para>
            IMAPS and POP3S are more secure that the simple IMAP and
            POP3 because they use SSL encryption to connect. Once you
            have chosen the protocol, amend the following line in the file
            <filename>/etc/dovecot/dovecot.conf</filename>:
<programlisting>
protocols = pop3 pop3s imap imaps
</programlisting>

            It enables the protocols when <application>dovecot</application> is started. Next, add the following line in the pop3 section of the file <filename>/etc/dovecot/dovecot.conf</filename>:
<programlisting>
pop3_uidl_format = %08Xu%08Xv
</programlisting>

            Next, choose the mailbox you use. <application>Dovecot</application> supports
            <emphasis role="strong">maildir</emphasis> and <emphasis role="strong">mbox</emphasis> formats. These are the most
            commonly used mailbox formats. They both have their own
            benefits and they are discussed on <ulink url="http://dovecot.org/doc/configuration.txt">the dovecot website</ulink>.
            </para>
            <para>여러분의 메일박스 종류를 선택한 후, <filename>/etc/dovecot/dovecot.conf</filename> 파일을 편집하기 위하여 열고 다음 줄을 변경 합니다: <programlisting>
default_mail_env = maildir:~/Maildir # (for maildir)
또는
default_mail_env = mbox:~/mail:INBOX=/var/spool/mail/%u # (for mbox)
</programlisting></para>
<note>
<para>
You should configure your Mail Transport Agent (MTA) to transfer the
incoming mail to this type of mailbox if it is different from the one
you have configured.
</para>
</note>
          <para>
          Once you have configured dovecot, start the <application>dovecot</application> daemon
          in order to test your setup:

          <screen><command>sudo /etc/init.d/dovecot start</command></screen>

          If you have enabled imap, or pop3, you can also try to log in
          with the commands <command>telnet localhost pop3</command> or
          <command>telnet localhost imap2</command>. If you see
          something like the following, the installation has been
          successful:
<programlisting>
bhuvan@rainbow:~$ telnet localhost pop3
Trying 127.0.0.1...
Connected to localhost.localdomain.
Escape character is '^]'.
+OK Dovecot ready.
</programlisting>
          </para>
        </sect3>
        <sect3 id="dovecot-ssl" status="complete">
          <title>Dovecot SSL 설정</title>
            <para>SSL을 사용하도록 <application>dovecot</application>을 설정하기 위하여, <filename>/etc/dovecot/dovecot.conf</filename> 파일을 편집하기 위해 열고 다음 줄을 수정 합니다: <programlisting>
ssl_cert_file = /etc/ssl/certs/dovecot.pem
ssl_key_file = /etc/ssl/private/dovecot.pem
ssl_disable = no
disable_plaintext_auth = no
</programlisting> <emphasis role="strong">cert</emphasis> 와 <emphasis role="strong">key</emphasis> 파일은 설치될 때 <application>dovecot</application>에 의하여 자동적으로 만들어 집니다. 이 키는 사인되지 않았고 클라이언트에서 연결을 할 때 "bad signature" 에러를 주게 되는 것을 주의 하십시오. 이 것을 피하려면, 상업용 인증서를 사용할 수 있고, 또는 보다 낫게, 여러분 스스로의 SSL 인증서를 사용할 수 있습니다.</para>
	</sect3>
	<sect3>
	  <title>이메일 서버를 위한 방화벽 설정</title>
          <para>다른 컴퓨터에서 메일 서버를 접근하려면, 필요한 포트로 서버로의 접속을 허용하도록 방화벽을 반드시 설정해야만 합니다. <itemizedlist>
            <listitem><para>IMAP - 143</para></listitem>
            <listitem><para>IMAPS - 993</para></listitem>
            <listitem><para>POP3 - 110</para></listitem>
            <listitem><para>POP3S - 995</para></listitem>
            </itemizedlist></para>
        </sect3>
      </sect2>
      <sect2 id="mailman" status="complete">
        <title>Mailman</title> 
          <para>Mailman은 전자 우편 회의와 전자 소식 목록을 관리하기 위한 오픈소스 프로그램 입니다. 많은 오픈소스 메일링 리스트는 (모든 <ulink url="http://lists.ubuntu.com">우분투 메일링 리스트</ulink>를 포함한) 메일링 리스트 소프트웨어로 Mailman을 사용 합니다. 이것은 강력하고 설치와 유지보수가 쉽습니다.</para>
        <sect3 id="mailman-installation" status="complete">
          <title>설치</title>
            <para>Mailman은 관리자와 사용자를 위한 웹 인터페이스를 제공 합니다. 그러므로, 그것은 mod_perl 지원을 하는 아파치를 필요로 합니다. Mailman은 이메일을 보내고 받기 위한 외부 메일 서버를 사용 합니다. 다음의 메일 서버와 완벽하게 동작 합니다:</para>
            <para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para><application>Postfix</application></para>
                </listitem>
                <listitem>
                    <para><application>Exim</application></para>
                </listitem>
                <listitem>
                    <para><application>Sendmail</application></para>
                </listitem>
                <listitem>
                    <para><application>Qmail</application></para>
                </listitem>
            </itemizedlist>
            </para>

            <para>우리는 어떻게 mailman, 아파치 웹 서버와 Exim 메일 서버를 설치하는지를 봅니다. 만약 여러분이 mailman을 다른 메일 서버와 함께 설치하기를 원한다면, 참조 영역을 참고 하십시오.</para>
          <sect4 id="mailman-apache2">
            <title>아파치2</title>
              <para>아파치2를 설치하는 것은 <xref linkend="http-installation"/> 을 참조 하십시오.</para>
          </sect4>
          <sect4 id="mailman-exim4">
            <title>Exim4</title>
              <para>
              To install Exim4 you run the following commands at a terminal prompt:
<screen>
<command>sudo apt-get install exim4</command>
<command>sudo apt-get install exim4-base</command>
<command>sudo apt-get install exim4-config</command>
</screen>

Once exim4 is installed, the configuration files are stored in
the <filename>/etc/exim4</filename> directory. In Ubuntu, by default, the exim4 configuration files are
split across different files. You can change this behavior by changing
the following variable in the <filename>/etc/exim4/update-exim4.conf</filename> file:

              <itemizedlist spacing="compact">
              <listitem>
                <para><application>dc_use_split_config='true'</application></para>
              </listitem>
              </itemizedlist>
              </para>
          </sect4>
          <sect4 id="mailman-mailman">
            <title>Mailman</title>
              <para><application>Mailman</application> 을 설치하기 위하여, 터미널 프롬프트에서 다음 명령을 실행 합니다: <screen>
<command>sudo apt-get install mailman</command> 
</screen> 이것은 설치 파일을 <application>/var/lib/mailman</application> 디렉토리 내로 복사하고, <application>/usr/lib/cgi-bin/mailman</application> 디렉토리 내에 CGI 스크립트를 설치 합니다. <emphasis>list</emphasis> 리눅스 사용자를 만들고, <emphasis>list</emphasis> 리눅스 그룹도 만듭니다. mailman 프로세스는 이 사용자에 의하여 소유 됩니다.</para>
          </sect4>
        </sect3>
        <sect3 id="mailman-configuration" status="complete">
          <title>설정</title>
            <para>이 영역에서는 여러분이 <application>mailman</application>, <application>apache2</application>, 그리고 <application>exim4</application>를 성공적으로 설치하였다고 가정 합니다. 이제 여러분은 단지 그것들을 설정할 필요가 있습니다.</para>
          <sect4 id="mailman-conf-apache2">
            <title>아파치2</title>
              <para>아파치2가 설치되면, <filename>/etc/apache2/apache2.conf</filename> 파일에 다음의 줄들을 추가할 수 있습니다: <programlisting>
Alias /images/mailman/ "/usr/share/images/mailman/"
Alias /pipermail/ "/var/lib/mailman/archives/public/"
</programlisting> Mailman은 CGI 스크립트를 사용하기 위하여 아파치2를 이용 합니다. 메일맨 스크립트는 <application>/usr/lib/cgi-bin/mailman</application> 디렉토리에 설치 됩니다. 그러므로 그 메일맨 url은 http://hostname/cgi-bin/mailman/ 이 됩니다. 만약 변경하기를 원한다면, <filename>/etc/apache2/apache2.conf</filename> 파일에서 바꿀 수 있습니다.</para>
          </sect4>

          <sect4 id="mailman-conf-exim4">
            <title>Exim4</title>
              <para>Exim4를 설치한 후, 터미널 프롬프트에서 다음 명령을 사용하여 Exim 서버를 시작할 수 있습니다: <screen>
<command>sudo apt-get /etc/init.d/exim4 start</command>
</screen> exim4와 함께 mailman이 동작하게 만들려면, exim4를 설정하는 것이 필요 합니다. 앞에 언급된 것과 같이, 기본 설정으로, exim4는 다른 종류의 복수 설정 파일들을 사용 합니다. 자세한 것은 <ulink url="http://www.exim.org">Exim</ulink> 웹 사이트를 참조 하십시오. mailman을 실행하기 위하여, 다음 설정 종류에 대한 새로운 설정 파일을 추가하여야 합니다: <itemizedlist spacing="compact">
              <listitem>
                <para>Main</para>
              </listitem>
              <listitem>
                <para>Transport</para>
              </listitem>
              <listitem>
                <para>Router</para>
              </listitem>
              </itemizedlist> Exim은 모든 이 작은 설정 파일들을 정렬하여 주 설정 파일을 만듭니다. 그러므로, 이 설정 파일의 순서는 매우 중요 합니다.</para>
          </sect4>
          <sect4 id="mailman-conf-main">
            <title>Main</title>
              <para>Main 종류에 속하는 모든 설정 파일들은 <filename>/etc/exim4/conf.d/main/</filename> 디렉토리 내에 저장 됩니다. <filename>04_exim4-config_mailman</filename> 이란 이름의 새 파일에 다음의 내용을 추가할 수 있습니다: <programlisting>
# start
# Home dir for your Mailman installation -- aka Mailman's prefix
# directory.
# On Ubuntu this should be "/var/lib/mailman"
# This is normally the same as ~mailman
MM_HOME=/var/lib/mailman
#
# User and group for Mailman, should match your --with-mail-gid
# switch to Mailman's configure script. Value is normally "mailman"
MM_UID=list
MM_GID=list
#
# Domains that your lists are in - colon separated list
# you may wish to add these into local_domains as well
domainlist mm_domains=hostname.com
#
# -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#
# These values are derived from the ones above and should not need
# editing unless you have munged your mailman installation
#
# The path of the Mailman mail wrapper script
MM_WRAP=MM_HOME/mail/mailman
#
# The path of the list config file (used as a required file when
# verifying list addresses)
MM_LISTCHK=MM_HOME/lists/${lc::$local_part}/config.pck
# end
</programlisting></para>
          </sect4>
          <sect4 id="mailman-conf-transport">
            <title>Transport</title>
              <para>Transport 종류에 속하는 모든 설정 파일들은 <filename>/etc/exim4/conf.d/transport/</filename> 디렉토리 내에 저장 됩니다. <filename> 40_exim4-config_mailman</filename> 이란 이름의 새 파일에 다음의 내용을 추가할 수 있습니다: <programlisting>
  mailman_transport:
   driver = pipe
   command = MM_WRAP \
               '${if def:local_part_suffix \
                     {${sg{$local_part_suffix}{-(\\w+)(\\+.*)?}{\$1}}} \
                     {post}}' \
               $local_part
    current_directory = MM_HOME
    home_directory = MM_HOME
    user = MM_UID
    group = MM_GID
</programlisting></para>
          </sect4>
          <sect4 id="mailman-conf-router">
            <title>Router</title>
              <para>Router 종류에 속하는 모든 설정 파일들은 <filename>/etc/exim4/conf.d/router/</filename> 디렉토리 내에 저장 됩니다. <filename>101_exim4-config_mailman</filename> 이란 이름의 새 파일에 다음의 내용을 추가할 수 있습니다: <programlisting>
  mailman_router:
   driver = accept
   require_files = MM_HOME/lists/$local_part/config.pck
   local_part_suffix_optional
   local_part_suffix = -bounces : -bounces+* : \
                       -confirm+* : -join : -leave : \
                       -owner : -request : -admin
   transport = mailman_transport
</programlisting></para>
<warning>
<para>Main과 Transport 설정 파일들의 순서는 어느 순서가 되도 무방 합니다. 그러나, Router 설정 파일의 순서는 반드시 똑같아야 합니다. 이 특정 파일은 <application>200_exim4-config_primary</application> 파일 이전에 반드시 나타나야 합니다. 이 두 설정 파일은 같은 종류의 정보를 가지고 있습니다. 첫 번째 파일이 우선권을 가집니다. 더 자세한 것은, 참조 영역을 참고 하십시오.</para>
</warning>
          </sect4>
          <sect4 id="mailman-conf-mailman">
            <title>Mailman</title>
              <para>mailman이 설치된 후, 여러분은 다음 명령을 사용하여 그것을 실행할 수 있습니다: <screen>
<command>sudo /etc/init.d/mailman start</command>
</screen> mailman이 설치된 후, 반드시 기본 설정 메일링 리스트를 만들어야 합니다. 그 메일링 리스트를 만들기 위하여 다음 명령을 실행 합니다: screen&gt;
<command>sudo /usr/sbin/newlist mailman</command>
</para>
          </sect4>
        </sect3>
        <sect3 id="mailman-admin" status="complete">
          <title>관리</title>
<para>
We assume you have a default installation. The
mailman cgi scripts are still in the
<application>/usr/lib/cgi-bin/mailman/</application> directory.  Mailman
provides a web based administration facility. To access this page, point
your browser to the following url: 

</para>
<para>http://hostname/cgi-bin/mailman/admin</para>

<para>
The default mailing list, <emphasis>mailman</emphasis>,
will appear in this screen. If you click the mailing list name, it
will ask for your authentication password.  If you enter the correct
password, you will be able to change administrative settings of this
mailing list.

You can create a new mailing list using the command line utility
(<command>/usr/sbin/newlist</command>).
Alternatively, you can create a new mailing list using the web interface. 
</para>
        </sect3>
        <sect3 id="mailman-users" status="complete">
          <title>사용자</title>
<para>Mailman은 사용자에게 웹 기반의 인터페이스를 제공 합니다. 이 페이지를 접근하려면, 다음 url을 여러분의 브라우저에서 사용 합니다:</para>

<para>http://hostname/cgi-bin/mailman/listinfo</para>

<para>기본 설정된 메일링 리스트, <emphasis>mailman</emphasis> 가 이 화면에 나타납니다. 그 메일링 리스트 이름을 클릭하면, 가입 양식을 보입니다. 여러분의 이메일 주소, 이름(선택사항) 그리고 암호를 가입하기 위하여 입력 합니다. 여러분에게 이메일 초대가 보내집니다. 가입하기 위하여 그 이메일의 절차를 따릅니다.</para>
        </sect3>
        <sect3 id="mailman-references" status="complete">
          <title>참조</title>
<para>
<ulink url="http://www.list.org/mailman-install/index.html">GNU Mailman - 설치 매뉴얼</ulink>
</para>
<para>
<ulink url="http://www.exim.org/howto/mailman21.html">하우투 - Exim 4와 Mailman 2.1을 함께 사용하기</ulink>
</para>
        </sect3>
      </sect2>
     </sect1>

	<sect1 id="NTP" status="complete">
		<title>Time Synchronisation with NTP</title>
	<para>
This page describes methods for keeping your computer's time accurate. This is useful for servers, but is not necessary (or desirable) for desktop machines. 
</para>
	<para>
NTP is a TCP/IP protocol for synchronising time over a network. Basically a client requests the current time from a server, and uses it to set its own clock.  
</para>
	<para>
Behind this simple description, there is a lot of complexity - there are tiers of NTP servers, with the tier one NTP servers connected to atomic clocks (often via GPS), and tier two and three servers spreading the load of actually handling requests across the internet. Also the client software is a lot more complex than you might think - it has to factor out communication delays, and adjust the time in a way that does not upset all the other processes that run on the server. But luckily all that complexity is hidden from you! 
</para>
	<para>
Ubuntu has two ways of automatically setting your time: ntpdate and ntpd. 
</para>

<sect2 id="ntpdate" status="complete">
<title>ntpdate</title>
	<para>
Ubuntu comes with ntpdate as standard, and will run it once at boot time to set up your time according to Ubuntu's NTP server. However, a server's clock  is likely to drift considerably between reboots, so it makes sense to correct the time ocassionally. The easiest way to do this is to get cron to run it every day. With your favourite editor, create a file 
<code>/etc/cron.daily/ntpdate</code>
 containing: 
</para>
<screen>ntpdate ntp.ubuntu.com
</screen>
<para/>
</sect2>
      <sect2 id="ntpd" status="complete">
<title>ntpd</title>
	<para>
ntpdate is a bit of a blunt instrument - it can only adjust the time once a day, in one big correction. The ntp daemon ntpd is far more subtle. It calculates the drift of your system clock and continuously adjusts it, so there are no large corrections that could lead to inconsistent logs for instance. The cost is a little processing power and memory, but for a modern server this is negligible. 
</para>
<para>To set up ntpd: </para>
<screen>sudo apt-get install ntp-simple
</screen>
<para/>
</sect2>
<sect2 id="timeservers" status="complete">
<title>Changing Time Servers</title>
	<para>
In both cases above, your system will use Ubuntu's NTP server at 
<code>ntp.ubuntu.com</code>
 by default. This is OK, but you might want to use several servers to increase accuracy and resilience, and you may want to use time servers that are geographically closer to you. to do this for ntpdate, change the contents of 
<code>/etc/cron.daily/ntpdate</code>
 to: 
</para>
<screen>ntpdate ntp.ubuntu.com pool.ntp.org 
</screen>
	<para>
And for ntpd edit 
<code>/etc/ntp.conf</code>
 to include additional server lines: 
</para>
<screen>ntp.ubuntu.com
server pool.ntp.org
</screen>
	<para>
You may notice 
<code>pool.ntp.org</code>
 in the examples above. This is a really good idea which uses round-robin DNS to return an NTP server from a pool, spreading the load between several different servers. Even better, they have pools for different regions - for instance, if you are in New Zealand, so you could use  
<code>nz.pool.ntp.org</code>
 instead of 
<code>pool.ntp.org</code>
. Look at 
<ulink url="http://www.pool.ntp.org/">http://www.pool.ntp.org/</ulink>
 for more details. 
</para>
	<para>
You can also Google for NTP servers in your region, and add these to your configuration. To test that a server works, just type 
<code>sudo ntpdate ntp.server.name</code>
 and see what happens. 
</para>
<para/>
</sect2>
	<sect2 id="relatedpages" status="complete">
<title>Related Pages</title>
	<itemizedlist>
	<listitem>
	<para>
<ulink url="http://ntp.isc.org/bin/view/Support/WebHome">NTP Support</ulink>
</para>
</listitem>
	<listitem>
	<para>
<ulink url="http://www.ntp.org/ntpfaq/NTP-a-faq.htm">The NTP FAQ and HOWTO</ulink>
</para>
</listitem>
</itemizedlist>
<para/>
</sect2>
    </sect1>
	</chapter>

