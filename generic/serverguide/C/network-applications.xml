<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" 
	"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % globalent SYSTEM "../../../libs/global.ent">
%globalent;
<!ENTITY % genericent SYSTEM "../../libs/generic.ent">
%genericent;
<!ENTITY % cdo-C SYSTEM "../../../libs/cdo-C.ent">
%cdo-C;
<!ENTITY % gnome-menus-C SYSTEM "../../../ubuntu/libs/gnome-menus-C.ent">
%gnome-menus-C;
<!ENTITY % xinclude SYSTEM "../../../libs/xinclude.mod">
%xinclude;
<!ENTITY language "&EnglishAmerican;">
]>
<chapter id="networking" status="complete">
	<title>Networking</title>
  <para>Networks consist of two or more devices, such as computer systems, printers, and related
        equipment which are connected by either physical cabling wireless links for the
        purpose of sharing and distributing information among the connected devices. 
  </para>
  <para>This section of the Ubuntu Server Guide provides general and specific information pertaining
        to networking, including an overview of network concepts and detailed discussion of popular
        network protocols and server applications.
  </para>
	<sect1 id="network-configuration" status="complete">
		<title>Network Configuration</title>
          <para>
            Ubuntu ships with a number of graphical utilities to configure your network devices.
			This document is geared toward server administrators and will focus on managing your
			network on the command line.
          </para>
      <sect2 id="ethernet" status="complete">
        <title>Ethernet</title> 
          <para>
		  Most ethernet configuration is centralized in a single file,
		  <filename>/etc/network/interfaces</filename>.  If you have no ethernet devices, only
		  the loopback interface will appear in this file, and it will look something like
		  this:
		  <screen># This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback
address 127.0.0.1
netmask 255.0.0.0</screen>
		If you have only one ethernet device, eth0, and it gets its configuration from a DHCP server,
		and it should come up automatically at boot, only two additional lines are required:
		<screen>auto eth0
iface eth0 inet dhcp</screen>
		The first line specifies that the eth0 device should come up automatically when you boot.
		The second line means that interface (<quote>iface</quote>) eth0 should have an IPv4 address
		space (replace <quote>inet</quote> with <quote>inet6</quote> for an IPv6 device) and that
		it should get its configuration automatically from DHCP.  Assuming your network and DHCP
		server are properly configured, this machine's network should need no further configuration to
		operate properly.  The DHCP server will provide the default gateway (implemented via the
		<application>route</application> command), the device's IP address (implemented via the 
		<application>ifconfig</application> command), and and DNS servers used on the network
		(implemented in the <filename>/etc/resolv.conf</filename> file.)</para>
		<para>To configure your ethernet device with a static IP address and custom configuration,
		some more information will be required.  Suppose you want to assign the IP address
		192.168.0.2 to the device eth1, with the typical netmask of 255.255.255.0.  Your default
		gateway's IP address is 192.168.0.1.  You would enter something like this into
		<filename>/etc/network/interfaces</filename>:
		<screen>iface eth1 inet static
	address 192.168.0.2
	netmask 255.255.255.0
	gateway 192.168.0.1</screen>
		In this case, you will need to specify your DNS servers manually in
		<filename>/etc/resolv.conf</filename>, which should look something like this:
		<screen>search mydomain.com
nameserver 192.168.0.1
nameserver 4.2.2.2</screen>
		The <emphasis role="italics">search</emphasis> directive will append mydomain.com
		to hostname queries in an attempt to resolve names to your network.  For example,
		if your network's domain is mydomain.com and you try to ping the host
		<quote>mybox</quote>, the DNS query will be modified to <quote>mybox.mydomain.com</quote>
		for resolution.  The <emphasis role="italics">nameserver</emphasis> directives
		specifiy DNS servers to be used to resolve hostnames to IP addresses.  If you use
		your own nameserver, enter it here.  Otherwise, ask your Internet Service Provider
		for the primary and secondary DNS servers to use, and enter them into
		<filename>/etc/resolv.conf</filename> as shown above.</para>
		<para>Many more configurations are possible, including dialup PPP interfaces, IPv6
		networking, VPN devices, etc.  Refer to <application>man 5 interfaces</application>
		for more information and supported options.  Remember that
		<filename>/etc/network/interfaces</filename> is used by the 
		<application>ifup</application>/<application>ifdown</application> scripts as a
		higher level configuration scheme than may be used in some other Linux distributions,
		and that the traditional, lower level utilities such as <application>ifconfig</application>,
		<application>route</application>, and <application>dhclient</application> are still
		available to you for ad hoc configurations.
		</para>
      </sect2>
      <sect2 id="managing-dns-entries" status="complete">
          <title>Managing DNS Entries</title>
            <para>This section explains how to configure the nameserver
            to use when resolving IP address to hostnames and vice
            versa. It does not explain how to configure the system as a name
            server.
            </para>
            <para>
            To manage DNS entries, you can add, edit, or remove DNS names
            from the <filename>/etc/resolv.conf</filename> file. A <ulink
            url="../sample/resolv.conf">sample file</ulink> is given below:
            </para>
<programlisting>
search com
nameserver 204.11.126.131
nameserver 64.125.134.133
nameserver 64.125.134.132
nameserver 208.185.179.218
</programlisting>
            
            <para>
             The <application>search</application> key specifies the string
             which will be appended to an incomplete hostname. Here, we
             have mentioned it as <application>com</application>. So, when we
             run: <command>ping ubuntu</command> it would be interpreted
             as <command>ping ubuntu.com</command>.
            </para> 

            <para>
            The <application>nameserver</application> key specifies the
            nameserver IP address. It will be used to resolve the given
            IP address or hostname. This file can have multiple nameserver
            entries. The nameservers will be used by the network query
            in the same order.
            </para>

            <warning>
            <para>
            If the DNS server names are retrieved dynamically from DHCP
            or PPPOE (retrieved from your ISP), do not add nameserver
            entries in this file. It will be updated automatically.
           </para>
            </warning>

            <warning>
            <para>
            The changes you do in <filename>/etc/resolv.conf</filename>
            will be erased when you reboot your machine. If you want to
            make this change permanent, you should install
            <application>resolvconf</application> package and update the
            DNS information in
            <filename>/etc/resolvconf/resolv.conf.d/base</filename>
            file provided by that package.
           </para>
            </warning>
        </sect2>
        <sect2 id="managing-hosts" status="complete">
          <title>Managing Hosts</title>
            <para>
            To manage hosts, you can add, edit, or remove hosts from
            <filename>/etc/hosts</filename> file. The file contains IP
            addresses and their corresponding hostnames.  When your
            system tries to resolve a hostname to an IP address or
            determine the hostname for an IP address, it refers to the
            <filename>/etc/hosts</filename> file before using the name
            servers.  If the IP address is listed in the
            <filename>/etc/hosts</filename> file, the name servers are
            not used.  This behavior can be modified by editing <filename>
			/etc/nsswitch.conf</filename> at your peril.
            </para>

            <para>
            If your network contains computers whose IP
            addresses are not listed in DNS, it is recommended that you
            add them to the <filename>/etc/hosts</filename> file.
            </para>
        </sect2>
    </sect1>
	<sect1 id="tcpip" status="complete">
		<title>TCP/IP</title>
          <para>
            The Transmission Control Protocol and Internet Protocol (TCP/IP) is a standard 
			set of protocols developed in the late 1970s by the Defense Advanced Research 
			Projects Agency (DARPA) as a means of communication between different types of 
			computers and computer networks. TCP/IP is the driving force of the Internet, 
			and thus it is the most popular set of network protocols on Earth. 
          </para>
      <sect2 id="tcpip-introduction" status="complete">
        <title>TCP/IP Introduction</title> 
          <para>
            The two protocol components of TCP/IP deal with different aspects of computer networking.
            <emphasis>Internet Protocol</emphasis>, the "IP" of TCP/IP is a 
			connectionless protocol which deals only with network packet routing using the <emphasis 
			role="italics">IP datagram</emphasis> as the basic unit of networking information.  The 
			IP datagram consists of a header followed by a message.  The <emphasis>
			Transmission Control Protocol</emphasis> is the "TCP" of TCP/IP and enables network hosts 
			to establish connections which may be used to exchange data streams.  TCP also guarantees 
			that the data between connections is delivered and that it arrives at one network host in 
			the same order as sent from another network host.
          </para>
          </sect2>
        <sect2 id="tcpip-configuration" status="complete">
          <title>TCP/IP Configuration</title>
            <para>
            The TCP/IP protocol configuration consists of several elements which must be set by 
			editing the appropriate configuration files, or deploying solutions such as the Dynamic 
			Host Configuration Protocol (DHCP) server which in turn, can be configured to provide the 
			proper TCP/IP configuration settings to network clients automatically. These 
			configuration values must be set correctly in order to facilitate the proper network 
			operation of your Ubuntu system.
            </para>
            <para>
            The common configuration elements of TCP/IP and their purposes are as follows:
            <itemizedlist>
               <listitem>
                  <para>
                  <emphasis role="bold">IP address</emphasis> The IP address is a unique
                  identifying string expressed as four decimal numbers ranging from zero (0)
                  to two-hundred and fifty-five (255), separated by periods,
                  with each of the four numbers representing eight (8) bits of the address for a
                  total length of thirty-two (32) bits for the whole address. This format is called
                  <emphasis>dotted quad
                  notation</emphasis>.</para>
               </listitem>
               <listitem>
                  <para>
                  <emphasis role="bold">Netmask</emphasis> The Subnet Mask (or simply,
                  <emphasis>netmask</emphasis>) is a local bit mask, or set of flags
                  which separate the portions of an IP address significant to the network from the
                  bits significant to the <emphasis>subnetwork</emphasis>.  For example,
                  in a Class C network, the standard netmask is 255.255.255.0 which masks the first
                  three bytes of the IP address and allows the last byte of the IP address to
                  remain available for specifying hosts on the subnetwork.
                  </para>
               </listitem>
               <listitem>
                  <para>
                  <emphasis role="bold">Network Address</emphasis> The Network Address represents the
                  bytes comprising the network portion of an IP address.  For example, the host 12.128.1.2
                  in a Class A network would use 12.0.0.0 as the network address, which uses twelve (12)
                  to represent the first byte of the IP address, (the network part) and zeroes (0) 
                  in all of the remaining three bytes to represent the potential host values.  Network
                  hosts using the very common private and non-routable IP addresses such as 192.168.1.100
                  would in turn use a Network Address of 192.168.1.0, which specifies the first three
                  bytes of the Class C 192.168.1 network and a zero (0) for all the possible hosts on the
                  network.
                  </para>
               </listitem>
               <listitem>
                  <para>
                  <emphasis role="bold">Broadcast Address</emphasis> The Broadcast Address is an IP address
                  which allows network data to be sent simultaneously to all hosts on a given subnetwork rather
                  than specifying a particular network host.  The standard general broadcast address for IP networks is
                  255.255.255.255, but this broadcast address cannot be used to send a broadcast message to
                  every host on the Internet because routers block it.  A more appropriate broadcast address
                  is set to match a specific subnetwork.  For example, on the popular private Class C IP network,
                  192.168.1.0, the broadcast address should be configured as 192.168.1.255. Broadcast messages are
                  typically produced by network protocols such as the Address Resolution Protocol (ARP) and the 
                  Routing Information Protocol (RIP).             
                  </para>
               </listitem>
               <listitem>
                  <para>
                  <emphasis role="bold">Gateway Address</emphasis> A Gateway Address is the IP address through which
                  a particular network, or host on a network, may be reached.  If one network host wishes to communicate
                  with another network host, and that host is not located on the same network, then a 
                  <emphasis>gateway</emphasis> must be used. In many cases, the Gateway Address will be that
                  of a router on the same network, which will in turn pass traffic on to other networks or hosts, such as
                  Internet hosts.  The value of the Gateway Address setting must be correct, or your system will not be able
                  to reach any hosts beyond those on the same network.                  
                  </para>
               </listitem>
               <listitem>
                  <para>
                  <emphasis role="bold">Nameserver Address</emphasis> Nameserver Addresses represent the IP addresses of
                  Domain Name Service (DNS) systems, which resolve network hostnames into IP addresses.  There are three levels of
                  Nameserver Addresses, which may be specified in order of precedence: The 
                  <emphasis>Primary</emphasis>
                  Nameserver, the <emphasis>Secondary</emphasis> Nameserver, and the 
                  <emphasis>Tertiary</emphasis>
                  Nameserver. In order for your system to be able to resolve network hostnames into their
                  corresponding IP addresses, you must specify valid Nameserver Addresses which you are authorized to use
                  in your system's TCP/IP configuration.  In many cases these addresses can and will be provided by your
                  network service provider, but many free and publicly accessible Nameservers are available for use, such as
                  the Level3 (Verizon) servers with IP addresses from
                  4.2.2.1 to 4.2.2.6. </para>
                     <tip>
                        <para>
                        The IP address, Netmask, Network Address, Broadcast Address, and Gateway Address
                        are typically specified via the appropriate directives in the file  <filename>/etc/network/interfaces</filename>. The Nameserver Addresses are typically specified via  <emphasis>nameserver</emphasis> 
                        directives in the file <filename>/etc/resolv.conf</filename>. For more information, 
                        view the system manual page for <filename>interfaces</filename> or <filename>resolv.conf</filename> respectively, with the following commands typed at a terminal prompt:
                        </para>
                     </tip>
                    <para>
                    Access the system manual page for <filename>interfaces</filename> with the following command:
                    </para>
                    <para>
<screen>
<command>man interfaces</command>
</screen>
                    </para>
                    <para>
                    Access the system manual page for <filename>resolv.conf</filename> with the following command:
                    </para>
                    <para>
<screen><command>man resolv.conf</command></screen>
                    </para>
               </listitem>
            </itemizedlist>
            </para>
        </sect2>
        <sect2 id="ip-routing" status="complete">
          <title>IP Routing</title>
            <para>
              IP routing is a means of specifying and discovering paths in a TCP/IP network along which
              network data may be sent.  Routing uses a set of <emphasis>routing tables</emphasis>
              to direct the forwarding of network data packets from their source to the destination, often
              via many intermediary network nodes known as <emphasis>routers</emphasis>.
              IP Routing is the principal mode of path discovery on the Internet.  There are two primary forms of
              IP Routing: <emphasis>Static Routing</emphasis> and 
              <emphasis>Dynamic Routing.</emphasis>
            </para>
            <para>
            Static routing involves manually adding IP routes to the system's routing table, and this is usually
            done by manipulating the routing table with the <application>route</application> command. Static routing enjoys
            many advantages over dynamic routing, such as simplicity of implementation on smaller networks, 
            predictability (the routing table is always computed in advance, and thus the route is precisely the 
            same each time it used), and low overhead on other routers and network links due to the lack of a
            dynamic routing protocol.  However, static routing does present some disadvantages as well.  For example,
            static routing is limited to small networks and does not scale well.  Static routing also fails completely
            to adapt to network outages and failures along the route due to the fixed nature of the route. 
            </para>
            <para>
            Dynamic Routing depends on large networks with multiple possible IP routes from a source to a destination
            and makes use of special routing protocols, such as the Router Information Protocol (RIP), which handle
            the automatic adjustments in routing tables that make dynamic routing possible.  Dynamic routing
            has several advantages over static routing, such as superior scalability and the ability to adapt
            to failures and outages along network routes. Additionally, there is less manual configuration of the
            routing tables, since routers learn from one another about their existence and available routes. This trait
            also eliminates the possibility of introducing mistakes in the routing tables via human error.
            Dynamic routing is not perfect, however, and presents disadvantages such as heightened complexity and
            additional network overhead from router communications, which does not immediately benefit the end users,
            but still consumes network bandwidth.
            </para>
        </sect2>
        <sect2 id="tcp-and-udp" status="complete">
          <title>TCP and UDP</title>
            <para>
              TCP is a connection-based protocol, offering error correction and guaranteed delivery of
              data via what is known as <emphasis>flow control</emphasis>. Flow control
              determines when the flow of a data stream needs to be stopped, and previously sent data
              packets should to be re-sent due to problems such as <emphasis>collisions</emphasis>,
              for example, thus ensuring complete and accurate delivery of the data.  TCP is typically
              used in the exchange of important information such as database transactions. 
            </para>
            <para>
              The User Datagram Protocol (UDP), on the other hand, is a <emphasis>connectionless</emphasis>
              protocol which seldom deals with the transmission of important data because it lacks flow
              control or any other method to ensure reliable delivery of the data.  UDP is commonly used
              in such applications as audio and video streaming, where it is considerably faster than
              TCP due to the lack of error correction and flow control, and where the loss of a few packets
			  is not generally catastrophic.
            </para>
        </sect2>
        <sect2 id="icmp" status="complete">
          <title>ICMP</title>
            <para>
              The Internet Control Messaging Protocol (ICMP) is an extension to the Internet Protocol (IP) as defined
              in the Request For Comments (RFC) #792 and supports network packets containing control, error, and
              informational messages.  ICMP is used by such network applications as the <application>ping</application>
              utility, which can determine the availability of a network host or device.  Examples of some error messages
              returned by ICMP which are useful to both network hosts and devices such as routers, include 
              <emphasis>Destination Unreachable</emphasis> and <emphasis>Time Exceeded</emphasis>.
            </para>
        </sect2>
        <sect2 id="daemons" status="complete">
          <title>Daemons</title>
            <para>
              Daemons are special system applications which typically execute continuously in the background and
              await requests for the functions they provide from other applications.  Many daemons are network-centric; that is,
              a large number of daemons executing in the background on an Ubuntu system may provide network-related functionality.
              Some examples of such network daemons include the <emphasis>Hyper Text Transport Protocol Daemon</emphasis> 
              (httpd), which provides web server functionality; the <emphasis>Secure SHell Daemon</emphasis> (sshd), which
              provides secure remote login shell and file transfer capabilities; and the <emphasis>Internet Message Access 
              Protocol Daemon</emphasis> (imapd), which provides E-Mail services.
            </para>
        </sect2>
    </sect1>
	<sect1 id="firewall-configuration" status="review">
		<title>Firewall Configuration</title>
          <para>
             The Linux kernel includes the <emphasis>Netfilter</emphasis> subsystem,
			 which is used to manipulate or decide the fate of network traffic headed into or through
			 your server.  All modern Linux firewall solutions use this system for packet filtering.
          </para>
        <sect2 id="firewall-introduction" status="review">
          <title>Firewall Introduction</title>
            <para>
              The kernel's packet filtering system would be of little use to administrators without
			  a userspace interface to manage it.  This is the purpose of iptables.  When a packet
			  reaches your server, it will be handed off to the Netfilter subsystem for acceptance,
			  manipulation, or rejection based on the rules supplied to it from userspace via
			  iptables.  Thus, iptables is all you need to manage your firewall if you're familiar
			  with it, but many frontends are available to simplify the task.
            </para>
        </sect2>
        <sect2 id="ip-masquerading" status="review">
          <title>IP Masquerading</title>
            <para>
              The purpose of IP Masquerading is to allow machines with private, non-routable IP
			  addresses on your network to access the Internet through the machine doing the
			  masquerading.  Traffic from your private network destined for the Internet must be
			  manipulated for replies to be routable back to the machine that made the request.
			  To do this, the kernel must modify the <emphasis>source</emphasis>
			  IP address of each packet so that replies will be routed back to it, rather than
			  to the private IP address that made the request, which is impossible over the 
			  Internet.  Linux uses <emphasis>Connection Tracking</emphasis>
			  (conntrack) to keep track of which connections belong to which machines and reroute
			  each return packet accordingly.  Traffic leaving your private network is thus
			  &quot;masqueraded&quot; as having originated from your Ubuntu gateway machine.
			  This process is referred to in Microsoft documentation as Internet
			  Connection Sharing.
            </para>
			<para>
              This can be accomplished with a single iptables rule, which may differ slightly
			  based on your network configuration:
			  <screen>sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/16 -o ppp0 -j MASQUERADE</screen>
			  The above command assumes that your private address space is 192.168.0.0/16 and
			  that your Internet-facing device is ppp0.  The syntax is broken down as follows:
			  <itemizedlist>
				  <listitem><para> -t nat -- the rule is to go into the nat table</para></listitem>
				  <listitem><para> -A POSTROUTING -- the rule is to be appended (-A) to the POSTROUTING 
				  chain</para></listitem>
				  <listitem><para> -s 192.168.0.0/16 -- the rule applies to traffic originating from the
				  specified address space</para></listitem>
				  <listitem><para> -o ppp0 -- the rule applies to traffic scheduled to be routed through
				  the specified network device</para></listitem>
				  <listitem><para> -j MASQUERADE -- traffic matching this rule is to &quot;jump&quot;
				  (-j) to the MASQUERADE target to be manipulated as described above</para></listitem>
			  </itemizedlist>
			</para>
			<para>
              Each chain in the filter table (the default table, and where most or all packet
			  filtering occurs) has a default <emphasis>policy</emphasis> of
			  ACCEPT, but if you are creating a firewall in addition to a gateway device, you
			  may have set the policies to DROP or REJECT, in which case your masqueraded
			  traffic needs to be allowed through the FORWARD chain for the above rule to work:
			  <screen>sudo iptables -A FORWARD -s 192.168.0.0/16 -o ppp0 -j ACCEPT
sudo iptables -A FORWARD -d 192.168.0.0/16 -m state --state ESTABLISHED,RELATED -i ppp0 -j ACCEPT</screen>
			  The above commands will allow all connections from your local network to the
			  Internet and all traffic related to those connections to return to the machine
			  that initiated them.
			</para>
        </sect2>
        <sect2 id="firewall-tools" status="review">
          <title>Tools</title>
            <para>
              There are many tools available to help you construct a complete firewall without
			  intimate knowledge of iptables.  For the GUI-inclined, 
			  <application>Firestarter</application> is quite popular and easy to use, and
			  <application>fwbuilder</application> is very powerful and will look familiar 
			  to an administrator who has used a commercial firewall utility such as Checkpoint 
			  FireWall-1.  If you prefer a command-line tool with plain-text configuration files, 
			  <application>Shorewall</application> is a very powerful solution to help you 
			  configure an advanced firewall for any network.  If your network is relatively 
			  simple, or if you don't have a network, <application>ipkungfu</application> should 
			  give you a working firewall &quot;out of the box&quot; with zero configuration, 
			  and will allow you to easily set up a more advanced firewall by editing simple, 
			  well-documented configuration files.  Another interesting tool is 
			  <application>fireflier</application>, which is designed to be a desktop firewall 
			  application.  It is made up of a server (fireflier-server) and your choice of GUI 
			  clients (GTK or QT), and behaves like many popular interactive firewall 
			  applications for Windows.
            </para>
        </sect2>
        <sect2 id="firewall-logs" status="review">
          <title>Logs</title>
            <para>
              Firewall logs are essential for recognizing attacks, troubleshooting your
			  firewall rules, and noticing unusual activity on your network.  You must include
			  logging rules in your firewall for them to be generated, though, and logging
			  rules must come before any applicable terminating rule (a rule with a target
			  that decides the fate of the packet, such as ACCEPT, DROP, or REJECT).  For
			  example:
			  <screen>sudo iptables -A INPUT -m state --state NEW -p tcp --dport 80 -j LOG --log-prefix "NEW_HTTP_CONN: "</screen>
			  A request on port 80 from the local machine, then, would generate a log in dmesg
			  that looks like this:
			</para>
			<para>
			  <programlisting>[4304885.870000] NEW_HTTP_CONN: IN=lo OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=58288 DF PROTO=TCP SPT=53981 DPT=80 WINDOW=32767 RES=0x00 SYN URGP=0</programlisting>
			</para>
			<para>
              The above log will also appear in <filename>/var/log/messages</filename>,
			  <filename>/var/log/syslog</filename>, and <filename>/var/log/kern.log</filename>.
			  This behavior can be modified by editing <filename>/etc/syslog.conf</filename>
			  appropriately or by installing and configuring <application>ulogd</application>
			  and using the ULOG target instead of LOG.  The <application>ulogd</application>
			  daemon is a userspace server that listens for logging instructions from the kernel
			  specifically for firewalls, and can log to any file you like, or even to a
			  <application>PostgreSQL</application> or <application>MySQL</application>
			  database.  Making sense of your firewall logs can be simplified by using a log
			  analyzing tool such as <application>fwanalog</application>, <application>
			  fwlogwatch</application>, or <application>lire</application>.
            </para>
        </sect2>
    </sect1>
	<sect1 id="openssh-server" status="complete">
		<title>OpenSSH Server</title>
      <sect2 id="openssh-introduction">
        <title>Introduction</title> 
           <para>
            This section of the &ubuntu; &sg-title; introduces a powerful collection of tools
            for the remote control of networked computers and transfer of data between networked 
            computers, called <emphasis>OpenSSH</emphasis>. You will also learn
            about some of the configuration settings possible with the OpenSSH server application and
            how to change them on your Ubuntu system. 
          </para>
          <para>
            OpenSSH is a freely available version of the Secure Shell (SSH) protocol family of 
            tools for remotely controlling a computer or transferring files between computers.
            Traditional tools used to accomplish these functions, such as <application>telnet</application>
            or <application>rcp</application>, are insecure and transmit the user's password in
            cleartext when used. OpenSSH provides a server daemon and client tools to facilitate
            secure, encrypted remote control and file transfer operations, effectively replacing
            the legacy tools.
          </para>
          <para>
            The OpenSSH server component, <application>sshd</application>, listens continuously for
            client connections from any of the client tools. When a connection request occurs,
            <application>sshd</application> sets up the correct connection depending on the type
            of client tool connecting. For example, if the remote computer is connecting with the
            <application>ssh</application> client application, the OpenSSH server sets up a remote
            control session after authentication. If a remote user connects to an OpenSSH server with
            <application>scp</application>, the OpenSSH server daemon initiates a secure copy of files
            between the server and client after authentication. OpenSSH can use many authentication
            methods, including plain password, public key, and <application>Kerberos</application> tickets.
            </para>
          </sect2>
        <sect2 id="openssh-installation">
        <title>Installation</title>
        <para>
        Installation of the OpenSSH client and server applications is simple. To install the OpenSSH client applications on your Ubuntu system, use this command at a terminal prompt:
        </para>
           <para>
<screen>
<command>sudo apt-get install openssh-client</command>
</screen>
           </para>
        <para>
        To install the OpenSSH server application, and related support files, use this command at a terminal prompt:
        </para>
           <para>
<screen>
<command>sudo apt-get install openssh-server</command>
</screen>
           </para>
        </sect2>
        <sect2 id="openssh-configuration">
          <title>Configuration</title>
            <para>
              You may configure the default behavior of the OpenSSH server application, <application>sshd</application>, by editing the file <filename>/etc/ssh/sshd_config</filename>. For information about the configuration directives used in this file, you may
              view the appropriate manual page with the following command, issued at a terminal prompt:
            </para>
               <para>
<screen>
<command>man sshd_config</command>
</screen>
               </para>
            <para>
            There are many directives in the <application>sshd</application> configuration file controlling such things as communications
            settings and authentication modes. The following are examples of configuration directives that can be changed by editing the <filename>/etc/ssh/ssh_config</filename> file.
            </para>
            <tip>
               <para>Prior to editing the configuration file, you should make a copy of the original file and protect it 
               from writing so you will have the original settings as a reference and to reuse as necessary.
               </para>
               <para>Copy the <filename>/etc/ssh/sshd_config</filename> file and protect it from writing with the following commands, issued at a terminal prompt:
               </para>
	    </tip>
               <para>
<screen>
<command>sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.original</command>
<command>sudo chmod a-w /etc/ssh/sshd_config.original</command>
</screen>
               </para> 
            <para>
            The following are examples of configuration directives you may change:
            </para>
           <itemizedlist>
               <listitem>
               <para>
               To set your OpenSSH to listen on TCP port 2222 instead of the default TCP port 22, change
               the Port directive as such:
               </para>
               <para>
               Port 2222
               </para>
               </listitem>
	<listitem>
            <para>
            To have <application>sshd</application> allow public key-based login credentials, simply add or modify the line:
            </para>
               <para>
               PubkeyAuthentication yes
               </para>
            <para>
            in the <filename>/etc/ssh/sshd_config</filename> file, or if already present, ensure the line is not commented out.
            </para>
            </listitem>
            <listitem>
             <para>
             To make your OpenSSH server display the contents of the <filename>/etc/issue.net</filename> file as a pre-login
             banner, simply add or modify the line:
             </para>
               <para>
               Banner  /etc/issue.net
               </para>
               <para>
               in the <filename>/etc/ssh/sshd_config</filename> file.
               </para>
             </listitem>
             </itemizedlist>
	    <para>
            After making changes to the <filename>/etc/ssh/sshd_config</filename> file, save the file, and restart the <application>sshd</application> 
            server application to effect the changes using the following command at a terminal prompt:
            </para>
               <para>
<screen>
<command>sudo /etc/init.d/ssh restart</command>
</screen>
               </para>
		<warning>
                           <para>
                           Many other configuration directives for <application>sshd</application> are available for changing the server application's
                           behavior to fit your needs. Be advised, however, if your only method of access to a server is <application>ssh</application>,
                           and you make a mistake in configuring <application>sshd</application> via the <filename>/etc/ssh/sshd_config</filename> file, you may find you
                           are locked out of the server upon restarting it, or that the <application>sshd</application> server refuses to start due
                           to an incorrect configuration directive, so be extra careful when editing this file on a remote server.
                           </para>
                        </warning>
        </sect2>
   <sect2 id="openssh-references" status="complete">
      <title>References</title>
      <para>
      <ulink url="http://www.openssh.org/">OpenSSH Website</ulink>
      </para>
      <para>
      <ulink url="https://wiki.ubuntu.com/AdvancedOpenSSH">Advanced OpenSSH Wiki Page</ulink>
      </para>
   </sect2>
     </sect1>
	<sect1 id="ftp-server" status="complete">
        <title>FTP Server</title> 
            <para>File Transfer Protocol (FTP) is a TCP protocol for uploading and downloading
                files between computers. FTP works on a client/server model. The server component is
                called an <emphasis>FTP daemon</emphasis>. It continuously listens for FTP requests
                from remote clients. When a request is received, it manages the login and sets up
                the connection. For the duration of the session it executes any of commands sent by
                the FTP client.</para>
            <para>Access to an FTP server can be managed in two ways:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>Anonymous</para>
                </listitem>
                <listitem>
                    <para>Authenticated</para>
                </listitem>
            </itemizedlist>
            <para>In the Anonymous mode, remote clients can access the FTP server by using the
                default user account called &apos;anonymous&quot; or &quot;ftp&quot; and
                sending an email address as the password. In the Authenticated mode a user must
                have an account and a password. User access to the FTP server directories and files is
                dependent on the permissions defined for the account used at login. As a general
                rule, the FTP daemon will hide the root directory of the FTP server and change it to
                the FTP Home directory. This hides the rest of the file system from remote
            sessions.</para>
            <sect2 id="vsftpd-ftp-server-installation" status="complete">
                <title>vsftpd - FTP Server Installation</title>
                    <para>vsftpd is an FTP daemon available in
                    Ubuntu. It is easy to install, set up, and
                    maintain.  To install <application>vsftpd</application> you
                can run the following command:
                <screen> <command>sudo apt-get install vsftpd</command> </screen>
                </para>

                </sect2>
            <sect2 id="vsftpd-ftp-server-configuration" status="complete">
                <title>vsftpd - FTP Server Configuration</title>
                <para>
                You can edit the vsftpd configuration file,
                <filename>/etc/vsftpd.conf</filename>, to
                change the default settings.

                By default only anonymous FTP is
                allowed. If you wish to disable this option, you
                should change the following line:
<programlisting>
anonymous_enable=YES
</programlisting>
                to
<programlisting>
anonymous_enable=NO
</programlisting>
                By default, local system users are not allowed to
                login to FTP server. To change this setting, you
                should uncomment the following line:
<programlisting>
#local_enable=YES
</programlisting>
                By default, users are allowed to download files
                from FTP server. They are not allowed to upload
                files to FTP server. To change this setting, you
                should uncomment the following line:
<programlisting>
#write_enable=YES
</programlisting>
                Similarly, by default, the anonymous users are not
                allowed to upload files to FTP server. To change
                this setting, you should uncomment the following
                line:
<programlisting>
#anon_upload_enable=YES
</programlisting>
                The configuration file consists of many
                configuration parameters. The information about
                each parameter is available in the configuration
                file. Alternatively, you can refer to the man
                page, <command>man 5 vsftpd.conf</command> for
                details of each parameter. 
                </para>
                <para> 
                Once you configure <application>vsftpd</application> you
                can start the daemon. You can run following command to
                run the <application>vsftpd</application> daemon:
                  <screen> <command>sudo /etc/init.d/vsftpd start</command> </screen>
                </para>
				<note><para>
				Please note that the defaults in the configuration file are
				set as they are for security reasons.  Each of the above
				changes makes the system a little less secure, so make them
				only if you need them.
				</para></note>
                </sect2>
    </sect1>
	<sect1 id="network-file-system" status="complete">
		<title>Network File System (NFS)</title>
          <para>
          NFS allows a system to share directories and files with others
          over a network. By using NFS, users and programs can access
          files on remote systems almost as if they were local files.
          </para>

          <para>
          Some of the most notable benefits that NFS can provide are:
          </para>

          <itemizedlist>
          <listitem>
      <para>Local workstations use less disk space because commonly used data
can be stored on a single machine and still remain accessible to others
over the network.</para>
          </listitem>
          <listitem>
      <para>There is no need for users to have separate home directories on
every network machine. Home directories could be set up on the NFS
server and made available throughout the network.</para>
          </listitem>
          <listitem>

      <para>Storage devices such as floppy disks, CDROM drives, and USB
Thumb drives can be used by other machines on the network. This may
reduce the number of removable media drives throughout the
network.</para>
          </listitem>
          </itemizedlist>

      <sect2 id="nfs-installation" status="complete">
        <title>Installation</title>
      
          <para>
          At a terminal prompt enter the following command to install the NFS
          Server:
          </para>
          <para>
<screen>
<command>sudo apt-get install nfs-kernel-server</command>
</screen>
          </para>
      </sect2>
      <sect2 id="nfs-configuration" status="complete">
        <title>Configuration</title>
          <para>
          You can configure the directories to be exported by adding them to
          the <filename>/etc/exports</filename> file. For example:
          </para>
          <para>
<screen>
/ubuntu  *(ro,sync,no_root_squash)
/home    *(rw,sync,no_root_squash)
</screen>
          </para>

          <para>
          You can replace * with one of the hostname formats. Make the
          hostname declaration as specific as possible so unwanted
          systems cannot access the NFS mount.
          </para>

          <para>
          To start the NFS server, you can run the following command at a terminal prompt:
          </para>
          <para>
<screen>
<command>sudo /etc/init.d/nfs-kernel-server start</command>
</screen>
          </para>
      </sect2>
      <sect2 id="nfs-client-configuration" status="complete">
        <title>NFS Client Configuration</title>
          <para>
          Use the <application>mount</application> command to mount a shared NFS directory from
          another machine, by typing a command line similar to the following at a terminal prompt:
          </para>
          <para>
<screen>
<command>sudo mount example.hostname.com:/ubuntu /local/ubuntu</command>
</screen>
</para>
      <warning>
      <para>
      The mount point directory <filename>/local/ubuntu</filename> must
      exist. There should be no files or subdirectories in the
      <filename>/local/ubuntu</filename> directory.
      </para>
      </warning>

      <para>
       An alternate way to mount an NFS share from another machine is to
       add a line to the <filename>/etc/fstab</filename> file. The line must state the
       hostname of the NFS server, the directory on the server being
       exported, and the directory on the local machine where the NFS
       share is to be mounted.
      </para>

      <para>
      The general syntax for the line in <filename>/etc/fstab</filename>
      file is as follows:
      </para>
      
      <para>
<programlisting>
example.hostname.com:/ubuntu /local/ubuntu nfs rsize=8192,wsize=8192,timeo=14,intr
</programlisting>
      </para>
      </sect2>
      <sect2 id="nfs-references" status="complete">
        <title>References</title>
				<para><ulink url="http://nfs.sourceforge.net/">Linux NFS faq</ulink></para>
      </sect2>
    </sect1>
	<sect1 id="dhcp" status="complete">
		<title>Dynamic Host Configuration Protocol (DHCP)</title>
            <para>The Dynamic Host Configuration Protocol (DHCP) is a network service that enables host
                computers to be automatically assigned settings from a server as opposed to
                manually configuring each network host. Computers configured to be DHCP clients have
                no control over the settings they receive from the DHCP server, and the configuration
                is transparent to the computer's user.</para>
            <para>The most common settings provided by a DHCP server to DHCP clients include:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>IP-Address and Netmask</para>
                </listitem>
                <listitem>
                    <para>DNS</para>
                </listitem>
                <listitem>
                    <para>WINS</para>
                </listitem>
            </itemizedlist>
            <para>However, a DHCP server can also supply configuration properties such as:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>Host Name</para>
                </listitem>
                <listitem>
                    <para>Domain Name</para>
                </listitem>
                <listitem>
                    <para>Default Gateway</para>
                </listitem>
                <listitem>
                    <para>Time Server</para>
                </listitem>
                <listitem>
                    <para>Print Server</para>
                </listitem>
            </itemizedlist>
            <para>The advantage of using DHCP is that changes to the network, for example a change
                in the address of the DNS server, need only be changed at the DHCP server, and all
                network hosts will be reconfigured the next time their DHCP clients poll the
                DHCP server. As an added advantage, it is also easier to integrate new computers into
                the network, as there is no need to check for the availability of an IP address.
                Conflicts in IP address allocation are also reduced.</para>
            <para>A DHCP server can provide configuration settings using two methods:</para>
            <variablelist>
                <varlistentry>
                    <term>MAC Address</term>
                    <listitem>
                        <para>This method entails using DHCP to identify the unique hardware address
                            of each network card connected to the network and then continually
                            supplying a constant configuration each time the DHCP client makes a
                            request to the DHCP server using that network device.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Address Pool</term>
                    <listitem>
                        <para>This method entails defining a pool (sometimes also called a range or
                            scope) of IP addresses from which DHCP clients are supplied their
                            configuration properties dynamically and on a fist come first serve
                            basis. When a DHCP client is no longer on the network for a specified
                            period, the configuration is expired and released back to the address
                            pool for use by other DHCP Clients.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>Ubuntu is shipped with both DHCP server and client. The server is
                    <application>dhcpd</application> (dynamic host configuration protocol daemon).
                The client provided with Ubuntu is
                <application>dhclient</application> and should be
                installed on all computers required to be automatically configured. Both programs
                are easy to install and configure and will be automatically started at system boot.</para>
      <sect2 id="dhcp-installation" status="complete">
        <title>Installation</title>
          <para>At a terminal prompt, enter the following command to install
                  <application>dhcpd</application>:</para>
          <para>
<screen>
<command>sudo apt-get install dhcpd</command>
</screen>
          </para>
          <para>You will see the following output, which explains what to do next:</para>
          <screen>
Please note that if you are installing the DHCP server for the first
time you need to configure. Please stop (/etc/init.d/dhcp
stop) the DHCP server daemon, edit /etc/dhcpd.conf to suit your needs
and particular configuration, and restart the DHCP server daemon
(/etc/init.d/dhcp start).

You also need to edit /etc/default/dhcp to specify the interfaces dhcpd
should listen to. By default it listens to eth0.

NOTE: dhcpd's messages are being sent to syslog. Look there for
diagnostics messages.

Starting DHCP server: dhcpd failed to start - check syslog for diagnostics.  </screen>
      </sect2>
      <sect2 id="dhcp-configuration" status="complete">
        <title>Configuration</title>
            <para>The error message the installation ends with might be a little confusing, but the
                following steps will help you configure the service:</para>
            <para>Most commonly, what you want to do is assign an IP address randomly. This can be
                done with settings as follows:</para>
            <screen>
# Sample /etc/dhcpd.conf
# (add your comments here) 
default-lease-time 600;
max-lease-time 7200;
option subnet-mask 255.255.255.0;
option broadcast-address 192.168.1.255;
option routers 192.168.1.254;
option domain-name-servers 192.168.1.1, 192.168.1.2;
option domain-name "mydomain.org";

subnet 192.168.1.0 netmask 255.255.255.0 {
range 192.168.1.10 192.168.1.100;
range 192.168.1.150 192.168.1.200;
} </screen>
            <para>This will result in the DHCP server giving a client an IP address from the range
                192.168.1.10-192.168.1.100 or 192.168.1.150-192.168.1.200. It will lease an IP
                address for 600 seconds if the client doesn't ask for a specific time frame. Otherwise
                the maximum (allowed) lease will be 7200 seconds. The server will also "advise" the
                client that it should use 255.255.255.0 as its subnet mask, 192.168.1.255 as its
                broadcast address, 192.168.1.254 as the router/gateway and 192.168.1.1 and
                192.168.1.2 as its DNS servers. </para>
            <para>If you need to specify a WINS server for your Windows clients, you will need to
                include the netbios-name-servers option, e.g.</para>
            <screen>
option netbios-name-servers 192.168.1.1; </screen>
            <para>Dhcpd configuration settings are taken from the DHCP mini-HOWTO, which can be found
                    <ulink url="http://www.tldp.org/HOWTO/DHCP/index.html">here</ulink>. </para>
      </sect2>
      <sect2 id="dhcp-references" status="complete">
        <title>References</title>
          <para>
            <ulink url="http://www.dhcp-handbook.com/dhcp_faq.html">DHCP FAQ</ulink>
          </para>
      </sect2>
    </sect1>
	<sect1 id="dns" status="complete">
		<title>Domain Name Service (DNS)</title>
            <para>Domain Name Service (DNS) is an Internet service that maps IP addresses and fully
                qualified domain names (FQDN) to one another. In this way, DNS alleviates the need to
                remember IP addresses. Computers that run DNS are called
                <emphasis>name
                servers</emphasis>. Ubuntu ships with <application>BIND</application> (Berkley
                Internet Naming Daemon), the most common program used for maintaining a name
                server on GNU/Linux.</para>
            <!-- things to do: IPv6-->
      <sect2 id="dns-installation" status="complete">
        <title>Installation</title>
          <para>At a terminal prompt, enter the following command to install
                  <application>dns</application>:</para>
          <para>
<screen>
<command>sudo apt-get install bind</command>
</screen>
          </para>
      </sect2>
      <sect2 id="dns-configuration" status="complete">
        <title>Configuration</title>
          <para>
          The DNS configuration files are stored in the
          <filename>/etc/bind</filename> directory. The
          primary configuration file is
         <filename>/etc/bind/named.conf</filename>. The content
          of the default configuration file is shown below:
          </para>

          <para>
<programlisting>
// This is the primary configuration file for the BIND DNS server named.
//
// Please read /usr/share/doc/bind/README.Debian for information on the 
// structure of BIND configuration files in Debian for BIND versions 8.2.1 
// and later, *BEFORE* you customize this configuration file.
//

include "/etc/bind/named.conf.options";

// reduce log verbosity on issues outside our control
logging {
	category lame-servers { null; };
	category cname { null; };
};

// prime the server with knowledge of the root servers
zone "." {
        type hint;
        file "/etc/bind/db.root";
};

// be authoritative for the localhost forward and reverse zones, and for
// broadcast zones as per RFC 1912

zone "localhost" {
        type master;
        file "/etc/bind/db.local";
};

zone "127.in-addr.arpa" {
        type master;
        file "/etc/bind/db.127";
};

zone "0.in-addr.arpa" {
        type master;
        file "/etc/bind/db.0";
};

zone "255.in-addr.arpa" {
        type master;
        file "/etc/bind/db.255";
};

// add local zone definitions here
include "/etc/bind/named.conf.local";
</programlisting>
          </para>

          <para>
          The <application>include</application> line specifies the
          filename which contains the DNS options. The
          <application>directory</application> line in the options file tells
          DNS where to look for files. All files BIND uses will be
          relative to this directory.
          </para>

          <para>
          The file named <filename>/etc/bind/db.root</filename> 
          describes the root name servers in the world. The servers
          change over time and must be maintained now and then.
          </para>

          <para>
          The <application>zone</application> section defines a master
          server, and it is stored in a file mentioned against file tag.
          Every zone file contains 3 resource records (RRs): an SOA RR, an
          NS RR and a PTR RR. SOA is short of Start of Authority. The
          "@" is a special notation meaning the origin. NS is the Name
          Server RR. PTR is Domain Name Pointer.  To start the DNS server,
          run the following command from a terminal prompt: 
           </para>
           <para>
<screen>
<command>sudo /etc/init.d/bind start</command>
</screen>
           </para>
          <para>You can refer to the
          documentation mentioned in the references section for details.
          </para>
      </sect2>
      <sect2 id="dns-references" status="complete">
        <title>References</title>
          <para>
            <ulink url="http://www.tldp.org/HOWTO/DNS-HOWTO.html">DNS HOWTO</ulink>
          </para>
      </sect2>
    </sect1>
	<sect1 id="cups" status="complete">
		<title>CUPS - Print Server</title>
          <para>
            The primary mechanism for Ubuntu printing and print services is the 
			<emphasis role="bold">Common UNIX Printing System</emphasis> (CUPS). 
			This printing system is a freely available, portable printing layer 
			which has become the new standard for printing in most GNU/Linux 
			distributions.
          </para>
          <para>
          CUPS manages print jobs and queues and provides network printing using 
		  the standard Internet Printing Protocol (IPP), while offering support 
		  for a very large range of printers, from dot-matrix to laser and many 
		  in between.  CUPS also supports PostScript Printer Description (PPD) and 
		  auto-detection of network printers, and features a simple web-based 
		  configuration and administration tool. 
          </para>
      <sect2 id="cups-installation" status="complete">
        <title>Installation</title>
          <para>
            To install CUPS on your Ubuntu computer, simply use <application>sudo</application> with the <application>apt-get</application> command and give the packages to install as the first parameter. A complete CUPS install has many package dependencies, but they may all be specified on the same command line.  Enter the following at a terminal prompt to install CUPS:
          </para>
          <para>
<screen>
<command>sudo apt-get install cupsys cupsys-client</command>
</screen>
          </para>
          <para>
          Upon authenticating with your user password, the packages should be downloaded
		  and installed without error. Upon the conclusion of installation, the CUPS server 
		  will be started automatically. For troubleshooting purposes, you can access CUPS 
		  server errors via the error log file at: <filename>/var/log/cups/error_log</filename>.
		  If the error log does not show enough information to troubleshoot any problems you
		  encounter, the verbosity of the CUPS log can be increased by changing the <emphasis
		  role="bold">LogLevel</emphasis> directive in the configuration file (discussed below)
		  to "debug" or even "debug2", which logs everything, from the default of "info".  If 
		  you make this change, remember to change it back once you've solved your problem, to 
		  prevent the log file from becoming overly large.
          </para>
      </sect2>
      <sect2 id="cups-configuration" status="complete">
        <title>Configuration</title>
          <para>
            The Common UNIX Printing System server's behavior is configured through the 
			directives contained in the file <filename>/etc/cups/cupsd.conf</filename>.  
			The CUPS configuration file follows the same syntax as the primary configuration 
			file for the Apache HTTP server, so users familiar with editing Apache's 
			configuration file should feel at ease when editing the CUPS configuration 
			file. Some examples of settings you may wish to change initially will be 
			presented here.
          </para>
          <tip>
               <para>Prior to editing the configuration file, you should make a copy of 
			   the original file and protect it from writing, so you will have the original 
			   settings as a reference, and to reuse as necessary.
               </para>
               <para>Copy the <filename>/etc/cups/cupsd.conf</filename> file and protect it 
			   from writing with the following commands, issued at a terminal prompt:
               </para>
               </tip>
               <para>
<screen>
<command>sudo cp /etc/cups/cupsd.conf /etc/cups/cupsd.conf.original</command>
<command>sudo chmod a-w /etc/cups/cupsd.conf.original</command>
</screen>
               </para>
          <itemizedlist>
                <listitem>
                <para>
                <emphasis role="bold">ServerAdmin</emphasis>: To configure the email 
				address of the designated administrator of the CUPS server, simply 
				edit the <filename>/etc/cups/cupsd.conf</filename> configuration file 
				with your preferred text editor, and modify the <emphasis 
				role="italics">ServerAdmin</emphasis> line accordingly.  For example, 
				if you are the Administrator for the CUPS server, and your e-mail 
				address is 'bjoy@somebigco.com', then you would modify the ServerAdmin 
				line to appear as such:
                </para>
                <para>
<screen>
ServerAdmin bjoy@somebigco.com
</screen>
                </para>
                </listitem>
          </itemizedlist>
                <para>
                For more examples of configuration directives in the CUPS server 
				configuration file, view the associated system manual page by entering the 
				following command at a terminal prompt:
               </para>
               <para>
<screen>
<command>man cupsd.conf</command>
</screen>
               </para>
                               <note>
                <para>
                Whenever you make changes to the <filename>/etc/cups/cupsd.conf</filename> configuration file, you'll need to restart the CUPS server by typing the following command at a terminal prompt:
                </para>
                </note>
                <para>
<screen>
<command>sudo /etc/init.d/cupsys restart</command>
</screen>
                </para>
	<para>Some other configuration for the CUPS server is done in the file <filename>/etc/cups/cups.d/ports.conf</filename>:</para>
          <itemizedlist>
                <listitem>
                <para>
                <emphasis role="bold">Listen</emphasis>: By default on Ubuntu, the CUPS 
				server installation listens only on the loopback interface at IP address 
				<emphasis>127.0.0.1</emphasis>. In order to instruct the 
				CUPS server to listen on an actual network adapter's IP address, you must 
				specify either a hostname, the IP address, or optionally, an IP 
				address/port pairing via the addition of a Listen directive.  For example, 
				if your CUPS server resides on a local network at the IP address <emphasis 
				role="italics">192.168.10.250</emphasis> and you'd like to make it 
				accessible to the other systems on this subnetwork, you would edit the 
				<filename>/etc/cups/cups.d/ports.conf</filename> and add a Listen 
				directive, as such:
                </para>
                <para>
<screen>
Listen 127.0.0.1:631           # existing loopback Listen
Listen /var/run/cups/cups.sock # existing socket Listen
Listen 192.168.10.250:631      # Listen on the LAN interface, Port 631 (IPP)
</screen>
                </para>
                <para>
                In the example above, you may comment out or remove the reference to the 
				Loopback address (127.0.0.1) if you do not wish <application>cupsd
				</application> to listen on that interface, but would rather have it only 
				listen on the Ethernet interfaces of the Local Area Network (LAN). To enable 
				listening for all network interfaces for which a certain hostname is bound, 
				including the Loopback, you could create a Listen entry for the hostname 
				<emphasis>socrates</emphasis> as such:
                </para>
                <para>
<screen>
Listen socrates:631  # Listen on all interfaces for the hostname 'socrates'
</screen>
                </para> 
				<para>or by omitting the Listen directive and using <emphasis>Port</emphasis> instead, as in:</para>
<para>
<screen>
Port 631  # Listen on port 631 on all interfaces
</screen>
</para>
                </listitem>
	</itemizedlist>

      </sect2>
      <sect2 id="cups-references" status="complete">
        <title>References</title>
        <para>
        <ulink url="http://www.cups.org/">CUPS Website</ulink>
        </para>
        </sect2>
    </sect1>
	<sect1 id="httpd" status="complete">
		<title>HTTPD - Apache2 Web Server</title>
      <para>Apache is the most commonly used Web Server on GNU/Linux systems. Web Servers are used
          to serve Web Pages requested by client computers. Clients typically request and view
          Web Pages using Web Browser applications such as <application>Firefox</application>,
              <application>Opera</application>, or <application>Mozilla</application>.</para>
      <para>Users enter a Uniform Resource Locator (URL) to point to a Web server by means of
          its Fully Qualified Domain Name (FQDN) and a path to the required resource. For example, to view the home page of
          the <ulink url="&ubuntu-web;">Ubuntu Web site</ulink> a user will enter only the FQDN. To request specific information about 
              <ulink url="&ubuntu-paidsupport;">paid
              support</ulink>, a user will enter the FQDN followed by a path.</para>
      <para>The most common protocol used to transfer Web pages is the Hyper Text Transfer
          Protocol (HTTP). Protocols such as Hyper Text Transfer Protocol over Secure Sockets Layer (HTTPS), and
          File Transfer Protocol (FTP), a protocol for uploading and downloading files, are also
          supported.</para>
      <para>Apache Web Servers are often used in combination with the <application>MySQL</application>
          database engine, the HyperText Preprocessor (<application>PHP</application>)
          scripting language, and other popular scripting languages such as
              <application>Python</application> and <application>Perl</application>. This
          configuration is termed LAMP (Linux, Apache, MySQL and Perl/Python/PHP) and forms a
          powerful and robust platform for the development and deployment of Web-based
          applications.</para>
<sect2 id="http-installation" status="complete">
  <title>Installation</title>
                  <para>The Apache2 web server is available in Ubuntu
                  Linux. To install Apache2:</para>
          <procedure><step>
                	  <para>At a terminal prompt enter the following command:
<screen>
<command>sudo apt-get install apache2</command>
</screen>
             		  </para>
			</step>
	    </procedure>
      </sect2>
      <sect2 id="http-configuration" status="complete">
        <title>Configuration</title>
          <para>
          Apache is configured by placing <emphasis>directives</emphasis> in plain text
          configuration files. The main configuration file is called 
		  <filename>apache2.conf</filename>. In addition, other configuration files may be added
          using the <emphasis>Include</emphasis> directive, and wildcards can be used to
          include many configuration files. Any directive may be placed
          in any of these configuration files. Changes to the main
          configuration files are only recognized by Apache2 when it is
          started or restarted.</para>

          <para>The server also reads a file containing mime document types;
          the filename is set by the <emphasis>TypesConfig</emphasis> directive, and is
          <filename>mime.types</filename> by default.</para>

          <para>The default Apache2 configuration file is <filename>/etc/apache2/apache2.conf</filename> .
          You can edit this file to configure the Apache2 server. You can
          configure the port number, document root, modules, log files, 
          virtual hosts, etc.
          </para>
        <sect3 id="http-basic-settings" status="complete">
          <title>Basic Settings</title>
            <para>
             This section explains Apache2 server essential configuration
             parameters. Refer to the <ulink
             url="http://httpd.apache.org/docs/2.0/">Apache2
             Documentation</ulink> for more details.</para>

             <itemizedlist>

             <listitem><para>
             Apache2 ships with a virtual-host-friendly default configuration.
			 That is, it is configured with a single default virtual host (using
			 the <emphasis>VirtualHost</emphasis> directive) which can modified or used as-is if you
			 have a single site, or used as a template for additional virtual hosts
			 if you have multiple sites.  If left alone, the default virtual host
			 will serve as your default site, or the site users will see if the
			 URL they enter does not match the <emphasis>ServerName</emphasis> directive of any of your 
			 custom sites.  To modify the default virtual host, edit the file
			 <filename>/etc/apache2/sites-available/default</filename>.  If you
			 wish to configure a new virtual host or site, copy that file into the
			 same directory with a name you choose.  For example,
			 <command>sudo cp /etc/apache2/sites-available/default /etc/apache2/sites-available/mynewsite</command>
			 Edit the new file to configure the new site using some of the directives
			 described below.
            </para></listitem>

             <listitem><para>
			 The <emphasis>ServerAdmin</emphasis> directive specifies the email address to be advertised
			 for the server's administrator.  The default value is webmaster@localhost.
			 This should be changed to an email address that is delivered to you (if you
			 are the server's administrator).  If your website has a problem, Apache2
			 will display an error message containing this email address to report the
			 problem to.  Find this directive in your site's configuration file in
			 /etc/apache2/sites-available.
			 </para></listitem>

             <listitem><para>
             The <emphasis>Listen</emphasis> directive specifies the port, and optionally the IP address,
			 Apache2 should listen on. If the IP address is not specified, Apache2
			 will listen on all IP addresses assigned to the machine it runs on.
			 The default value for the Listen directive is 80.  Change this to
			 127.0.0.1:80 to cause Apache2 to listen only on your loopback interface
			 so that it will not be available to the Internet, to (for example) 81
			 to change the port that it listens on, or leave it as is for normal
			 operation.  This directive can be found and changed in its own file,
			 <filename>/etc/apache2/ports.conf</filename>
             </para></listitem>

			 <listitem><para>
			 The <emphasis>ServerName</emphasis> directive is optional and specifies what FQDN your
			 site should answer to.  The default virtual host has no ServerName
			 directive specified, so it will respond to all requests that do not
			 match a ServerName directive in another virtual host.  If you have
			 just acquired the domain name ubunturocks.com and wish to host it on
			 your Ubuntu server, the value of the ServerName directive in your
			 virtual host configuration file should be ubunturocks.com.  Add this
			 directive to the new virtual host file you created earlier 
			 (<filename>/etc/apache2/sites-available/mynewsite</filename>).
			 
			 <tip><para>You may also want your site to respond to www.ubunturocks.com, since
				many users will assume the www prefix is appropriate.  Use the
				<emphasis>ServerAlias</emphasis> directive for this.  You may also use wildcards in the
				ServerAlias directive.  For example,
				<command>ServerAlias *.ubunturocks.com</command>
				will cause your site to respond to any domain request ending in
				.ubunturocks.com.
			 </para></tip>
			 </para></listitem>

			 <listitem><para>
			 The <emphasis>DocumentRoot</emphasis> directive specifies where Apache should look for the
			 files that make up the site.  The default value is /var/www.  No site
			 is configured there, but if you uncomment the <emphasis>RedirectMatch</emphasis> directive
			 in <filename>/etc/apache2/apache2.conf</filename> requests will be
			 redirected to /var/www/apache2-default where the default Apache2 site
			 awaits.  Change this value in your site's virtual host file, and
			 remember to create that directory if necessary!
			 </para></listitem>
            </itemizedlist>

			<tip><para>
			The /etc/apache2/sites-available directory is <emphasis role="bold">
			not</emphasis> parsed by Apache2.  Symbolic links in /etc/apache2/sites-enabled
			point to &quot;available&quot; sites.  Use the a2ensite (Apache2
			Enable Site) utility to create those symbolic links, like so:
			<command>sudo a2ensite mynewsite</command>
			where your site&apos;s configuration file is <filename>
			/etc/apache2/sites-available/mynewsite</filename>.  Similarly, the
			a2dissite utility should be used to disable sites.
			</para></tip>

        </sect3>
        <sect3 id="default-settings" status="complete">
          <title>Default Settings</title>
            <para>
             This section explains configuration of the Apache2 server
             default settings.  For example, if you add a virtual host, 
             the settings you configure for the virtual host take
             precedence for that virtual host. For a directive not
             defined within the virtual host settings, the default
             value is used.
            </para>

            <itemizedlist>
            <listitem>
            <para>
             The <emphasis>DirectoryIndex</emphasis> is the default page served by the
             server when a user requests an index of a directory by
             specifying a forward slash (/) at the end of the directory
             name.</para>

             <para>For example, when a user requests the page
             http://www.example.com/this_directory/, he or she will
             get either the DirectoryIndex page if it exists, a
             server-generated directory list if it does not and the
			 Indexes option is specified, or a Permission Denied page
			 if neither is true.  The server will try to
             find one of the files listed in the DirectoryIndex
             directive and will return the first one it finds. If it
             does not find any of these files and if Options Indexes is
             set for that directory, the server will generate and
             return a list, in HTML format, of the subdirectories and
             files in the directory.  The default value, found in
			 <filename>/etc/apache2/apache2.conf</filename> is &quot;
			 index.html index.cgi index.pl index.php index.xhtml&quot;.
			 Thus, if Apache2 finds a file in a requested directory
			 matching any of these names, the first will be displayed.
            </para>
            </listitem>

            <listitem>
            <para>
             The <emphasis>ErrorDocument</emphasis> directive allows you to specify a file
			 for Apache to use for specific error events.  For example,
			 if a user requests a resource that does not exist, a 404
			 error will occur, and per Apache2's default configuration,
			 the file <filename>/usr/share/apache2/error/HTTP_NOT_FOUND.html.var
			 </filename> will be displayed.  That file is not in the
			 server's DocumentRoot, but there is an Alias directive in
			 <filename>/etc/apache2/apache2.conf</filename> that redirects
			 requests to the /error directory to /usr/share/apache2/error/.
			 To see a list of the default ErrorDocument directives, use this
			 command:
			 <command>grep ErrorDocument /etc/apache2/apache2.conf</command>
            </para>
            </listitem>


            <listitem>
            <para>
             By default, the server writes the transfer log to the file
             /var/log/apache2/access.log. You can change this on a per-site
			 basis in your virtual host configuration files with the <emphasis>CustomLog</emphasis>
			 directive, or omit it to accept the default, specified in <filename>
			 /etc/apache2/apache2.conf</filename>.  You may also specify the file
			 to which errors are logged, via the <emphasis>ErrorLog</emphasis> directive, whose default
			 is <filename>/var/log/apache2/error.log</filename>.  These are kept
			 separate from the transfer logs to aid in troubleshooting problems
			 with your Apache2 server.  You may also specify the <emphasis>LogLevel</emphasis> (the
			 default value is &quot;warn&quot;) and the <emphasis>LogFormat</emphasis> (see <filename>
			 /etc/apache2/apache2.conf</filename> for the default value).
			 </para>
            </listitem>

            <listitem>
            <para>
            Some options are specified on a per-directory basis rather than per-server.
			Option is one of these directives.  A Directory stanza is enclosed in 
			XML-like tags, like so:
			<screen><command>&lt;Directory /var/www/mynewsite&gt;
				...
			&lt;/Directory&gt;</command></screen>
			The Options directive within a Directory stanza accepts one or more of the
			following values (among others), separated by spaces:
            </para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para><emphasis role="bold">ExecCGI</emphasis> - Allow
                    execution of CGI scripts. CGI scripts are not
                    executed if this option is not chosen.
					<tip><para>Most files should not be executed as CGI scripts.  This
					would be very dangerous.  CGI scripts should kept in a directory 
					separate from and outside your DocumentRoot, and only this
					directory should have the ExecCGI option set.  This is the default,
					and the default location for CGI scripts is /usr/lib/cgi-bin.
					</para></tip>
					</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Includes</emphasis> - Allow server-side includes.
					Server-side includes allow an HTML file to <emphasis>
					include</emphasis> other files.  This is not a common option.  See
					<ulink url="http://httpd.apache.org/docs/2.0/howto/ssi.html">the Apache2
					SSI Howto</ulink> for mor information.</para>
                </listitem>
                <listitem>
                    <para><emphasis
                    role="bold">IncludesNOEXEC</emphasis> - Allow server-side includes,
                    but disable the #exec and #include commands in CGI
                    scripts.</para>
                </listitem>
                <listitem>
                    <para>
                    <emphasis role="bold">Indexes</emphasis> - Display a formatted list of the
                    directory's contents, if no DirectoryIndex (such as index.html) exists in the 
					requested directory.
					<caution><para>For security reasons, this should usually not be set, and certainly
					should not be set on your DocumentRoot directory.  Enable this option carefully on
					a per-directory basis only if you are certain you want users to see the entire
					contents of the directory.</para></caution>
                    </para>
                </listitem>
                <listitem>
                    <para>
                    <emphasis role="bold">Multiview</emphasis> - Support content-negotiated multiviews;
                    this option is disabled by default for security reasons.  See the <ulink
					url="http://httpd.apache.org/docs/2.0/mod/mod_negotiation.html#multiviews">Apache2
					documentation on this option</ulink>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                    <emphasis
                    role="bold">SymLinksIfOwnerMatch</emphasis> - Only follow symbolic links
                    if the target file or directory has the same owner as the link.
                    </para>
                </listitem>
            </itemizedlist>

            </listitem>
            </itemizedlist>
        </sect3>
        <sect3 id="virtual-hosts-settings" status="complete">

          <title>Virtual Hosts Settings</title>
            <para>
			Virtual hosts allow you to run different servers for different IP addresses, different host 
			names, or different ports on the same machine. For example, you can run the website for 
			http://www.example.com and http://www.anotherexample.com on the same Web server using virtual 
			hosts. This option corresponds to the &lt;VirtualHost&gt; directive for the default virtual 
			host and IP-based virtual hosts. It corresponds to the &lt;NameVirtualHost&gt; directive for 
			a name-based virtual host.
			</para>

			<para>
			The directives set for a virtual host only apply to that particular virtual host. If a 
			directive is set server-wide and not defined within the virtual host settings, the default 
			setting is used. For example, you can define a Webmaster email address and not define 
			individual email addresses for each virtual host. 
    		</para>
 
 			<para>
			Set the DocumentRoot directive to the directory that contains the root document (such as 
			index.html) for the virtual host. The default DocumentRoot is <filename>/var/www</filename>.
			</para>

			<para>
			The ServerAdmin directive within the VirtualHost stanza is email the address used in the 
			footer of error pages if you choose to show a footer with an email address on the error pages.
			</para>

        </sect3>
        <sect3 id="server-settings" status="complete">
          <title>Server Settings</title>
            <para>
This section explains how to configure basic server settings.</para>
                    <para><emphasis role="bold">LockFile</emphasis> - The LockFile directive sets the path 
					to the lockfile used when the server is compiled with either USE_FCNTL_SERIALIZED_ACCEPT 
					or USE_FLOCK_SERIALIZED_ACCEPT. It must be stored on the local disk. It should be left 
					to the default value unless the logs directory is located on an NFS share. If this is 
					the case, the default value should be changed to a location on the local disk and to a 
					directory that is readable only by root. </para>

					<para><emphasis role="bold">PidFile</emphasis> - The PidFile directive sets the file in which the server 
					records its process ID (pid). This file should only be readable by root. In most cases, it should be left 
					to the default value.</para>

<para><emphasis role="bold">User</emphasis> - The User directive sets the userid used by the server to answer requests. This 
setting determines the server's access. Any files inaccessible to this user will also be inaccessible to your website's visitors. 
The default value for User is www-data.  </para>
            <warning>
            <para>
 Unless you know exactly what you are doing, do not set the User directive to root. Using root as the User will create large security holes for your Web server.  </para>
            </warning>
 <para>The Group directive is similar to the User directive. Group sets the group under which the server will answer requests. The default group is also www-data.</para>

        </sect3>
        <sect3 id="apache-modules" status="complete">
          <title>Apache Modules</title>
              <para>

              Apache is a modular server. This implies that only the most
              basic functionality is included in the core server. Extended
              features are available through modules which can be loaded
              into Apache. By default, a base set of modules is included in
              the server at compile-time. If the server is compiled to use
              dynamically loaded  modules, then modules can be compiled
              separately, and added at any time using the LoadModule
              directive. Otherwise, Apache must be recompiled to add or
              remove modules. Ubuntu compiles Apache2 to allow the dynamic
			  loading of modules.  Configuration directives may be conditionally
	      included on the presence of a particular module by enclosing
              them in an &lt;IfModule&gt; block.

              You can install additional Apache2 modules and use them
              with your Web server. You can install Apache2
              modules using the <application>apt-get</application>
              command. For example, to install the Apache2 module
              for MYSQL authentication, you can run the
                following command from a terminal prompt:</para>
                
                <para>
<screen>
<command>sudo apt-get install libapache2-mod-auth-mysql</command>
</screen>
                </para>
                <para>
                Once you install the module, the module will
                be available in the
                <filename>/etc/apache2/mods-available</filename> directory. You can use
              the <application>a2enmod</application> command to
              enable a module. You can use
              the <application>a2dismod</application> command to
              disable a module. Once you enable the module,
              the module will be available in the
              the <filename>/etc/apache2/mods-enabled</filename> directory.
              </para>
        </sect3>
      </sect2>
      <sect2 id="https-configuration" status="complete">
        <title>HTTPS Configuration</title>
          <para>
           The <application>mod_ssl</application> module adds
           an important feature to the Apache2 server - the ability to
           encrypt communications.  Thus, when your browser is
           communicating using SSL encryption, the
           https:// prefix is used at the beginning of the Uniform
           Resource Locator (URL) in the browser navigation bar.
          </para>

          <para>
          The <application>mod_ssl</application> module is available in
          <application>apache2-common</application> package. If you have
          installed this package, you can run the following command from a terminal prompt to
          enable the <application>mod_ssl</application> module:
          </para>

          <para>
<screen>
<command>sudo a2enmod ssl</command>
</screen>
          </para>
        <sect3 id="certificates-and-security" status="complete">
          <title>Certificates and Security</title>
            <para>
              To set up your secure server, use public key cryptography to
              create a public and private key pair. In most cases, you
              send your certificate request (including your public key),
              proof of your company's identity, and payment to a
              Certificate Authority (CA). The
              CA verifies the certificate request and your identity, and
              then sends back a certificate for your secure server. 
            </para>
             <para>
             Alternatively, you can create your own self-signed
             certificate. Note, however, that self-signed certificates
             should not be used in most production environments.
             Self-signed certificates are not automatically accepted by
             a user's browser.  Users are prompted by the browser to
             accept the certificate and create the secure connection.
             </para>

             <para>
              Once you have a self-signed certificate or a signed
              certificate from the CA of your choice, you need to
              install it on your secure server.
             </para>
        </sect3>
        <sect3 id="types-of-certificates" status="complete">
          <title>Types of Certificates</title>
            <para>
             You need a key and a certificate to operate your secure
             server, which means that you can either generate a
             self-signed certificate or purchase a CA-signed
             certificate.  A CA-signed certificate provides two important
              capabilities for your server:
            </para>

            <itemizedlist>
            <listitem>
            <para>
            Browsers (usually) automatically recognize the certificate
            and allow a secure connection to be made without prompting
            the user.
            </para>
            </listitem>
            <listitem>
            <para>
             When a CA issues a signed certificate, it is
             guaranteeing the identity of the organization that is
             providing the web pages to the browser.
            </para>
            </listitem>
            </itemizedlist>

            <para>
             Most Web browsers that support SSL have a list of CAs whose
             certificates they automatically accept. If a browser
             encounters a certificate whose authorizing CA is not in the
             list, the browser asks the user to either accept or decline
             the connection.
            </para>
            <para>
             You can generate a self-signed certificate for your secure server, but
            be aware that a self-signed certificate does not provide the same
            functionality as a CA-signed certificate. A self-signed certificate is
            not automatically recognized by most Web browsers, and a self-signed
            certificate does not provide any guarantee concerning the identity of
            the organization that is providing the website. A CA-signed certificate
            provides both of these important capabilities for a secure server. 
            The process of getting a certificate from a CA is fairly
            easy. A quick overview is as follows:
            </para>

            <orderedlist>
            <listitem>
               <para>Create a private and public encryption key pair.</para>
            </listitem>
            <listitem>
                 <para>Create a certificate request based on the public key. The
              certificate request contains information about your server and the
              company hosting it.</para>
            </listitem>
            <listitem>
                 <para>Send the certificate request, along with documents proving your
              identity, to a CA. We cannot tell you which certificate authority to
              choose. Your decision may be based on your past experiences, or on the
              experiences of your friends or colleagues, or purely on monetary
              factors.</para>

                    <para>Once you have decided upon a CA, you need to follow the
              instructions they provide on how to obtain a certificate
              from them.</para>
            </listitem>
            <listitem>
               <para>When the CA is satisfied that you are indeed who you claim to be,
            they send you a digital certificate.</para>
            </listitem>
            <listitem>
               <para>Install this certificate on your secure server, and begin handling
            secure transactions. </para>
            </listitem>
            </orderedlist>

            <para>Whether you are getting a certificate from a CA or generating your own
            self-signed certificate, the first step is to generate a key.
            </para>
        </sect3>
        <sect3 id="generating-a-csr" status="complete">
          <title>Generating a Certificate Signing Request (CSR)</title>
            <para>
            To generate the Certificate Signing Request (CSR), you should create your
            own key. You can run the following command from a terminal prompt to create the
            key:
            </para>

            <para>
<screen>
<command>openssl genrsa -des3 -out server.key 1024</command>
</screen>
            </para>
<programlisting>
Generating RSA private key, 1024 bit long modulus
.....................++++++
.................++++++
unable to write 'random state'
e is 65537 (0x10001)
Enter pass phrase for server.key:
</programlisting>

        <para>
        You can now enter your passphrase. For best security, it should
        at least contain eight characters. The minimum length when
		specifying -des3 is four characters. It should include numbers
        and/or punctuation and not be a word in a dictionary. Also
        remember that your passphrase is case-sensitive. 
        </para>

        <para>
        Re-type the passphrase to verify. Once you have re-typed it
        correctly, the server key is generated and stored in
        <filename>server.key</filename> file.
        </para>

        <warning>
        <para>
        You can also run your secure web server without a passphrase.
        This is convenient because you will not need to enter the
        passphrase every time you start your secure web server. But it
        is highly insecure and a compromise of the key means a
        compromise of the server as well.
        </para>
        </warning>

        <para>
        In any case, you can choose to run your secure web server without
        a passphrase by leaving out the -des3 switch in the generation
        phase or by issuing the following command at a terminal prompt:
        </para>

        <para>
<screen>
<command>openssl rsa -in server.key -out server.key.insecure</command>
</screen>
        </para>
        <para>
        Once you run the above command, the insecure key will be stored
        in the <filename>server.key.insecure</filename> file. You can use this
        file to generate the CSR without passphrase.
        </para>

        <para>
        To create the CSR, run the following command at a terminal prompt:
        </para>

        <para>
<screen>
<command>openssl req -new -key server.key -out server.csr</command>
</screen>
        </para>

        <para>It will prompt you enter the passphrase. If you enter the
        correct passphrase, it will prompt you to enter Company Name,
        Site Name, Email Id, etc. Once you enter all these details, your
        CSR will be created and it will be stored in the
        <filename>server.csr</filename> file. You can submit this CSR file
        to a CA for processing. The CAN will use this CSR file and issue
        the certificate. On the other hand, you can create self-signed
        certificate using this CSR.</para>

        </sect3>
        <sect3 id="creating-a-self-signed-certificate" status="complete">
          <title>Creating a Self-Signed Certificate</title>
            <para>
            To create the self-signed certificate, run the
            following command at a terminal prompt:
            </para>

            <para>
<screen>
<command>openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt</command>
</screen>
            </para>

            <para>The above command will prompt you to enter the
            passphrase. Once you enter the correct passphrase, your
            certificate will be created and it will be stored in the
            <filename>server.crt</filename> file.  </para>
        <warning>
        <para>
            If your secure server is to be used in a production environment, you
            probably need a CA-signed certificate.  It is not
            recommended to use self-signed certificate.
        </para>
        </warning>
        </sect3>
        <sect3 id="installing-the-certificate" status="complete">
          <title>Installing the Certificate</title>

            <para>You can install the key file
            <filename>server.key</filename> and certificate file
            <filename>server.crt</filename> or the certificate file issued
            by your CA by running following commands at a terminal prompt:
            </para>
            <para>
<screen>
<command>sudo cp server.crt /etc/ssl/certs</command>
<command>sudo cp server.key /etc/ssl/private</command>
</screen>
            </para>
            <para>
            You should add the following four lines to the
            <filename>/etc/apache2/sites-available/default</filename>
            file or the configuration file for your secure virtual
			host. You should place them in the <emphasis>VirtualHost</emphasis> section. They
            should be placed under the <emphasis>DocumentRoot</emphasis> line:
            </para>
<programlisting>
SSLEngine on

SSLOptions +FakeBasicAuth +ExportCertData +CompatEnvVars +StrictRequire

SSLCertificateFile /etc/ssl/certs/server.crt
SSLCertificateKeyFile /etc/ssl/private/server.key
</programlisting>
          
            <para>
            HTTPS should listen on port number 443. You should add the
            following line to the <filename>/etc/apache2/ports.conf</filename>
            file:
            </para>
<programlisting>
Listen 443
</programlisting>

        </sect3>
        <sect3 id="accessing-the-server" status="complete">
          <title>Accessing the Server</title>
            <para>
            Once you install your certificate, you should restart your
            web server. You can run the following command at a terminal prompt to
            restart your web server:
            </para>
            <para>
<screen><command>sudo /etc/init.d/apache2 restart</command> </screen>
            </para>
        <note><para>
        You should remember and enter the passphrase every time you
        start your secure web server.
        </para></note>

            <para>You will be prompted to enter the passphrase. Once you
            enter the correct passphrase, the secure web server will be
            started. You can access the secure server pages by typing
            https://your_hostname/url/ in your
            browser address bar.</para>

        </sect3>
      </sect2>
      <sect2 id="http-references" status="complete">
        <title>References</title>
          <para>
          <ulink url="http://httpd.apache.org/docs/2.0/">Apache2
          Documentation</ulink>
          </para>
          <para>
          <ulink url="http://www.modssl.org/docs/">Mod SSL
          Documentation</ulink>
          </para>
      </sect2>
    </sect1>

	<sect1 id="php5" status="complete">
		<title>PHP5 - Scripting Language</title>
      <para>PHP is a general-purpose scripting language suited for Web
      development. The PHP script can be embedded into HTML. This
      section explains how to install and configure PHP5 in Ubuntu
      System with Apache2 and MySQL.</para>
      <para> This section assumes you have installed and configured
      Apache 2 Web Server and MySQL Database Server. You can refer to
      Apache 2 section and MySQL sections in this document to install and
      configure Apache 2 and MySQL respectively.</para>

<sect2 id="php5-installation" status="complete">
  <title>Installation</title>
      <para>The PHP5 is available in Ubuntu Linux. </para>
      
      <procedure><step><para>
      To install PHP5 you
      can enter the following command in the terminal prompt:

<screen>
<command>sudo apt-get install php5-common php5 libapache2-mod-php5</command>
</screen>
</para>

      <para>You can run PHP5 scripts from command line. to run PHP5 scripts 
      from command line you should install
      <application>php5-cgi</application> package. To install
      <application>php5-cgi</application> you can enter the following
      command in the terminal prompt:
<screen>
<command>sudo apt-get install php5-cgi</command>
</screen>
</para>
      <para>To use <application>MySQL</application> with PHP5 you should install
      <application>php5-mysql</application> package. To install
      <application>php5-mysql</application> you can enter the following
      command in the terminal prompt:
<screen>
<command>sudo apt-get install php5-mysql</command>
</screen>
</para>
      <para>Similarly, to use <application>PostgreSQL</application> with PHP5 you should install
      <application>php5-pgsql</application> package. To install
      <application>php5-pgsql</application> you can enter the following
      command in the terminal prompt:
<screen>
<command>sudo apt-get install php5-pgsql</command>
</screen>
      </para>
			</step>
	    </procedure>
      </sect2>
      <sect2 id="php5-configuration" status="complete">
        <title>Configuration</title>
          <para>
          Once you install PHP5, you can run PHP5 scripts from your web
          browser. If you have installed
          <application>php5-cgi</application> package, you can run PHP5
          scripts from your command prompt.
          </para>

          <para>
          By default, the Apache 2 Web server is configured to run PHP5
          scripts. In other words, the PHP5 module is enabled in Apache2
          Web server automatically when you install the module. Please
          verify if the files
          <filename>/etc/apache2/mods-enabled/php5.conf</filename> and
          <filename>/etc/apache2/mods-enabled/php5.load</filename>
          exist. If they do not exists, you can enable the module using
          <command>a2enmod</command> command.
          </para>

          <para>Once you install PHP5 related packages and enabled PHP5
          Apache 2 module, you should restart Apache2 Web server to run
          PHP5 scripts. You can run the following command at a terminal
          prompt to restart your web server:
<screen><command>sudo /etc/init.d/apache2 restart</command> </screen>
          </para>
      </sect2>
      <sect2 id="php5-testing" status="complete">
        <title>Testing</title>
          <para>To verify your installation, you can run following PHP5
          phpinfo script:
          </para>
<programlisting>
&lt;?php
print_r (phpinfo());
?&gt;
</programlisting>
          <para>
          You can save the content in a file
          <filename>phpinfo.php</filename> and place it
          under <command>DocumentRoot</command> directory of Apache2 Web
          server. When point your browser to
          <filename>http://hostname/phpinfo.php</filename>, it would
          display values of various PHP5 configuration parameters.
      </para>
      </sect2>
    </sect1>
	
	<sect1 id="squid" status="complete">
		<title>Squid - Proxy Server</title>
          <para>
          Squid is a full-featured web proxy cache server application which provides proxy and cache services for Hyper Text
          Transport Protocol (HTTP), File Transfer Protocol (FTP), and other popular network protocols.  Squid can implement
          caching and proxying of Secure Sockets Layer (SSL) requests and caching of Domain Name Server (DNS) lookups, and perform
          transparent caching. Squid also supports a wide variety of caching protocols, such as Internet Cache Protocol, (ICP)
          the Hyper Text Caching Protocol, (HTCP) the Cache Array Routing Protocol (CARP), and the Web Cache Coordination 
          Protocol. (WCCP) 
          </para>
          <para>
          The Squid proxy cache server is an excellent solution to a variety of proxy and caching server needs, and scales from
          the branch office to enterprise level networks while providing extensive, granular access control mechanisms and
          monitoring of critical parameters via the Simple Network Management Protocol (SNMP).  When selecting a computer system
          for use as a dedicated Squid proxy, or caching servers, ensure your system is configured with a large amount of physical
          memory, as Squid maintains an in-memory cache for increased performance.
          </para>
      <sect2 id="squid-installation" status="complete">
        <title>Installation</title>
          <para>
            At a terminal prompt, enter the following command to install the Squid server:
          </para>
          <para>
<screen>
<command>sudo apt-get install squid squid-common</command>
</screen>
          </para>
      </sect2>
      <sect2 id="squid-configuration" status="complete">
        <title>Configuration</title>
          <para>
            Squid is configured by editing the directives contained within the <filename>/etc/squid/squid.conf</filename> configuration file.
            The following examples illustrate some of the directives which may be modified to affect the behavior of the Squid server.
            For more in-depth configuration of Squid, see the References section. 
          </para>
             <tip>
               <para>Prior to editing the configuration file, you should make a copy of the original file and protect it 
               from writing so you will have the original settings as a reference, and to re-use as necessary.
               </para>
               <para>Copy the <filename>/etc/squid/squid.conf</filename> file and protect it from writing with the following commands entered at a terminal prompt:
               </para>
	     </tip>
               <para>
<screen>
<command>sudo cp /etc/squid/squid.conf /etc/squid/squid.conf.original</command>
<command>sudo chmod a-w /etc/squid/squid.conf.original</command>
</screen>
               </para> 
	        <para>
           <itemizedlist>
               <listitem>
                  <para>
                  To set your Squid server to listen on TCP port 8888 instead of the default TCP port 3128, change
                  the http_port directive as such:
                  </para>
                  <para>
                  http_port 8888
                  </para>
               </listitem>
	            <listitem>
                  <para>
                  Change the visible_hostname directive in order to give the Squid server a specific hostname.  This hostname
                  does not necessarily need to be the computer's hostname. In this example it is set to <emphasis>weezie</emphasis>
                  </para>
                  <para>
                  visible_hostname weezie
                  </para>
               </listitem>
               <listitem>
                  <para>
                     Again, Using Squid's access control, you may configure use of Internet services proxied by Squid
                     to be available only users with certain Internet Protocol (IP) addresses.  For example, we willll illustrate access 
                     by users of the 192.168.42.0/24 subnetwork only:
                  </para>
                  <para>
                     Add the following to the <emphasis role="bold">bottom</emphasis> of the ACL section of your <filename>/etc/squid/squid.conf</filename> file:
                  </para>
                  <para>
                     acl fortytwo_network src 192.168.42.0/24
                  </para>
                  <para>
                     Then, add the following to the <emphasis role="bold">top</emphasis> of the http_access section of your
                     <filename>/etc/squid/squid.conf</filename> file:
                  </para>
                  <para>
                     http_access allow fortytwo_network
                  </para>
               </listitem>
               <listitem>
                  <para>
                     Using the excellent access control features of Squid, you may configure use of Internet services proxied by Squid
                     to be available only during normal business hours.  For example, we'll illustrate access by employees of a business
                     which is operating between 9:00AM and 5:00PM, Monday through Friday, and which uses the 10.1.42.0/42 subnetwork:
                  </para>
                  <para>
                     Add the following to the <emphasis role="bold">bottom</emphasis> of the ACL section of your <filename>/etc/squid/squid.conf</filename> file:
                  </para>
                  <para>
                     acl biz_network src 10.1.42.0/24
                     acl biz_hours time M T W T F 9:00-17:00
                  </para>
                  <para>
                     Then, add the following to the <emphasis role="bold">top</emphasis> of the http_access section of your
                     <filename>/etc/squid/squid.conf</filename> file:
                  </para>
                  <para>
                     http_access allow biz_network biz_hours
                  </para>
               </listitem>
          </itemizedlist>
          </para>
          <note>
	  <para>
          After making changes to the <filename>/etc/squid/squid.conf</filename> file, save the file and restart the <application>squid</application> 
          server application to effect the changes using the following command entered at a terminal prompt:
          </para>
          </note>
          <para>
<screen>
<command>sudo /etc/init.d/squid restart</command>
</screen>
          </para>
      </sect2>
      <sect2 id="squid-references" status="complete">
      <title>References</title>
      <para>
      <ulink url="http://www.squid-cache.org/">Squid Website</ulink>
      </para>
      </sect2>
    </sect1>
	<sect1 id="version-control-system" status="complete">
		<title>Version Control System</title>
          <para>
Version control is the art of managing changes to information. It has long been a critical tool for programmers, who typically spend their time making small changes to software and then undoing those changes the next day. But the usefulness of version control software extends far beyond the bounds of the software development world. Anywhere you can find people using computers to manage information that changes often, there is room for version control.</para>
<para>
          </para>
      <sect2 id="subversion" status="complete">
        <title>Subversion</title>
          <para>
Subversion is an open source version control system. Using Subversion, you can record the history of source files and documents. It manages files and directories over time. A tree of files is placed into a central repository. The repository is much like an ordinary file server, except that it remembers every change ever made to files and directories.
          </para>
        <sect3 id="subversion-installation" status="complete">
          <title>Installation</title>
            <para>
To access Subversion repository using the HTTP protocol, you must install and 
configure a web server. Apache2 is proven to work with Subversion. Please 
refer to the HTTP subsection in the Apache2 section to install and configure 
Apache2.  To access the Subversion repository using the HTTPS protocol, you 
must install and configure a digital certificate in your Apache 2 web server. 
Please refer to the HTTPS subsection in the Apache2 section to install and 
configure the digital certificate.
						</para>
						<para>
		To install Subversion, run the following command from a terminal prompt:
            </para>
	    <para>
<screen>
<command>sudo apt-get install subversion libapache2-svn</command>
</screen>
	    </para>

        </sect3>
        <sect3 id="subversion-configuration" status="complete">
          <title>Server Configuration</title>
            <para>
	This step assumes you have installed above mentioned packages on your system. This section explains how to create a Subversion repository and access the project.</para>
			<sect4 id="create-svn-repos" status="complete">
				<title>Create Subversion Repository</title>
<para>The Subversion repository can be created using the following command from a terminal prompt:</para>

        <para>
<screen>
<command>svnadmin create /path/to/repos/project</command>
</screen>
        </para>
			</sect4>

        </sect3>
        <sect3 id="access-methods" status="complete">
          <title>Access Methods</title>
<para>Subversion repositories can be accessed (checked out) through many 
different methods --on local disk, or through various network protocols. 
A repository location, however, is always a URL. The table describes how 
different URL schemas map to the available access methods.</para>
				<table><title>Access Methods</title>

					<tgroup cols="2">
						<colspec colname="1"/>
						<colspec colname="2"/>
						<thead>
							<row>
								<entry><para>Schema</para></entry>
								<entry><para>Access Method</para></entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry><para>file://</para></entry>
								<entry><para>direct repository access (on local disk)</para></entry>
							</row>
							<row>
								<entry><para>http://</para></entry>
								<entry><para>Access via WebDAV protocol to Subversion-aware Apache2 web server</para></entry>
							</row>
							<row>
								<entry><para>https://</para></entry>
								<entry><para>Same as http://, but with SSL encryption</para></entry>
							</row>
							<row>
								<entry><para>svn://</para></entry>
								<entry><para>Access via custom protocol to an svnserve server</para></entry>
							</row>
							<row>
								<entry><para>svn+ssh://</para></entry>
								<entry><para>Same as svn://, but through an SSH tunnel</para></entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<para>
In this section, we will see how to configure Subversion for all 
these access methods. Here, we cover the basics. For more advanced 
usage details, refer to the <ulink 
url="http://svnbook.red-bean.com/">svn book</ulink>.
				</para>
			<sect4 id="direct-repos-access" status="complete">
				<title>Direct repository access (file://)</title>
<para> This is the simplest of all access methods. It does not 
require any Subversion server process to be running. This access 
method is used to access Subversion from the same machine. The 
syntax of the command, entered at a terminal prompt, is as follows:</para>

        <para>
<screen>
<command>svn co file:///path/to/repos/project</command>
</screen>
        </para>
  <para>or</para>
	<para>
<screen>
<command>svn co file://localhost/path/to/repos/project</command>
</screen>
        </para>
	<note>
		<para>If you do not specify the hostname, there are three forward slashes (///) -- two for the protocol (file, in this case) plus the leading slash in the path. If you specify the hostname, you must use two forward slashes (//).</para>
	</note>
		<para>The repository permissions depend on filesystem permissions. If the user has read/write permission, he can checkout from and commit to the repository.</para>
			</sect4>
			<sect4 id="access-via-webdav" status="complete">
				<title>Access via WebDAV protocol (http://)</title>
<para> To access the Subversion repository via WebDAV protocol, you must configure your Apache 2 web server. You must add the following snippet in your <filename>/etc/apache2/apache2.conf</filename> file:</para>

	<programlisting> &lt;Location /svn&gt;
  DAV svn
  SVNPath /path/to/repos
  AuthType Basic
  AuthName "Your repository name"
  AuthUserFile /etc/subversion/passwd
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
  Require valid-user
  &lt;/LimitExcept&gt;
  &lt;/Location&gt; </programlisting>
  <para>Next, you must create the <filename>/etc/subversion/passwd</filename> 
  file. This file contains user authentication details. To add an entry, i.e. 
  to add a user, you can run the following command from a terminal prompt:</para>
	<para>
<screen>
<command>htpasswd2 /etc/subversion/passwd user_name</command>
</screen>
        </para>
	<para>This command will prompt you to enter the password. Once you enter the password, the user is added. Now, to access the repository you can run the following command:</para>
        <screen><command>svn co http://servername/svn</command></screen>
	<warning>
		<para>
			The password is transmitted as plain text. If you are worried about password snooping, you are advised to use SSL encryption. For details, please refer next section.
		</para>
	</warning>
			</sect4>
			<sect4 id="access-via-webdav-with-ssl" status="complete">
				<title>Access via WebDAV protocol with SSL encryption (https://)</title>
					<para> 
						Accessing Subversion repository via WebDAV protocol with SSL 
						encryption (https://) is similar to http:// except that you 
						must install and configure the digital certificate in your 
						Apache2 web server.
					</para>

					<para>
						You can install a digital certificate issued by a signing 
						authority like Verisign. Alternatively, you can install your 
						own self-signed certificate.
					</para>
					<para>
						This step assumes you have installed and configured a digital 
						certificate in your Apache 2 web server. Now, to access the 
						Subversion repository, please refer to the above section! 
						The access methods are exactly the same, except the protocol. 
						You must use https:// to access the Subversion repository.
					</para>

			</sect4>
			<sect4 id="access-via-custom-protocol" status="complete">
				<title>Access via custom protocol (svn://)</title>
					<para> 
					Once the Subversion repository is created, you can configure the 
					access control. You can edit the <filename>
					/path/to/repos/project/conf/svnserve.conf</filename> file to 
					configure the access control.  For example, to set up 
					authentication, you can uncomment the following lines in the 
					configuration file: </para>
					<programlisting># [general]
# password-db = passwd</programlisting>

					<para>
					After uncommenting the above lines, you can maintain the user 
					list in the passwd file. So, edit the file <filename>passwd
					</filename> in the same directory and add the new user. The 
					syntax is as follows:
					</para>
					<programlisting>username = password</programlisting>
					<para>
					For more details, please refer to the file.
					</para>

					<para>
					Now, to access Subversion via the svn:// custom protocol, either 
					from the same machine or a different machine, you can run 
					svnserver using svnserve command. The syntax is as follows:
					</para>
					<programlisting>$ svnserve -d --foreground -r /path/to/repos
# -d -- daemon mode
# --foreground -- run in foreground (useful for debugging)
# -r -- root of directory to serve

For more usage details, please refer to:
$ svnserve --help</programlisting>

					<para>Once you run this command, Subversion starts listening on default port (3690). To access the project repository, you must run the following command from a terminal prompt: </para>
					<para>
<screen>
<command>svn co svn://hostname/project project --username user_name</command>
</screen>
                                        </para>
					<para>Based on server configuration, it prompts for password. Once 
					you are authenticated, it checks out the code from Subversion 
					repository.  To synchronize the project repository with the local 
					copy, you can run the <command>update</command> sub-command. The 
					syntax of the command, entered at a terminal prompt, is as follows:
					</para>
					<para>
<screen>
<command>cd project_dir ; svn update</command>
</screen>
                                        </para>
					<para>For more details about using each Subversion sub-command, you 
					can refer to the manual. For example, to learn more about the co 
					(checkout) command, please run the following command from a 
					terminal prompt:</para>
                    <para><screen><command>svn co help</command></screen></para>

			</sect4>
			<sect4 id="access-via-custom-protocol-with-ssl" status="complete">
				<title>Access via custom protocol with SSL encryption (svn+ssh://)</title>
					<para> The configuration and server process is same as in the
					svn:// method. For details, please refer to the above section. 
					This step assumes you have followed the above step and started 
					the	Subversion server using <application>svnserve</application>  
					command.</para>

					<para>It is also assumed that the ssh server is running on that 
					machine and that it is allowing incoming connections. To confirm, 
					please try to login to that machine using ssh. If you can login, 
					everything is perfect. If you cannot login, please address it 
					before continuing further.</para>

					<para>The svn+ssh:// protocol is used to access the Subversion 
					repository using SSL encryption. The data transfer is encrypted 
					using this method. To access the project repository (for example 
					with a checkout), you must use the following command syntax: 
                                        </para>
                                        <para>
<screen>
<command>svn co svn+ssh://hostname/var/svn/repos/project</command>
</screen>
                                        </para>

					<note><para> You must use the full path (/path/to/repos/project) 
					to access the Subversion repository using this access method. 
					</para></note>
					<para>
					Based on server configuration, it prompts for password. You must 
					enter the password you use to login via ssh. Once you are 
					authenticated, it checks out the code from the Subversion 
					repository.
					</para>
			</sect4>
			</sect3>

      </sect2>
      <sect2 id="cvs-server" status="complete">
        <title>CVS Server</title> 
          <para>
          CVS is a version control system. You can use it to record the
          history of source files.
          </para>
        <sect3 id="cvs-installation" status="complete">
          <title>Installation</title>
            <para>
              At a terminal prompt, enter the following command to install
              <application>cvs</application>:

<screen>
<command>sudo apt-get install cvs</command>
</screen>

After you install <application>cvs</application>, you should install
<application>xinetd</application> to start/stop the cvs server. At the
prompt, enter the following command to install
<application>xinetd</application>:

<screen>
<command>sudo apt-get install xinetd</command>
</screen>
            </para>
        </sect3>
        <sect3 id="cvs-configuration" status="complete">
          <title>Configuration</title>
            <para>
            Once you install cvs, the repository will be automatically
            initialized. By default, the repository resides under the
            <application>/var/lib/cvs</application> directory. You can
            change this path by running following command:

<screen>
<command>cvs -d /your/new/cvs/repo init</command>
</screen>

Once the initial repository is set up, you can configure
<application>xinetd</application> to start the CVS server. 
You can copy the following lines to the <filename>
/etc/xinetd/cvspserver</filename> file.

<programlisting>
service cvspserver
{
     port = 2401
     socket_type = stream
     protocol = tcp
     user = root
     wait = no
     type = UNLISTED
     server = /usr/bin/cvs
     server_args = -f --allow-root /var/lib/cvs pserver
     disable = no
}
</programlisting>

<note>
<para>
Be sure to edit the repository if you have changed the default
repository (<application>/var/lib/cvs</application>) directory.
</para>
</note>

Once you have configured <application>xinetd</application> you 
can start the cvs server by running following command:

<screen>
<command>sudo /etc/init.d/xinetd start</command>
</screen>
            </para>
            <para>
            You can confirm that the CVS server is running by issuing 
			the following command:
            </para>

            <para>
<screen>
<command>sudo netstat -tap | grep cvs</command>
</screen>
            </para>

            <para>
            When you run this command, you should see the following line
            or something similar:
            </para>

<programlisting>
tcp        0      0 *:cvspserver            *:* LISTEN 
</programlisting>

        <para>
From here you can continue to add users, add new projects,
and manage the CVS server. 
        </para>
        <warning>
<para>
          CVS allows the user to add users independently of the
underlying OS installation. Probably the easiest way is to use the Linux
Users for CVS, although it has potential security issues. Please refer
to the CVS manual for details.
</para>
        </warning>

        </sect3>
        <sect3 id="cvs-add-projects" status="complete">
          <title>Add Projects</title>
            <para>
            This section explains how to add new project to the CVS 
			repository. Create the directory and add necessary document 
			and source files to the directory. Now, run the following 
			command to add this project to CVS repository:
<screen>
<command>cd your/project</command>
<command>cvs import -d :pserver:username@hostname.com:/var/lib/cvs -m "Importing my project to CVS repository" . new_project start</command>
</screen>

<tip>
<para>
You can use the CVSROOT environment variable to store the CVS root directory.
Once you export the CVSROOT environment variable, you can avoid using -d option to
above cvs command.
</para>
</tip>
The string <emphasis>new_project</emphasis> is a vendor
tag, and <emphasis>start</emphasis> is a release tag.
They serve no purpose in this context, but since CVS requires them, they
must be present.

<warning>
<para>
When you add a new project, the CVS user you use must have write access to the
CVS repository (<application>/var/lib/cvs</application>). By default, the
<application>src</application> group has write access to the CVS
repository. So, you can add the user to this group, and he can then add and
manage projects in the CVS repository.
</para>
</warning>
            </para>
        </sect3>
      </sect2>
      <sect2 id="version-control-ref" status="complete">
        <title>References</title> 
				<para><ulink url="http://subversion.tigris.org/">Subversion Home Page</ulink></para>
				<para><ulink url="http://svnbook.red-bean.com/">Subversion Book</ulink></para>
				<para><ulink
url="http://ximbiot.com/cvs/manual/cvs-1.11.21/cvs_toc.html">CVS Manual</ulink></para>
      </sect2>
    </sect1>
	<sect1 id="databases" status="complete">
		<title>Databases</title>
          <para>
            Ubuntu provides two Database servers. They are:
            <itemizedlist spacing="compact">
                <listitem>
                    <para><application><trademark>MySQL</trademark></application></para>
                </listitem>
                <listitem>
                    <para><application>PostgreSQL</application></para>
                </listitem>
            </itemizedlist>
            They are available in the main repository. This section
            explains how to install and configure these database
            servers.
          </para>
      <sect2 id="mysql" status="complete">
        <title>MySQL</title>
          <para>
          MySQL is a fast, multi-threaded, multi-user, and robust SQL
          database server. It is intended for mission-critical, 
		  heavy-load production systems as well as for embedding into 
		  mass-deployed software.
          </para>

        <sect3 id="mysql-installation" status="complete">
          <title>Installation</title>
            <para>
            To install MySQL, run the following command from a terminal prompt:
            </para>

            <para>
<screen>
<command>sudo apt-get install mysql-server mysql-client</command>
</screen>
            </para>

            <para>
            Once the installation is complete, the MySQL server should be
            started automatically. You can run the following command from a terminal prompt to
            check whether the MySQL server is running:
            </para>

            <para>
<screen>
<command>sudo netstat -tap | grep mysql</command>
</screen>
            </para>

            <para>
            When you run this command, you should see the following line
            or something similar:
            </para>

<programlisting>
tcp        0      0 localhost.localdomain:mysql           *:* LISTEN -
</programlisting>
	<para>If the server is not running correctly, you can type the following command to start it:</para>
            <para>
<screen>
<command>sudo /etc/init.d/mysql restart</command>
</screen>
        </para>

        </sect3>
        <sect3 id="mysql-configuration" status="complete">
          <title>Configuration</title>
            <para>
            By default, the administrator password is not set. Once you
            install MySQL, the first thing you must do is to configure
            the MySQL administrator password. To do this, run the following commands:
            </para>
            <para>
<screen>
<command>sudo mysqladmin -u root password newrootsqlpassword</command>
</screen>
            </para>
            <para>
<screen>
<command>sudo mysqladmin -p -u root -h localhost password newrootsqlpassword</command>
</screen>
            </para>

            <para>
            You can edit the <filename>/etc/mysql/my.cnf</filename> file to configure the basic
            settings -- log file, port number, etc. Refer to
            <filename>/etc/mysql/my.cnf</filename> file for more details.
            </para>
        </sect3>
      </sect2>
      <sect2 id="postgresql" status="complete">
        <title>PostgreSQL</title> 
          <para>
          PostgreSQL is an object-relational database system that has
          the features of traditional commercial database systems with
          enhancements to be found in next-generation DBMS systems.
          </para>
        <sect3 id="postgresql-installation" status="complete">
          <title>Installation</title>
            <para>
            To install PostgreSQL, run the following command in the
            command prompt:
            </para>

            <para>
<screen>
<command>sudo apt-get install postgresql</command>
</screen>
            </para>

            <para>
            Once the installation is complete, you should configure the
            PostgreSQL server based on your needs, although the default
            configuration is viable.</para>
            
        </sect3>
        <sect3 id="postgresql-configuration" status="complete">
          <title>Configuration</title>
            <para>By default, connection via TCP/IP is disabled.
            PostgreSQL supports multiple client authentication methods.
            By default, IDENT authentication method is used.  Please
            refer <ulink 
			url="http://www.postgresql.org/docs/8.1/static/admin.html">
			the PostgreSQL Administrator's Guide</ulink>.</para>
            
            <para>The following discussion assumes that you wish to enable 
			TCP/IP connections and use the MD5 method for client 
			authentication. PostgreSQL configuration files are stored in the
            <filename>/etc/postgresql/&lt;version&gt;/main</filename>
            directory. For example, if you install PostgreSQL 7.4, the
            configuration files are stored in the
            <filename>/etc/postgresql/7.4/main</filename> directory.
            </para>
            
            <tip>
            <para>
             To configure <application>ident</application>
             authentication, add entries to the <filename>/etc/postgresql/7.4/main/pg_ident.conf</filename>
             file.
            </para>
            </tip>

            <para>To enable TCP/IP connections, edit the file <filename>/etc/postgresql/7.4/main/postgresql.conf</filename></para>

            <para>Locate the line <emphasis>#tcpip_socket =
            false</emphasis> and change it to
            <emphasis>tcpip_socket =
            true</emphasis>. You may
            also edit all other parameters, if you know what you are doing! 
			For details, refer to the configuration file or to the PostgreSQL documentation.
            </para>

            <para>By default, the user credentials are not set for
            <emphasis>MD5</emphasis> client
            authentication. So, first it is necessary to configure the PostgreSQL server to use
            <emphasis>trust</emphasis> client
            authentication, connect to the database,
            configure the password, and revert the configuration back to use
            <emphasis>MD5</emphasis> client authentication.
            To enable <emphasis>trust</emphasis> client
            authentication, edit the file <filename>/etc/postgresql/7.4/main/pg_hba.conf</filename></para>

            <para>Comment out all the existing lines which use
            <emphasis>ident</emphasis> and
            <emphasis>MD5</emphasis>
            client authentication and add the following
            line:</para>
<programlisting>
local   all         postgres                          trust sameuser
</programlisting>

            <para>Then, run the following command to
            start the PostgreSQL server:
            </para>
            <para>
<screen>
<command>sudo /etc/init.d/postgresql start</command>
</screen>
            </para>
            <para>Once the PostgreSQL server is successfully started, run the following command at a terminal prompt to connect to the default
            PostgreSQL template database</para>

            <para>
<screen>
<command>psql -U postgres -d template1</command>
</screen>
            </para>
            <para>The above command connects to PostgreSQL
            database <emphasis>template1</emphasis> as user
            <emphasis>postgres</emphasis>. Once you connect to the PostgreSQL
            server, you will be at a SQL prompt. You can run the
            following SQL command at the <application>psql</application> prompt to configure the
            password for the user <emphasis
            role="italics">postgres</emphasis>.</para>

            <para>
<screen>
<command>template1=# ALTER USER postgres with encrypted password 'your_password';</command>
</screen>
            </para>
            <para>After configuring the password, edit the file
            <filename>/etc/postgresql/7.4/main/pg_hba.conf</filename> to use
            <emphasis>MD5</emphasis> authentication:</para>
            <para>Comment the recently added <emphasis
            role="italics">trust</emphasis> line and add the following
            line: </para>

<programlisting>
local   all         postgres                          md5 sameuser
</programlisting>
            <warning>
            <para>
             The above configuration is not complete by any means. Please
             refer <ulink url="http://www.postgresql.org/docs/8.1/static/admin.html">
			 the PostgreSQL Administrator's Guide</ulink> to configure more parameters.
            </para>
            </warning>
        </sect3>
      </sect2>
    </sect1>
	<sect1 id="email-services" status="complete">
		<title>Email Services</title>
          <para>
            The process of getting an email from one person to another over a network or
			the Internet involves many systems working together.  Each of these systems
			must be correctly configured for the process to work.  The sender uses a <emphasis>Mail
			User Agent</emphasis> (MUA), or email client, to send the message through one or more
			<emphasis>Mail Transfer Agents</emphasis> (MTA), the last of which will hand it off to a 				<emphasis>Mail Delivery Agent</emphasis> (MDA) for delivery to the 
			recipient's mailbox, from which it
			will be retrieved by the recipient's email client, usually via a POP3 or IMAP server.
          </para>
      <sect2 id="postfix" status="complete">
        <title>Postfix</title>
          <para>
            <application>Postfix</application> is the default Mail Transfer Agent (MTA) in Ubuntu. It
            attempts to be fast and easy to administer and secure. It is
            compatible with the MTA <application>sendmail</application>. This section explains how
            to install and configure <application>postfix</application>. It also explains how to
            set it up as an SMTP server using a secure connection (for sending emails securely).
          </para>
        <sect3 id="postfix-installation" status="complete">
          <title>Installation</title>
            <para>
            To install <application>postfix</application> with SMTP-AUTH and Transport Layer
            Security (TLS), run the following command:
<screen>
<command>sudo apt-get install postfix</command>
</screen>
		Simply press return when the installation process asks questions, the configuration will be done in greater detail in the next stage.
            </para>
        </sect3>
        <sect3 id="postfix-configuration" status="complete">
          <title>Basic Configuration</title>
            <para>
            To configure <application>postfix</application>, run the following command:
<screen>
<command>sudo dpkg-reconfigure postfix</command>
</screen>
            The user interface will be displayed. On each screen, select the following
            values:
            <itemizedlist spacing="compact">
            <listitem><para>Ok</para></listitem>
            <listitem><para>Internet Site</para></listitem>
            <listitem><para>NONE</para></listitem>
            <listitem><para>mail.example.com</para></listitem>
            <listitem><para>mail.example.com, localhost.localdomain, localhost</para></listitem>
            <listitem><para>No</para></listitem>
            <listitem><para>127.0.0.0/8</para></listitem>
            <listitem><para>Yes</para></listitem>
            <listitem><para>0</para></listitem>
            <listitem><para>+</para></listitem>
            <listitem><para>all</para></listitem>
            </itemizedlist>
            </para>
            <note>
            <para>
            Replace mail.example.com with your mail server hostname.
            </para>
            </note>
	 </sect3>
        <sect3 id="postfix-smtp-authentication" status="complete">
          <title>SMTP Authentication</title>
            <para>The next steps are to configure
            <application>postfix</application> to use SASL for SMTP
            AUTH. Rather than editing the configuration file directly, 
	     you can use the <command>postconf</command> command to configure
            all <application>postfix</application> parameters.  The
            configuration parameters will be stored in
            <filename>/etc/postfix/main.cf</filename> file. Later if you
            wish to re-configure a particular parameter, you can either
            run the command or change it manually in the file.</para>
	<procedure>
		<step><para>Configure Postfix to do SMTP AUTH using SASL (saslauthd):
<screen>
postconf -e 'smtpd_sasl_local_domain ='
postconf -e 'smtpd_sasl_auth_enable = yes'
postconf -e 'smtpd_sasl_security_options = noanonymous'
postconf -e 'broken_sasl_auth_clients = yes'
postconf -e 'smtpd_recipient_restrictions = permit_sasl_authenticated,permit_mynetworks,reject_unauth_destination'
postconf -e 'inet_interfaces = all'
</screen>
Open the <filename>/etc/postfix/sasl/smtpd.conf</filename> file and add
the following lines to end of the file:
<screen>
pwcheck_method: saslauthd
mech_list: plain login
</screen>
		</para>
		</step>
		<step><para>Next, configure the digital certificate 
            for TLS. When asked questions, follow the instructions and answer appropriately.
<screen>
openssl genrsa -des3 -rand /etc/hosts -out smtpd.key 1024
chmod 600 smtpd.key
openssl req -new -key smtpd.key -out smtpd.csr
openssl x509 -req -days 3650 -in smtpd.csr -signkey smtpd.key -out smtpd.crt
openssl rsa -in smtpd.key -out smtpd.key.unencrypted
mv -f smtpd.key.unencrypted smtpd.key
openssl req -new -x509 -extensions v3_ca -keyout cakey.pem -out cacert.pem -days 3650
sudo mv smtpd.key /etc/ssl/private/
sudo mv smtpd.crt /etc/ssl/certs/
sudo mv cakey.pem /etc/ssl/private/
sudo mv cacert.pem /etc/ssl/certs/
</screen>
		</para>
		<note><para>You can get the digital
            certificate from a certificate authority. Alternatively, you
            can create the certificate yourself. Refer to 
			<xref linkend="creating-a-self-signed-certificate" /> for more 
			details.</para></note>
		</step>
		<step><para>Configure Postfix to do TLS encryption for both incoming and outgoing mail:
<screen>
postconf -e 'smtpd_tls_auth_only = no'
postconf -e 'smtp_use_tls = yes'
postconf -e 'smtpd_use_tls = yes'
postconf -e 'smtp_tls_note_starttls_offer = yes'
postconf -e 'smtpd_tls_key_file = /etc/ssl/private/smtpd.key'
postconf -e 'smtpd_tls_cert_file = /etc/ssl/certs/smtpd.crt'
postconf -e 'smtpd_tls_CAfile = /etc/ssl/certs/cacert.pem'
postconf -e 'smtpd_tls_loglevel = 1'
postconf -e 'smtpd_tls_received_header = yes'
postconf -e 'smtpd_tls_session_cache_timeout = 3600s'
postconf -e 'tls_random_source = dev:/dev/urandom'
postconf -e 'myhostname = mail.example.com'
</screen>
		</para>
		</step>
		</procedure>
            <note>
            <para>
            After you run all the commands, the SMTP AUTH is configured
            with <application>postfix</application>. The self-signed
            cerficiate is created for TLS and it is configured with
            <application>postfix</application>.
            </para>
            </note>
            <para>
            Now, the file <filename>/etc/postfix/main.cf</filename>
            should look like <ulink url="../sample/postfix_configuration">this</ulink>.
		</para>
		<para>
            The postfix initial configuration is complete. Run
            the following command to start postfix daemon:
            <screen><command>sudo /etc/init.d/postfix start</command></screen>

            Now the <application>postfix</application> daemon is installed, configured and run
            successfully. <application>Postfix</application> supports SMTP AUTH as defined in
            <ulink
            url="ftp://ftp.isi.edu/in-notes/rfc2554.txt">RFC2554</ulink>.
            It is based on <ulink
            url="ftp://ftp.isi.edu/in-notes/rfc2222.txt">SASL</ulink>. However it is still necessary to set up SASL authentication before you can use SMTP.
            </para>
	</sect3>
	<sect3 id="sasl">
	  <title>Configuring SASL</title>
            <para>
            The
            <application>libsasl2</application>,
            <application>sasl2-bin</application> and
            <application>libsasl2-modules</application> are necessary to
            enable SMTP AUTH using SASL. You can install these applications if
            you have not installed them already.
<screen>
<command>sudo apt-get install libsasl2 sasl2-bin</command>
</screen>
	    </para>
	    <para>
		A few changes are necessary to make it work properly. Because <application>Postfix</application> runs chrooted in <filename>/var/spool/postfix</filename>, <application>SASL</application> needs to be configured to run in the false root (<filename>/var/run/saslauthd</filename> becomes <filename>/var/spool/postfix/var/run/saslauthd</filename>):
<screen>
<command>mkdir -p /var/spool/postfix/var/run/saslauthd</command>
<command>rm -rf /var/run/saslauthd</command>
</screen>
	    </para>
	    <para>
            To activate <application>saslauthd</application>, edit the file <filename>/etc/default/saslauthd</filename>, and change or add the START variable. In order to configure <application>saslauthd</application> to run in the false root, add the PWDIR, PIDFILE and PARAMS variables. Finally, configure the MECHANISMS variable to your liking. The file should look like this:

<programlisting>
# This needs to be uncommented before saslauthd will be run
# automatically
START=yes

PWDIR="/var/spool/postfix/var/run/saslauthd"
PARAMS="-m ${PWDIR}"
PIDFILE="${PWDIR}/saslauthd.pid"

# You must specify the authentication mechanisms you wish to use.
# This defaults to "pam" for PAM support, but may also include
# "shadow" or "sasldb", like this:
# MECHANISMS="pam shadow"

MECHANISMS="pam"
</programlisting>
            </para>
<note>
<para>
If you prefer, you can use <emphasis role="strong">shadow</emphasis>
instead of <emphasis role="strong">pam</emphasis>. This will use MD5
hashed password transfer and is perfectly secure. The username and
password needed to authenticate will be those of the users on the system
you are using on the server.
</para>
</note>
        <para>
Next, update the dpkg "state" of <filename>/var/spool/portfix/var/run/saslauthd</filename>. The saslauthd init script uses this setting to create the missing directory with the appropriate permissions and ownership:
<screen>
<command>dpkg-statoverride --force --update --add root sasl 755 /var/spool/postfix/var/run/saslauthd</command>
</screen>
        </para>
        </sect3>
        <sect3 id="postfix-testing" status="complete">
          <title>Testing</title>
            <para>
          SMTP AUTH configuration is complete. Now it is time to start
          and test the setup. You can run the following command to start
          the SASL daemon:
            <screen><command>sudo /etc/init.d/saslauthd start</command></screen>

          To see if SMTP-AUTH and TLS work properly, run the following
          command:
            <screen><command>telnet mail.example.com 25</command></screen>
          After you have established the connection to the postfix mail
          server, type:
            <screen>ehlo mail.example.com</screen>
          If you see the following lines among others, then everything
          is working perfectly. Type <command>quit</command> to exit.
<programlisting>
250-STARTTLS
250-AUTH LOGIN PLAIN
250-AUTH=LOGIN PLAIN
250 8BITMIME
</programlisting>
        </para>
        </sect3>
      </sect2>
      <sect2 id="exim4" status="complete">
        <title>Exim4</title>
          <para>
            <application>Exim4</application> is is another Message Transfer
            Agent (MTA) developed at the University of Cambridge for use
            on Unix systems connected to the internet. Exim can be
            installed in place of <application>sendmail</application>,
            although the configuration of
            <application>exim</application> is quite different to
            that of <application>sendmail</application>.
          </para>
        <sect3 id="exim4-installation" status="complete">
          <title>Installation</title>
            <para>
            To install <application>exim4</application>, run the following command:
<screen>
<command>sudo apt-get install exim4 exim4-base exim4-config</command>
</screen>
            </para>
        </sect3>
        <sect3 id="exim4-configuration" status="complete">
          <title>Configuration</title>
            <para>
            To configure <application>exim4</application>, run the following command:
<screen>
<command>sudo dpkg-reconfigure exim4-config</command>
</screen>
            The user interface will be displayed. The user interface
            lets you configure many parameters. For example, In
            <application>exim4</application> the configuration files are
            split among multiple files. If you wish to have them in one
            file you can configure accordingly in this user interface.
            </para>

            <para>
            All the parameters you configure in the user interface are
            stored in
            <filename>/etc/exim4/update-exim4.conf.conf</filename> file.
            If you wish to re-configure, either you re-run the
            configuration wizard or manually edit this file
            using your favourite editor. Once you configure, you can run
            the following command to generate the master configuration
            file:
<screen>
<command>sudo update-exim4.conf</command>
</screen>
            The master configuration file, is generated and
            it is stored in
            <filename>/var/lib/exim4/config.autogenerated</filename>. 
            
            <warning>
            <para>
            At any time, you should not edit the master configuration
            file,
            <filename>/var/lib/exim4/config.autogenerated</filename>
            manually. It is updated automatically every time you run
            <command>update-exim4.conf</command>
            </para>
            </warning>
            You can run
            the following command to start
            <application>exim4</application> daemon.
<screen>
<command>sudo /etc/init.d/exim4 start</command>
</screen>
            <emphasis role="strong">TODO:</emphasis> This section should
            cover configuring SMTP AUTH with exim4. 
            </para>
        </sect3>
      </sect2>
      <sect2 id="dovecot-server" status="complete">
        <title>Dovecot Server</title> 
          <para>
          <application>Dovecot</application> is a Mail Delivery Agent, written with security
          primarily in mind. It supports the major mailbox formats: mbox
          or Maildir. This section explain how to set it up as an imap or
          pop3 server.
          </para>
        <sect3 id="dovecot-installation" status="complete">
          <title>Installation</title>
            <para>
            To install <application>dovecot</application>, run the following command in the
            command prompt:
<screen>
<command>sudo apt-get install dovecot-common dovecot-imapd dovecot-pop3d</command>
</screen>
            </para>
        </sect3>
        <sect3 id="dovecot-configuration" status="complete">
          <title>Configuration</title>
            <para>
            To configure <application>dovecot</application>, you can edit the file
            <filename>/etc/dovecot/dovecot.conf</filename>. You can
            choose the protocol you use. It could be pop3, pop3s (pop3
            secure), imap and imaps (imap secure). A description of these protocols is beyond the scope of this guide. For further information, refer to the wikipedia articles on <ulink
            url="http://en.wikipedia.org/wiki/POP3">POP3</ulink> and
            <ulink
            url="http://en.wikipedia.org/wiki/Internet_Message_Access_Protocol">IMAP</ulink>.
            </para>

            <para>
            IMAPS and POP3S are more secure that the simple IMAP and
            POP3 because they use SSL encryption to connect. Once you
            have chosen the protocol, amend the following line in the file
            <filename>/etc/dovecot/dovecot.conf</filename>:
<programlisting>
protocols = pop3 pop3s imap imaps
</programlisting>

            It enables the protocols when <application>dovecot</application> is started. Next, add the following line in pop3 section in the file <filename>/etc/dovecot/dovecot.conf</filename>:
<programlisting>
pop3_uidl_format = %08Xu%08Xv
</programlisting>

            Next, choose the mailbox you use. <application>Dovecot</application> supports
            <emphasis role="strong">maildir</emphasis> and <emphasis
            role="strong">mbox</emphasis> formats. These are the most
            commonly used mailbox formats. They both have their own
            benefits and they are discussed on <ulink
            url="http://dovecot.org/doc/configuration.txt">the dovecot website</ulink>.
            </para>
            <para>
            Once you have chosen your mailbox type, edit the file
            <filename>/etc/dovecot/dovecot.conf</filename> and change
            the following line:
<programlisting>
default_mail_env = maildir:~/Maildir # (for maildir)
or
default_mail_env = mbox:~/mail:INBOX=/var/spool/mail/%u # (for mbox)
</programlisting>
            </para>
<note>
<para>
You should configure your Mail Transport Agent (MTA) to transfer the
incoming mail to this type of mailbox if it is different from the one
you have configured.
</para>
</note>
          <para>
          Once you have configured dovecot, start the <application>dovecot</application> daemon
          in order to test your setup:

          <screen><command>sudo /etc/init.d/dovecot start</command></screen>

          If you have enabled imap, or pop3, you can also try to log in
          with the commands <command>telnet localhost pop3</command> or
          <command>telnet localhost imap2</command>. If you see
          something like the following, the installation has been
          successful:
<programlisting>
bhuvan@rainbow:~$ telnet localhost pop3
Trying 127.0.0.1...
Connected to localhost.localdomain.
Escape character is '^]'.
+OK Dovecot ready.
</programlisting>
          </para>
        </sect3>
        <sect3 id="dovecot-ssl" status="complete">
          <title>Dovecot SSL Configuration</title>
            <para>
            To configure <application>dovecot</application> to use SSL, you can edit the file
            <filename>/etc/dovecot/dovecot.conf</filename> and amend
            following lines:
<programlisting>
ssl_cert_file = /etc/ssl/certs/dovecot.pem
ssl_key_file = /etc/ssl/private/dovecot.pem
ssl_disable = no
disable_plaintext_auth = no
</programlisting>

          The <emphasis role="strong">cert</emphasis> and <emphasis
          role="strong">key</emphasis> files are created automatically
          by <application>dovecot</application> when you install it. Please note that these keys
          are not signed and will give "bad signature" errors when
          connecting from a client. To avoid this, you can use
          commercial certificates, or even better, you can use your own
          SSL certificates.
          </para>
	</sect3>
	<sect3>
	  <title>Firewall Configuration for an Email Server</title>
          <para>
          To access your mail server from another computer, you must
          configure your firewall to allow connections to the server on
          the necessary ports.
            <itemizedlist>
            <listitem><para>IMAP - 143</para></listitem>
            <listitem><para>IMAPS - 993</para></listitem>
            <listitem><para>POP3 - 110</para></listitem>
            <listitem><para>POP3S - 995</para></listitem>
            </itemizedlist>
          </para>
        </sect3>
      </sect2>
      <sect2 id="mailman" status="complete">
        <title>Mailman</title> 
          <para>
          Mailman is an open source program for managing electronic mail
          discussions and e-newsletter lists. Many open source mailing
          lists (including all the <ulink
          url="http://lists.ubuntu.com">Ubuntu mailing lists</ulink>) use
          Mailman as their mailing list software. It is powerful and easy
          to install and maintain.
          </para>
        <sect3 id="mailman-installation" status="complete">
          <title>Installation</title>
            <para>
            Mailman provides a web interface for the administrators
            and users. So, it requires apache with mod_perl support.
            Mailman uses an external mail server to send and receive 
			emails. It works perfectly with the following mail servers:
            </para>
            <para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para><application>Postfix</application></para>
                </listitem>
                <listitem>
                    <para><application>Exim</application></para>
                </listitem>
                <listitem>
                    <para><application>Sendmail</application></para>
                </listitem>
                <listitem>
                    <para><application>Qmail</application></para>
                </listitem>
            </itemizedlist>
            </para>

            <para>
            We will see how to install mailman, the apache web server 
			and the Exim mail server. If you wish to install mailman
            with a different mail server, please refer to the references
            section. 
            </para>
          <sect4 id="mailman-apache2">
            <title>Apache2</title>
              <para>
                To install apache2 you refer to <xref linkend="http-installation" />.
              </para>
          </sect4>
          <sect4 id="mailman-exim4">
            <title>Exim4</title>
              <para>
              To install Exim4 you run the following commands at a terminal prompt:
<screen>
<command>sudo apt-get install exim4</command>
<command>sudo apt-get install exim4-base</command>
<command>sudo apt-get install exim4-config</command>
</screen>

Once exim4 is installed, the configuration files are stored in
the <filename>/etc/exim4</filename> directory. In ubuntu, by default, the exim4 configuration files are
split across different files. You can change this behavior by changing
the following variable in the <filename>/etc/exim4/update-exim4.conf</filename> file:

              <itemizedlist spacing="compact">
              <listitem>
                <para><application>dc_use_split_config='true'</application></para>
              </listitem>
              </itemizedlist>
              </para>
          </sect4>
          <sect4 id="mailman-mailman">
            <title>Mailman</title>
              <para>
              To install <application>Mailman</application>, run following command at a terminal prompt:
<screen>
<command>sudo apt-get install mailman</command> 
</screen>

It copies the installation files in
<application>/var/lib/mailman</application> directory. It installs the
CGI scripts in <application>/usr/lib/cgi-bin/mailman</application>
directory.  It creates <emphasis>list</emphasis> linux
user. It creates the <emphasis>list</emphasis> linux
group. The mailman process will be owned by this user. 
              </para>
          </sect4>
        </sect3>
        <sect3 id="mailman-configuration" status="complete">
          <title>Configuration</title>
            <para>
            This section assumes you have successfully installed
            <application>mailman</application>,
            <application>apache2</application>, and
            <application>exim4</application>. Now you just need
            to configure them. 
            </para>
          <sect4 id="mailman-conf-apache2">
            <title>Apache2</title>
              <para>
              Once apache2 is installed, you can add the following lines in
              the <filename>/etc/apache2/apache2.conf</filename> file:
<programlisting>
Alias /images/mailman/ "/usr/share/images/mailman/"
Alias /pipermail/ "/var/lib/mailman/archives/public/"
</programlisting>

Mailman uses apache2 to render its CGI scripts. The mailman CGI scripts
are installed in the <application>/usr/lib/cgi-bin/mailman</application>
directory. So, the mailman url will be
http://hostname/cgi-bin/mailman/. You can make changes to the
<filename>/etc/apache2/apache2.conf</filename> file if you wish to
change this behavior.
              </para>
          </sect4>

          <sect4 id="mailman-conf-exim4">
            <title>Exim4</title>
              <para>
              Once Exim4 is installed, you can start the Exim server using the following
              command from a terminal prompt:
<screen>
<command>sudo apt-get /etc/init.d/exim4 start</command>
</screen>

In order to make mailman work with exim4, you need to configure exim4.
As mentioned earlier, by default, exim4 uses multiple configuration
files of different types. For details, please refer to the <ulink
url="http://www.exim.org">Exim</ulink> website.  To run mailman, we
should add new a configuration file to the following configuration
types: 
              <itemizedlist spacing="compact">
              <listitem>
                <para>Main</para>
              </listitem>
              <listitem>
                <para>Transport</para>
              </listitem>
              <listitem>
                <para>Router</para>
              </listitem>
              </itemizedlist>
              Exim creates a master configuration file by sorting all
              these mini configuration files. So, the order of these
              configuration files is very important.
              </para>
          </sect4>
          <sect4 id="mailman-conf-main">
            <title>Main</title>
              <para>
              All the configuration files belonging to the main type are
              stored in the
              <filename>/etc/exim4/conf.d/main/</filename> directory. You can add
              the following content to a new file, named <filename>04_exim4-config_mailman</filename>:

<programlisting>
# start
# Home dir for your Mailman installation -- aka Mailman's prefix
# directory.
# On Ubuntu this should be "/var/lib/mailman"
# This is normally the same as ~mailman
MM_HOME=/var/lib/mailman
#
# User and group for Mailman, should match your --with-mail-gid
# switch to Mailman's configure script.  Value is normally "mailman"
MM_UID=list
MM_GID=list
#
# Domains that your lists are in - colon separated list
# you may wish to add these into local_domains as well
domainlist mm_domains=hostname.com
#
# -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#
# These values are derived from the ones above and should not need
# editing unless you have munged your mailman installation
#
# The path of the Mailman mail wrapper script
MM_WRAP=MM_HOME/mail/mailman
#
# The path of the list config file (used as a required file when
# verifying list addresses)
MM_LISTCHK=MM_HOME/lists/${lc::$local_part}/config.pck
# end
</programlisting>
          </para>
          </sect4>
          <sect4 id="mailman-conf-transport">
            <title>Transport</title>
              <para>
All the configuration files belonging to transport type are stored in
the <filename>/etc/exim4/conf.d/transport/</filename> directory. You
can add the following content to a new file named <filename>
40_exim4-config_mailman</filename>:

<programlisting>
  mailman_transport:
   driver = pipe
   command = MM_WRAP \
               '${if def:local_part_suffix \
                     {${sg{$local_part_suffix}{-(\\w+)(\\+.*)?}{\$1}}} \
                     {post}}' \
               $local_part
    current_directory = MM_HOME
    home_directory = MM_HOME
    user = MM_UID
    group = MM_GID
</programlisting>
              </para>
          </sect4>
          <sect4 id="mailman-conf-router">
            <title>Router</title>
              <para>
All the configuration files belonging to router type are stored in the
<filename>/etc/exim4/conf.d/router/</filename> directory. You can add the following content
in to a new file named <filename>101_exim4-config_mailman</filename>:
<programlisting>
  mailman_router:
   driver = accept
   require_files = MM_HOME/lists/$local_part/config.pck
   local_part_suffix_optional
   local_part_suffix = -bounces : -bounces+* : \
                       -confirm+* : -join : -leave : \
                       -owner : -request : -admin
   transport = mailman_transport
</programlisting>

              </para>
<warning>
<para>
The order of main and transport configuration files can be in any order.
But, the order of router configuration files must be the same.
This particular file must appear before the
<application>200_exim4-config_primary</application> file.
These two configuration files contain same type of information. The
first file takes the precedence. For more details, please refer to the
references section.
</para>
</warning>
          </sect4>
          <sect4 id="mailman-conf-mailman">
            <title>Mailman</title>
              <para>
Once mailman is installed, you can run it using the following command:
<screen>
<command>sudo /etc/init.d/mailman start</command>
</screen>

Once mailman is installed, you should create the default mailing list.
Run the following command to create the mailing list:


<screen>
<command>sudo /usr/sbin/newlist mailman</command>
</screen>

<programlisting>
  Enter the email address of the person running the list: bhuvan at ubuntu.com
  Initial mailman password:
  To finish creating your mailing list, you must edit your <filename>/etc/aliases</filename> (or
  equivalent) file by adding the following lines, and possibly running the
  `newaliases' program:

  ## mailman mailing list
  mailman:              "|/var/lib/mailman/mail/mailman post mailman"
  mailman-admin:        "|/var/lib/mailman/mail/mailman admin mailman"
  mailman-bounces:      "|/var/lib/mailman/mail/mailman bounces mailman"
  mailman-confirm:      "|/var/lib/mailman/mail/mailman confirm mailman"
  mailman-join:         "|/var/lib/mailman/mail/mailman join mailman"
  mailman-leave:        "|/var/lib/mailman/mail/mailman leave mailman"
  mailman-owner:        "|/var/lib/mailman/mail/mailman owner mailman"
  mailman-request:      "|/var/lib/mailman/mail/mailman request mailman"
  mailman-subscribe:    "|/var/lib/mailman/mail/mailman subscribe mailman"
  mailman-unsubscribe:  "|/var/lib/mailman/mail/mailman unsubscribe mailman"

  Hit enter to notify mailman owner...

  # 
</programlisting>

We have configured exim to recognize all emails from mailman. So, it is
not mandatory to make any new entries in
<filename>/etc/aliases</filename>.  If you have made any changes
to the configuration files, please ensure that you restart those
services before continuing to next section.
</para>
          </sect4>
        </sect3>
        <sect3 id="mailman-admin" status="complete">
          <title>Administration</title>
<para>
We assume you have a default installation. The
mailman cgi scripts are still in
<application>/usr/lib/cgi-bin/mailman/</application> directory.  Mailman
provides a web based administration facility. To access this page, point
your browser to the following url: 

</para>
<para>
http://hostname/cgi-bin/mailman/admin
</para>

<para>
The default mailing list, <emphasis>mailman</emphasis>,
will appear in this screen. If you click the mailing list name, it
will ask for your authentication password.  If you enter the correct
password, you will be able to change administrative settings of this
mailing list.

You can create a new mailing list using command line utility
(<command>/usr/sbin/newlist</command>).
Alternatively, you can create a new mailing list using web interface. 
</para>
        </sect3>
        <sect3 id="mailman-users" status="complete">
          <title>Users</title>
<para>
Mailman provides a web based interface for users. To access this page,
point your browser to the following url:
</para>

<para>
http://hostname/cgi-bin/mailman/listinfo
</para>

<para>
The default mailing list, <emphasis>mailman</emphasis>,
will appear in this screen. If you
click the mailing list name, it will display the subscription form. You
can enter your email address, name (optional), and password to subscribe.
An email invitation will be sent to you. You can follow the
instructions in the email to subscribe.
</para>
        </sect3>
        <sect3 id="mailman-references" status="complete">
          <title>References</title>
<para>
<ulink url="http://www.list.org/mailman-install/index.html"> GNU Mailman
- Installation Manual</ulink>
</para>
<para>
<ulink url="http://www.exim.org/howto/mailman21.html">HOWTO - Using Exim
4 and Mailman 2.1 together</ulink>
</para>
        </sect3>
      </sect2>
     </sect1>

	<sect1 id="NTP" status="complete">
		<title>Time Synchronisation with NTP</title>
	<para>
This page describes methods for keeping your computer's time accurate. This is useful for servers, but is not necessary (or desirable) for desktop machines. 
</para>
	<para>
NTP is a TCP/IP protocol for synchronising time over a network. Basically a client requests the current time from a server, and uses it to set its own clock.  
</para>
	<para>
Behind this simple description, there is a lot of complexity - there are tiers of NTP servers, with the tier one NTP servers connected to atomic clocks (often via GPS), and tier two and three servers spreading the load of actually handling requests across the internet. Also the client software is a lot more complex than you might think - it has to factor out communication delays, and adjust the time in a way that does not upset all the other processes that run on the server. But luckily all that complexity is hidden from you! 
</para>
	<para>
Ubuntu has two ways of automatically setting your time: ntpdate and ntpd. 
</para>

<sect2 id="ntpdate" status="complete">
<title>ntpdate</title>
	<para>
Ubuntu comes with ntpdate as standard, and will run it once at boot time to set up your time according to Ubuntu's NTP server. However, a server's clock  is likely to drift considerably between reboots, so it makes sense to correct the time ocassionally. The easiest way to do this is to get cron to run it every day. With your favourite editor, create a file 
<code>/etc/cron.daily/ntpdate</code>
 containing: 
</para>
<screen>ntpdate ntp.ubuntu.com
</screen>
<para/>
</sect2>
      <sect2 id="ntpd" status="complete">
<title>ntpd</title>
	<para>
ntpdate is a bit of a blunt instrument - it can only adjust the time once a day, in one big correction. The ntp daemon ntpd is far more subtle. It calculates the drift of your system clock and continuously adjusts it, so there are no large corrections that could lead to inconsistent logs for instance. The cost is a little processing power and memory, but for a modern server this is negligible. 
</para>
<para>To set up ntpd: </para>
<screen>sudo apt-get install ntp-simple
</screen>
<para/>
</sect2>
<sect2 id="timeservers" status="complete">
<title>Changing Time Servers</title>
	<para>
In both cases above, your system will use Ubuntu's NTP server at 
<code>ntp.ubuntu.com</code>
 by default. This is OK, but you might want to use several servers to increase accuracy and resilience, and you may want to use time servers that are geographically closer to you. to do this for ntpdate, change the contents of 
<code>/etc/cron.daily/ntpdate</code>
 to: 
</para>
<screen>ntpdate ntp.ubuntu.com pool.ntp.org 
</screen>
	<para>
And for ntpd edit 
<code>/etc/ntp.conf</code>
 to include additional server lines: 
</para>
<screen>ntp.ubuntu.com
server pool.ntp.org
</screen>
	<para>
You may notice 
<code>pool.ntp.org</code>
 in the examples above. This is a really good idea which uses round-robin DNS to return an NTP server from a pool, spreading the load between several different servers. Even better, they have pools for different regions - for instance, if you are in New Zealand, so you could use  
<code>nz.pool.ntp.org</code>
 instead of 
<code>pool.ntp.org</code>
. Look at 
<ulink url="http://www.pool.ntp.org/">http://www.pool.ntp.org/</ulink>
 for more details. 
</para>
	<para>
You can also Google for NTP servers in your region, and add these to your configuration. To test that a server works, just type 
<code>sudo ntpdate ntp.server.name</code>
 and see what happens. 
</para>
<para/>
</sect2>
	<sect2 id="relatedpages" status="complete">
<title>Related Pages</title>
	<itemizedlist>
	<listitem>
	<para>
<ulink url="http://ntp.isc.org/bin/view/Support/WebHome">NTP Support</ulink>
</para>
</listitem>
	<listitem>
	<para>
<ulink url="http://www.ntp.org/ntpfaq/NTP-a-faq.htm">The NTP FAQ and HOWTO</ulink>
</para>
</listitem>
</itemizedlist>
<para/>
</sect2>
    </sect1>
	</chapter>
