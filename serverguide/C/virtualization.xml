<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" 
	"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % globalent SYSTEM "../../libs/global.ent">
%globalent;
<!ENTITY % gnome-menus-C SYSTEM "../../libs/gnome-menus-C.ent">
%gnome-menus-C;
<!ENTITY % xinclude SYSTEM "../../libs/xinclude.mod">
%xinclude;
<!ENTITY language "&EnglishAmerican;">
]>
<chapter id="virtualization" status="review">
  <title>Virtualization</title>
  <para>
  Virtualization is being adopted in many different environments and situations. If you are a developer, 
  virtualization can provide you with a contained environment where you can safely do almost any sort of 
  development safe from messing up your main working environment. If you are a systems administrator, you 
  can use virtualization to more easily separate your services and move them around based on demand.
  </para>
  <para>
  The default virtualization technology supported in Ubuntu is <application>KVM</application>, a technology 
  that takes advantage of virtualization extensions built into Intel and AMD hardware.  
  For hardware without virtualization extensions <application>Xen</application> and 
  <application>Qemu</application> are popular solutions.
  </para>
  <sect1 id='libvirt' status='review'>
    <title>libvirt</title>
    <para>
    The <application>libvirt</application> library is used to interface with different
    virtualization technologies.  
    Before getting started with <application>libvirt</application> it is best to make sure your hardware supports the necessary 
    virtualization extensions for <application>KVM</application>.  Enter the following from a terminal prompt:
    </para>
<screen>
<command>kvm-ok</command>
</screen>
    <para>
    A message will be printed informing you if your CPU <emphasis>does</emphasis> or <emphasis>does not</emphasis> support hardware virtualization.
    </para>
    <note>
      <para>
      On most computer whose processor supports virtualization, it is
      necessary to activate an option in the BIOS to enable it. 
      </para>
    </note>
    <sect2 id="virtual-networking" status="review">
      <title>Virtual Networking</title>

      <para>
      There are a few different ways to allow a virtual machine access to the external network.  The default virtual network configuration is 
      <emphasis>usermode</emphasis> networking, which uses the SLIRP protocol and traffic is NATed through the host interface to the outside network.
      </para>

      <para>
      To enable external hosts to directly access services on virtual machines a <emphasis>bridge</emphasis> needs to be configured.  This allows
      the virtual interfaces to connect to the outside network through the physical interface, making them appear as normal hosts to the rest 
      of the network. For information on setting up a bridge see <xref linkend="bridging"/>.
      </para>

    </sect2>
    <sect2 id='libvirt-installation' status='review'>
      <title>Installation</title>
      <para>
      To install the necessary packages, from a terminal prompt enter:
      </para>
<screen>
<command>sudo apt-get install kvm libvirt-bin</command>
</screen>
      <para>
      After installing <application>libvirt-bin</application>, the user used to manage virtual machines will need to be added to 
      the <emphasis>libvirtd</emphasis> group.  Doing so will grant the user access to the advanced networking options.  
      </para>
      <para>
      In a terminal enter:
      </para>
<screen>
<command>sudo adduser $USER libvirtd</command>
</screen>
      <note>
	<para>
	If the user chosen is the current user, you will need to log out and back in for the new group membership to take effect.
	</para>
      </note>
      <para>
      You are now ready to install a <emphasis>Guest</emphasis> operating system.  Installing a virtual machine follows the same
      process as installing the operating system directly on the hardware.  You either need a way to automate the installation, or 
      a keyboard and monitor will need to be attached to the physical machine.  
      </para>
      <para>
      In the case of virtual machines a Graphical User Interface (GUI) is analogous to using a physical keyboard and mouse.  Instead of installing
      a GUI the <application>virt-viewer</application> application can be used to connect to a virtual machine's console using <application>VNC</application>.  
      See <xref linkend="libvirt-virt-viewer"/> for more information.
      </para>
      <para>
      There are several ways to automate the Ubuntu installation process, for example using 
      preseeds, kickstart, etc.  Refer to the <ulink url="https://help.ubuntu.com/&distro-rev-short;/installation-guide/">Ubuntu Installation Guide</ulink> for details.
      </para>
      <para>
      Yet another way to install an Ubuntu virtual machine is to use <application>ubuntu-vm-builder</application>.  <application>ubuntu-vm-builder</application> 
      allows you to setup advanced partitions, execute custom post-install scripts, etc.  For details see <xref linkend="jeos-and-vmbuilder"/>
      </para>
    </sect2>
    <sect2 id='libvirt-virt-install' status='review'>
      <title>virt-install</title>
      <para>
      <application>virt-install</application> is part of the <application>python-virtinst</application> package.  To install it, from a terminal prompt enter:
      </para>
<screen>
<command>sudo apt-get install python-virtinst</command>
</screen>
      <para>
      There are several options available when using <application>virt-install</application>.  For example:
      </para>
<screen>
<command>sudo virt-install -n web_devel -r 256 -f web_devel.img \
-s 4 -c jeos.iso --accelerate \
--connect=qemu:///system --vnc \
--noautoconsole -v</command>
</screen>
      <itemizedlist>
        <listitem>
          <para>
          <emphasis>-n web_devel:</emphasis> the name of the new virtual machine will be <emphasis>web_devel</emphasis> in this example.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>-r 256:</emphasis> specifies the amount of memory the virtual machine will use.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>-f web_devel.img:</emphasis> indicates the path to the virtual disk which can be a file, partition, or logical volume.
          In this example a file named <filename>web_devel.img</filename>.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>-s 4:</emphasis> the size of the virtual disk.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>-c jeos.iso:</emphasis> file to be used as a virtual CDROM.  The file can be either an ISO file or the path to the
          host's CDROM device.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>--accelerate:</emphasis> enables the kernel's acceleration technologies. 
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>--vnc:</emphasis> exports the guest's virtual console using VNC. 
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>--noautoconsole:</emphasis> will not automatically connect to the virtual machine's console. 
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>-v:</emphasis> creates a fully virtualized guest. 
          </para>
        </listitem>
      </itemizedlist>
      <para>
      After launching <application>virt-install</application> you can connect to the virtual machine's console either locally
      using a GUI or with the <application>virt-viewer</application> utility.
      </para>
    </sect2>
    <sect2 id="libvirt-virt-clone" status="review">
      <title>virt-clone</title>
      <para>
      The <application>virt-clone</application> application can be used to copy one virtual machine to another.  For example:
      </para>
<screen>
<command>sudo virt-clone -o web_devel -n database_devel -f /path/to/database_devel.img --connect=qemu:///system</command> 
</screen>
      <itemizedlist>
        <listitem>
          <para>
          <emphasis>-o:</emphasis> original virtual machine.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>-n:</emphasis> name of the new virtual machine.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>-f:</emphasis> path to the file, logical volume, or partition to be used by the new virtual machine.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>--connect:</emphasis> specifies which hypervisor to connect to.
          </para>
        </listitem>
      </itemizedlist>
      <para>
      Also, use <emphasis>-d</emphasis> or <emphasis>--debug</emphasis> option to help troubleshoot problems with 
      <application>virt-clone</application>.
      </para>
      <note>
        <para>
	Replace <emphasis>web_devel</emphasis> and <emphasis>database_devel</emphasis> with appropriate virtual machine names.
        </para>
      </note>
    </sect2>
    <sect2 id="libvirt-management" status="review">
      <title>Virtual Machine Management</title>
      <sect3 id="virsh" status="review">
        <title>virsh</title>
        <para>
        There are several utilities available to manage virtual machines and <application>libvirt</application>.  
        The <application>virsh</application> utility can be used from the command line.  Some examples: 
        </para>
        <itemizedlist>
          <listitem>
            <para>
    	    To list running virtual machines:
            </para>
<screen>
<command>virsh -c qemu:///system list</command>
</screen>
          </listitem>
          <listitem>
            <para>
  	    To start a virtual machine:
            </para>
<screen>
<command>virsh -c qemu:///system start web_devel</command>
</screen>
          </listitem>
          <listitem>
            <para>
  	    Similarly, to start a virtual machine at boot:
            </para>
<screen>
<command>virsh -c qemu:///system autostart web_devel</command>
</screen>
          </listitem>
          <listitem>
            <para>
 	    Reboot a virtual machine with:
            </para>
<screen>
<command>virsh -c qemu:///system reboot web_devel</command>
</screen>
          </listitem>
          <listitem>
            <para>
  	    The <emphasis>state</emphasis> of virtual machines can be saved to a file in order to be restored later.  The
            following will save the virtual machine state into a file named according to the date:
            </para>
<screen>
<command>virsh -c qemu:///system save web_devel web_devel-022708.state</command>
</screen>
            <para>
            Once saved the virtual machine will no longer be running.
            </para>
          </listitem>
          <listitem>
            <para>
	    A saved virtual machine can be restored using:
            </para>
<screen>
<command>virsh -c qemu:///system restore web_devel-022708.state</command>
</screen>
          </listitem>
          <listitem>
            <para>
	    To shutdown a virtual machine do:
            </para>
<screen>
<command>virsh -c qemu:///system shutdown web_devel</command>
</screen>
          </listitem>
          <listitem>
            <para>
	    A CDROM device can be mounted in a virtual machine by entering:
            </para>
<screen>
<command>virsh -c qemu:///system attach-disk web_devel /dev/cdrom /media/cdrom</command>
</screen>
          </listitem>
        </itemizedlist>
        <note>
          <para>
          In the above examples replace <emphasis>web_devel</emphasis> with the appropriate virtual machine name, and 
  	  <filename>web_devel-022708.state</filename> with a descriptive file name.
          </para>
        </note>
      </sect3>
      <sect3 id="virt-manager" status="review">
        <title>Virtual Machine Manager</title>
        <para>
        The <application>virt-manager</application> package contains a graphical utility to manage local and remote virtual machines.
        To install virt-manager enter:
        </para>
<screen>
<command>sudo apt-get install virt-manager</command>
</screen>
        <para>
        Since <application>virt-manager</application> requires a Graphical User Interface (GUI) environment it is recommended to be 
	installed on a workstation or test machine instead of a production server.  To connect to the local 
        <application>libvirt</application> service enter:
        </para>
<screen>
<command>virt-manager -c qemu:///system</command>
</screen>
        <para>
	You can connect to the <application>libvirt</application> service running on another host by entering the following in a terminal prompt:
        </para>
<screen>
<command>virt-manager -c qemu+ssh://virtnode1.mydomain.com/system</command>
</screen>
        <note>
          <para>
          The above example assumes that <application>SSH</application> connectivity between the management system and virtnode1.mydomain.com 
          has already been configured, and uses SSH keys for authentication.  SSH <emphasis>keys</emphasis> are needed because 
          <application>libvirt</application> sends the password prompt to another process.  For details on configuring 
	  <application>SSH</application> see <xref linkend="openssh-server"/>
          </para>
        </note>
      </sect3>
    </sect2>
    <sect2 id="libvirt-virt-viewer" status="review">
      <title>Virtual Machine Viewer</title> 
      <para>
      The <application>virt-viewer</application> application allows you to connect to a virtual machine's console.  
      <application>virt-viewer</application> does require a Graphical User Interface (GUI) to interface with the virtual machine. 
      </para>
      <para>  
      To install <application>virt-viewer</application> from a terminal enter:
      </para>
<screen>
<command>sudo apt-get install virt-viewer</command>
</screen>
      <para>
      Once a virtual machine is installed and running you can connect to the virtual machine's console by using:
      </para>
<screen>
<command>virt-viewer -c qemu:///system web_devel</command>
</screen>
      <para>
      Similar to <application>virt-manager</application>, <application>virt-viewer</application> can connect to a remote host using 
      <emphasis>SSH</emphasis> with key authentication, as well:
      </para>
<screen>
<command>virt-viewer -c qemu+ssh://virtnode1.mydomain.com/system web_devel</command>
</screen>
      <para>
      Be sure to replace <emphasis role="italic">web_devel</emphasis> with the appropriate virtual machine name.
      </para>
      <para>
      If configured to use a <emphasis>bridged</emphasis> network interface you can also setup <application>SSH</application> access
      to the virtual machine.  See <xref linkend="openssh-server"/> and <xref linkend="bridging"/> for more details.
      </para>
    </sect2>
    <sect2 id="libvirt-resources" status="review">
      <title>Resources</title> 
      <itemizedlist>
        <listitem>
          <para>
     	  See the <ulink url="http://kvm.qumranet.com/kvmwiki">KVM</ulink> home page for more details.
          </para>
        </listitem>
        <listitem>
          <para>
     	  For more information on <application>libvirt</application> see the <ulink url="http://libvirt.org/">libvirt home page</ulink> 
          </para>
        </listitem>
        <listitem>
          <para>
     	  The <ulink url="http://virt-manager.et.redhat.com/">Virtual Machine Manager</ulink> site has more information on 
          <application>virt-manager</application> development.
          </para>
        </listitem>
        <listitem>
          <para>
          Also, stop by the <emphasis>#ubuntu-virt</emphasis> IRC channel on <ulink url="http://freenode.net/">freenode</ulink> to 
          discuss virtualization technology in Ubuntu.
          </para>
        </listitem>
        <listitem>
          <para>
          Another good resource is the <ulink url="https://help.ubuntu.com/community/KVM">Ubuntu Wiki KVM</ulink> page.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
  <sect1 id="jeos-and-vmbuilder" status="review">
  <title>JeOS and vmbuilder</title>

  <sect2 id="jeos-introduction" status="review">
    <title>Introduction</title>

    <sect3 id="what-is-jeos" status="review">
      <title>What is JeOS</title>

  <para>
  Ubuntu <emphasis>JeOS</emphasis> (pronounced "Juice") is an efficient variant of the Ubuntu Server operating system, 
  configured specifically for virtual appliances.  No longer available as a CD-ROM ISO for download, but only as an option either:
  </para>

  <itemizedlist>
    <listitem>
      <para>
      While installing from the Server Edition ISO (pressing <emphasis>F4</emphasis> on the first screen will allow you to pick 
      "Minimal installation", which is the package selection equivalent to JeOS).
      </para>
    </listitem>
    <listitem>
      <para>
      Or to be built using Ubuntu's vmbuilder, which is described here. 
      </para>
    </listitem>
  </itemizedlist>
      
  <para>
  JeOS is a specialized installation of Ubuntu Server Edition with a tuned kernel that only contains the base elements needed 
  to run within a virtualized environment.
  </para>

  <para>
  Ubuntu JeOS has been tuned to take advantage of key performance technologies in the latest virtualization products from VMware. 
  This combination of reduced size and optimized performance ensures that Ubuntu JeOS Edition delivers a highly efficient use of 
  server resources in large virtual deployments.
  </para>
  
  <para>
  Without unnecessary drivers, and only the minimal required packages, ISVs can configure their supporting OS exactly as they require. 
  They have the peace of mind that updates, whether for security or enhancement reasons, will be limited to the bare minimum of what 
  is required in their specific environment. In turn, users deploying virtual appliances built on top of JeOS will have to go through 
  fewer updates and therefore less maintenance than they would have had to with a standard full installation of a server.
  </para>
 
    </sect3>
    <sect3 id="what-is-vmbuilder">
      <title>What is vmbuilder</title>

      <para>
      With vmbuilder, there is no need to download a JeOS ISO anymore. vmbuilder will fetch the various package and build a virtual machine 
      tailored for your needs in about a minute. vmbuilder is a script that automates the process of creating a ready to use Linux based
      VM. The currently supported hypervisors are KVM and Xen.
      </para>

      <para>
      You can pass command line options to add extra packages, remove packages, choose which version of Ubuntu, which mirror etc. On recent 
      hardware with plenty of RAM, tmpdir in <filename>/dev/shm</filename> or using a tmpfs, and a local mirror, you can bootstrap a VM in 
      less than a minute.
      </para>

      <para>
      First introduced as a shell script in Ubuntu 8.04 LTS, <application>ubuntu-vm-builder</application> started with little emphasis as 
      a hack to help developers test their new code in a virtual machine without having to restart from scratch each time. As a few Ubuntu 
      administrators started to notice this script, a few of them went on improving it and adapting it for so many use case that 
      Soren Hansen (the author of the script and Ubuntu virtualization specialist, not the golf player) decided to rewrite it from scratch 
      for Intrepid as a python script with a few new design goals:
      </para>

      <itemizedlist>
        <listitem>
          <para>
          Develop it so that it can be reused by other distributions.
          </para>
        </listitem>
        <listitem>
          <para>
          Use a plugin mechanisms for all virtualization interactions so that others can easily add logic for other virtualization environments.
          </para>
        </listitem>
        <listitem>
          <para>
          Provide an easy to maintain web interface as an option to the command line interface.
          </para>
        </listitem>
      </itemizedlist>

      <para>
      But the general principles and commands remain the same. 
      </para>

    </sect3>
  </sect2>
  <sect2 id="jeos-initial-setup" status="review">
    <title>Initial Setup</title>

    <para>
    It is assumed that you have installed and configured <application>libvirt</application> and <application>KVM</application> locally
    on the machine you are using. For details on how to perform this, please refer to:
    </para>

    <itemizedlist>
      <listitem>
        <para>
        <xref linkend="libvirt"/>
        </para>
      </listitem>
      <listitem>
        <para>
        The <ulink url="https://help.ubuntu.com/community/KVM">KVM</ulink> Wiki page.
        </para>
      </listitem>
    </itemizedlist>

    <para>
    We also assume that you know how to use a text based text editor such as nano or vi. If you have not used any of them before, 
    you can get an overview of the various text editors available by reading the  
    <ulink url="https://help.ubuntu.com/community/PowerUsersTextEditors">PowerUsersTextEditors</ulink> page. This tutorial has been 
    done on KVM, but the general principle should remain on other virtualization technologies. 
    </para>
  
      <sect3 id="install-vmbuilder" status="review">
        <title>Install vmbuilder</title>

        <para>
        The name of the package that we need to install is <application>python-vm-builder</application>.  In a terminal prompt enter: 
        </para>

<screen>
<command>sudo apt-get install python-vm-builder</command>
</screen>

        <note>
          <para>
          If you are running Hardy, you can still perform most of this using the older version of the package named 
          <application>ubuntu-vm-builder</application>, there are only a few changes to the syntax of the tool. 
          </para>
        </note>

      </sect3>
    </sect2>
    <sect2 id="defining-vm" status="review">
      <title>Defining Your Virtual Machine</title>

      <para>
      Defining a virtual machine with Ubuntu's vmbuilder is quite simple, but here are a few thing to consider:
      </para>

      <itemizedlist>
        <listitem>
          <para>
          If you plan on shipping a virtual appliance, do not assume that the end-user will know how to extend disk size to fit their need,
          so either plan for a large virtual disk to allow for your appliance to grow, or explain fairly well in your documentation how
          to allocate more space. It might actually be a good idea to store data on some separate external storage.
	  </para>
	</listitem>
        <listitem>
          <para>
          Given that RAM is much easier to allocate in a VM, RAM size should be set to whatever you think is a safe minimum for your appliance.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
      The <application>vmbuilder</application> command has 2 main parameters: the <emphasis>virtualization technology (hypervisor)</emphasis>
      and the targeted <emphasis>distribution</emphasis>. Optional parameters are quite numerous and can be found using the following command:
      </para>

<screen>
<command>vmbuilder kvm ubuntu --help</command>
</screen>

    <sect3 id="vm-base-parameters" status="review">
      <title>Base Parameters</title>

      <para>
      As this example is based on <application>KVM</application> and Ubuntu &distro-rev; (&distro-version;), and we are likely to rebuild 
      the same virtual machine multiple time, we'll invoke vmbuilder with the following first parameters: 
      </para>

<screen>
<command>sudo vmbuilder kvm ubuntu --suite &distro-short-codename; --flavour virtual --arch i386  -o --libvirt qemu:///system</command>
</screen>

      <para>
      The <emphasis>--suite</emphasis> defines the Ubuntu release, the <emphasis>--flavour</emphasis> specifies that we want to use 
      the virtual kernel (that's the one used to build a JeOS image), the <emphasis>--arch</emphasis> tells that we want to use a 
      32 bit machine, the <emphasis>-o</emphasis> tells vmbuilder to overwrite the previous version of the VM and the 
      <emphasis>--libvirt</emphasis> tells to inform the local virtualization environment to add the resulting VM to the list of available
      machines. 
      </para>

      <para>
      Notes:
      </para>

      <itemizedlist>
        <listitem>
          <para>
          Because of the nature of operations performed by vmbuilder, it needs to have root privilege, hence the use of sudo.
          </para>
        </listitem>
        <listitem>
          <para>
          If your virtual machine needs to use more than 3Gb of ram, you should build a 64 bit machine (--arch amd64).
          </para>
        </listitem>
        <listitem>
          <para>
          Until Ubuntu 8.10, the virtual kernel was only built for 32 bit architecture, so if you want to define an amd64 machine 
          on Hardy, you should use <emphasis>--flavour</emphasis> server instead. 
          </para>
        </listitem> 
      </itemizedlist>
    </sect3>
    <sect3 id="jeos-installation-parameters" status="review">
      <title>JeOS Installation Parameters</title>

      <sect4 id="jeos-networking" status="review">
        <title>JeOS Networking</title>

      <sect5 id="jeos-fixed-ip" status="review">
        <title>Assigning a fixed IP address</title>

        <para>
        As a virtual appliance that may be deployed on various very different networks, it is very difficult to know what 
        the actual network will look like. In order to simplify configuration, it is a good idea to take an approach similar 
        to what network hardware vendors usually do, namely assigning an initial fixed IP address to the appliance in a 
        private class network that you will provide in your documentation. An address in the range 192.168.0.0/255 is usually a good choice.
        </para>
        
        <para>
        To do this we'll use the following parameters:
        </para>
	
        <itemizedlist>
          <listitem>
            <para>
            <emphasis>--ip ADDRESS</emphasis>: IP address in dotted form (defaults to dhcp if not specified)
            </para>
	  </listitem>
          <listitem>
            <para>
            <emphasis>--hostname NAME</emphasis>: Set NAME as the hostname of the guest.
            </para>
	  </listitem>
          <listitem>
            <para>
            <emphasis>--mask VALUE</emphasis>: IP mask in dotted form (default: 255.255.255.0)
            </para>
          </listitem>
          <listitem>
            <para>
            <emphasis>--net VALUE</emphasis>: IP net address (default: X.X.X.0)
            </para>
	  </listitem>
          <listitem>
            <para>
            <emphasis>--bcast VALUE</emphasis>: IP broadcast (default: X.X.X.255)
            </para>
	  </listitem>
          <listitem>
            <para>
            <emphasis>--gw ADDRESS</emphasis>: Gateway address (default: X.X.X.1)
            </para>
	  </listitem>
          <listitem>
            <para>
            <emphasis>--dns ADDRESS</emphasis>: Name server address (default: X.X.X.1)
            </para>
	  </listitem>
        </itemizedlist>

        <para>
        We assume for now that default values are good enough, so the resulting invocation becomes: 
        </para>

<screen>
<command>sudo vmbuilder kvm ubuntu --suite &distro-short-codename; --flavour virtual --arch i386 -o --libvirt qemu:///system --ip 192.168.0.100 --hostname myvm </command>
</screen>

        </sect5>
        <sect5 id="jeos-bridging" status="review">
          <title>Bridging</title>

          <para>
          Because our appliance will be likely to need to be accessed by remote hosts, we need to configure libvirt so that the appliance
          uses bridge networking.  To do this add the <emphasis>--bridge</emphasis> option to the command: 
          </para>

<screen>
<command>sudo vmbuilder kvm ubuntu --suite &distro-short-codename; --flavour virtual --arch i386 -o --libvirt qemu:///system --ip 192.168.0.100 --hostname myvm --bridge br0</command>
</screen>

        <note>
          <para>
          You will need to have previously setup a bridge interface, see <xref linkend="bridging"/> for more information.
          Also, if the interface name is different change <emphasis>br0</emphasis> to the actual bridge interface.
          </para>
        </note>

        </sect5>
      </sect4>
      <sect4 id="jeos-partitioning" status="review">
        <title>Partitioning</title>
          
        <para>
        Partitioning of the virtual appliance will have to take into consideration what you are planning to do with is. Because 
        most appliances want to have a separate storage for data, having a separate <filename>/var</filename> would make sense.
        </para>
           
        <para>
        In order to do this vmbuilder provides us with <emphasis>--part</emphasis>: 
        </para>

<programlisting>
--part PATH
  Allows you to specify a partition table in a partition file, located at PATH. Each line of the partition file should specify
  (root first):
      mountpoint size
  where  size  is  in megabytes. You can have up to 4 virtual disks, a new disk starts on a
  line with ’---’.  ie :
      root 1000
      /opt 1000
      swap 256
      ---
      /var 2000
      /log 1500
</programlisting>

        <para>
        In our case we will define a text file name <filename>vmbuilder.partition</filename> which will contain the following: 
        </para>

<programlisting>
root 8000
swap 4000
---
/var 20000
</programlisting>

        <note>
          <para>
          Note that as we are using virtual disk images, the actual sizes that we put here are maximum sizes for these volumes. 
          </para>
        </note>

        <para>
        Our command line now looks like: 
        </para>

<screen>
<command>sudo vmbuilder kvm ubuntu --suite &distro-short-codename; --flavour virtual --arch i386 \ 
         -o --libvirt qemu:///system --ip 192.168.0.100 --hostname myvm --part vmbuilder.partition</command>
</screen>

        <note>
          <para>
          Using a "\" in a command will allow long command strings to wrap to the next line.
          </para>
        </note>

      </sect4>
      <sect4 id="jeos-user-password" status="review">
        <title>User and Password</title>

        <para>
        Again setting up a virtual appliance, you will need to provide a default user and password that is generic so 
        that you can include it in your documentation. We will see later on in this tutorial how we will provide some 
        security by defining a script that will be run the first time a user actually logs in the appliance, that will, 
        among other things, ask him to change his password. In this example I will use <emphasis>'user'</emphasis> as my 
        user name, and <emphasis>'default'</emphasis> as the password.
        </para>

        <para>
        To do this we use the following optional parameters: 
        </para>

        <itemizedlist>
          <listitem>
            <para>
            <emphasis>--user USERNAME:</emphasis> Sets the name of the user to be added. Default: ubuntu.
            </para>
          </listitem>
          <listitem>
            <para>
            <emphasis>--name FULLNAME:</emphasis> Sets the full name of the user to be added. Default: Ubuntu.
            </para>
          </listitem>
          <listitem>
            <para>
            <emphasis>--pass PASSWORD:</emphasis>   Sets the password for the user. Default: ubuntu.
            </para>
          </listitem>
        </itemizedlist>

        <para>
        Our resulting command line becomes:
        </para>

<screen>
<command>sudo vmbuilder kvm ubuntu --suite &distro-short-codename; --flavour virtual --arch i386 \
         -o --libvirt qemu:///system --ip 192.168.0.100 --hostname myvm --part vmbuilder.partition \ 
         --user user --name user --pass default</command>
</screen>

      </sect4>
    </sect3>
    <sect3 id="jeos-required-packages" status="review">
      <title>Installing Required Packages</title>

      <para>
      In this example we will be installing a package <application>(Limesurvey)</application> that accesses a 
      <application>MySQL</application> database and has a web interface. We will therefore require our OS to 
      provide us with:
      </para>

      <itemizedlist>
        <listitem><para>Apache</para></listitem>
        <listitem><para>PHP</para></listitem>
        <listitem><para>MySQL</para></listitem>
        <listitem><para>OpenSSH Server</para></listitem>
        <listitem><para>Limesurvey (as an example application that we have packaged)</para></listitem>
      </itemizedlist>

      <para>
      This is done using vmbuilder by specifying the --addpkg option multiple times:
      </para>

<programlisting>
--addpkg PKG
  Install PKG into the guest (can be specfied multiple times)
</programlisting>

      <para>
      However, due to the way vmbuilder operates, packages that have to ask questions to the user during the post install phase are not supported and
      should instead be installed while interactivity can occur. This is the case of Limesurvey, which we will have to install later, once the user logs
      in.
      </para>

      <para>
      Other packages that ask simple debconf question, such as <application>mysql-server</application> asking to set a password, the package can be
      installed immediately, but we will have to reconfigure it the first time the user logs in.
      </para>


     <para>
     If some packages that we need to install are not in main, we need to enable the additional repositories using --comp and --ppa: 
     </para>

<programlisting>
--components COMP1,COMP2,...,COMPN
           A comma separated list of distro components to include (e.g. main,universe). This defaults
           to "main"
--ppa=PPA  Add ppa belonging to PPA to the vm's sources.list.
</programlisting>

      <para>
      Limesurvey not being part of the archive at the moment, we'll specify it's PPA (personal package archive) address so that it is added to the VM 
      <filename>/etc/apt/source.list</filename>, so we add the following options to the command line:
      </para>

<screen>
<command>--addpkg apache2 --addpkg apache2-mpm-prefork --addpkg apache2-utils --addpkg apache2.2-common \
         --addpkg dbconfig-common --addpkg libapache2-mod-php5 --addpkg mysql-client --addpkg php5-cli \
         --addpkg php5-gd --addpkg php5-ldap --addpkg php5-mysql --addpkg wwwconfig-common \
         --addpkg mysql-server --ppa nijaba</command>
</screen>

      </sect3>
      <sect3 id="jeos-speed-consideration" status="review">
        <title>Speed Considerations</title>
        
        <sect4 id="jeos-package-caching" status="review">
          <title>Package Caching</title>

          <para>       
          When vmbuilder creates builds your system, it has to go fetch each one of the packages that composes it over the network 
          to one of the official repositories, which, depending on your internet connection speed and the load of the mirror, can 
          have a big impact on the actual build time. In order to reduce this, it is recommended to either have a local repository 
          (which can be created using <application>apt-mirror</application>) or using a caching proxy such as 
          <application>apt-proxy</application>. The later option being much simpler to implement and requiring less disk space, it
          is the one we will pick in this tutorial. To install it, simply type:
          </para>

<screen>
<command>sudo apt-get install apt-proxy</command>
</screen>

          <para>
          Once this is complete, your (empty) proxy is ready for use on http://mirroraddress:9999 and will find ubuntu repository 
          under /ubuntu. For vmbuilder to use it, we'll have to use the <emphasis>--mirror</emphasis> option:
          </para>

<programlisting>
--mirror=URL  Use Ubuntu mirror at URL instead of the default, which
              is http://archive.ubuntu.com/ubuntu for official
              arches and http://ports.ubuntu.com/ubuntu-ports
              otherwise
</programlisting>

          <para>
          So we add to the command line: 
          </para>

<screen>
<command>--mirror http://mirroraddress:9999/ubuntu</command>
</screen>

          <note>
            <para>
            The mirror address specified here will also be used in the <filename>/etc/apt/sources.list</filename> of the newly created 
            guest, so it is useful to specify here an address that can be resolved by the guest or to plan on reseting this address 
            later on.
            </para>
          </note>

          </sect4>
          <sect4 id="jeos-local-mirror" status="review">
            <title>Install a Local Mirror</title>

            <para>
            If we are in a larger environment, it may make sense to setup a local mirror of the Ubuntu repositories. 
            The package apt-mirror provides you with a script that will handle the mirroring for you. You should 
            plan on having about 20 gigabyte of free space per supported release and architecture.
            </para>

            <para>
            By default, <application>apt-mirror</application> uses the configuration file in <filename>/etc/apt/mirror.list</filename>. 
            As it is set up, it will replicate only the architecture of the local machine. If you would like to support other 
            architectures on your mirror, simply duplicate the lines starting with “deb”, replacing the deb keyword by /deb-{arch}
            where arch can be i386, amd64, etc... For example, on an amd64 machine, to have the i386 archives as well, you will have:
            </para>

<programlisting>
deb  http://archive.ubuntu.com/ubuntu &distro-short-codename; main restricted universe multiverse 
/deb-i386  http://archive.ubuntu.com/ubuntu &distro-short-codename; main restricted universe multiverse

deb  http://archive.ubuntu.com/ubuntu &distro-short-codename;-updates main restricted universe multiverse 
/deb-i386  http://archive.ubuntu.com/ubuntu &distro-short-codename;-updates main restricted universe multiverse 

deb http://archive.ubuntu.com/ubuntu/ &distro-short-codename;-backports main restricted universe multiverse 
/deb-i386  http://archive.ubuntu.com/ubuntu &distro-short-codename;-backports main restricted universe multiverse 

deb http://security.ubuntu.com/ubuntu &distro-short-codename;-security main restricted universe multiverse 
/deb-i386  http://security.ubuntu.com/ubuntu &distro-short-codename;-security main restricted universe multiverse 

deb http://archive.ubuntu.com/ubuntu &distro-short-codename; main/debian-installer restricted/debian-installer universe/debian-installer multiverse/debian-installer 
/deb-i386 http://archive.ubuntu.com/ubuntu &distro-short-codename; main/debian-installer restricted/debian-installer universe/debian-installer multiverse/debian-installer 
</programlisting>

            <para>
            Notice that the source packages are not mirrored as they are seldom used compared to the binaries and they do take
            a lot more space, but they can be easily added to the list.
            </para>

            <para>
            Once the mirror has finished replicating (and this can be quite long), you need to configure Apache so that your
            mirror files (in <filename>/var/spool/apt-mirror</filename> if you did not change the default), are published by 
            your Apache server. For more information on Apache see <xref linkend="httpd"/>.
            </para>

          </sect4>
        </sect3>
      </sect2>
      <sect2 id="jeos-package-application" status="review">
        <title>Package the Application</title>

        <para>
        Two option are available to us:
        </para>

        <itemizedlist>
          <listitem>
	    <para>
            The recommended method to do so is to make a <emphasis>Debian</emphasis> package. Since this is outside of the
            scope of this tutorial, we will not perform this here and invite the reader to read the documentation on how to do 
            this in the <ulink url="https://wiki.ubuntu.com/PackagingGuide">Ubuntu Packaging Guide</ulink>. In this case it is 
            also a good idea to setup a repository for your package so that updates can be conveniently pulled from it. See the
            <ulink url="http://www.debian-administration.org/articles/286">Debian Administration</ulink> article for a tutorial on this.
            </para> 
          </listitem>
          <listitem>
	    <para>
            Manually install the application under <filename>/opt</filename> as recommended by the 
            <ulink url="http://www.pathname.com/fhs/">FHS guidelines</ulink>. 
            </para> 
          </listitem>
        </itemizedlist>

        <para>
        In our case we'll use <application>Limesurvey</application> as example web application for which we wish to provide 
        a virtual appliance. As noted before, we've made a version of the package available in a PPA (Personal Package Archive).
        </para>

      </sect2>
      <sect2 id="jeos-additions" status="review">
        <title>Useful Additions</title>

      <sect3 id="jeos-automatic-updates" status="review">
        <title>Configuring Automatic Updates</title>
        
        <para>
        To have your system be configured to update itself on a regular basis, we will just install 
        <application>unattended-upgrades</application>, so we add the following option to our command line:
        </para>

<screen>
<command>--addpkg unattended-upgrades</command>
</screen>

      <para>
      As we have put our application package in a PPA, the process will update not only the system, but also 
      the application each time we update the version in the PPA.
      </para>
 
      </sect3>
      <sect3 id="jeos-acpi" status="review">
        <title>ACPI Event Handling</title>

        <para>
        For your virtual machine to be able to handle restart and shutdown events it is being sent, it is a good idea to install the acpid package as
        well. To do this we just add the following option: 
        </para>

<screen>
<command>--addpkg acpid</command>
</screen>

      </sect3>
    </sect2>
    <sect2 id="jeos-final-command">
      <title>Final Command</title>

      <para>
      Here is the command with all the options discussed above:      
      </para>

<screen>
<command>sudo vmbuilder kvm ubuntu --suite &distro-short-codename; --flavour virtual --arch i386 -o \ 
         --libvirt qemu:///system --ip 192.168.0.100 --hostname myvm --part vmbuilder.partition --user user \
         --name user --pass default --addpkg apache2 --addpkg apache2-mpm-prefork \ 
         --addpkg apache2-utils --addpkg apache2.2-common --addpkg dbconfig-common \ 
         --addpkg libapache2-mod-php5 --addpkg mysql-client --addpkg php5-cli \ 
         --addpkg php5-gd --addpkg php5-ldap --addpkg php5-mysql --addpkg wwwconfig-common \
         --addpkg mysql-server --addpkg unattended-upgrades --addpkg acpid --ppa nijaba \ 
         --mirror http://mirroraddress:9999/ubuntu 
         </command>
</screen>

    </sect2>
    <sect2 id="jeos-resources" status="review">
      <title>Resources</title>
      <para>
      If you are interested in learning more, have questions or suggestions, please contact the Ubuntu Server Team at:
      </para>
      <itemizedlist>
        <listitem>
          <para>
          IRC: #ubuntu-server on freenode
          </para>
        </listitem>
        <listitem>
          <para>
          Mailing list: <ulink url="https://lists.ubuntu.com/mailman/listinfo/ubuntu-server">ubuntu-server at lists.ubuntu.com</ulink>
          </para>
        </listitem>
        <listitem>
          <para>
          Also, see the <ulink url="https://help.ubuntu.com/community/JeOSVMBuilder">JeOSVMBuilder Ubuntu Wiki</ulink> page.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
  <sect1 id="uec" status="review">
    <title>UEC</title>

    <sect2 id="uec-overview" status="review">
      <title>Overview</title>

      <para>
      This tutorial covers <application>UEC</application> installation from the Ubuntu &distro-rev; Server Edition CD, and assumes a basic network topology, 
      with a single system serving as the <emphasis>"all-in-one controller"</emphasis>, and one or more nodes attached.
      </para>

      <para>
      From this Tutorial you will learn how to install, configure, register and perform several operations on a basic <application>UEC</application> 
      setup that results in a cloud with a one controller <emphasis>"front-end"</emphasis> and one or several node(s) for running Virtual Machine (VM)
      instances. You will also use examples to help get you started using your own private compute cloud.
      </para>

    </sect2>
    <sect2 id="uec-prerequisites" status="review">
      <title>Prerequisites</title>

      <para>
      To deploy a minimal cloud infrastructure, you’ll need at least <emphasis>two</emphasis> dedicated systems:
      </para>

      <itemizedlist>
        <listitem>
          <para>
          A front end.
          </para>
        </listitem>
        <listitem>
          <para>
          One or more node(s).
          </para>
        </listitem>
      </itemizedlist>

      <para>
      The following are recommendations, rather than fixed requirements. However, our experience in developing this documentation indicated the following suggestions.
      </para>

      <sect3 id="uec-frontend-requirements" status="review">
        <title>Front End Requirements</title>
 
        <para>
        Use the following table for a system that will run one or more of:
        </para>

        <itemizedlist>
          <listitem><para>Cloud Controller (CLC)</para></listitem>
          <listitem><para>Cluster Controller (CC)</para></listitem>
          <listitem><para>Walrus (the S3-like storage service)</para></listitem>
          <listitem><para>Storage Controller (SC)</para></listitem>
        </itemizedlist>

        <table>
          <title>UEC Front End Requirements</title>
          <tgroup cols="4" rowsep="1">
          <colspec colname="1"/>
          <colspec colname="2"/>
          <colspec colname="3"/>
          <colspec colname="4"/>
          <thead>
            <row>
              <entry morerows="1" valign="middle"><para>Hardware</para></entry>
              <entry morerows="1" valign="middle"><para>Minimum</para></entry>
              <entry morerows="1" valign="middle"><para>Suggested</para></entry>
              <entry morerows="1" valign="middle"><para>Notes</para></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><para>CPU</para></entry>
              <entry><para>1 GHz</para></entry>
              <entry><para>2 x 2 GHz</para></entry>
              <entry><para>For an <emphasis>all-in-one</emphasis> front end, it helps to have at least a dual core processor.</para></entry>
            </row>
            <row>
              <entry><para>Memory</para></entry>
              <entry><para>2 GB</para></entry>
              <entry><para>4 GB</para></entry>
              <entry><para>The Java web front end benefits from lots of available memory.</para></entry>
            </row>
            <row>
              <entry><para>Disk</para></entry>
              <entry><para>5400 RPM IDE</para></entry>
              <entry><para>7200 RPM SATA</para></entry>
              <entry><para>Slower disks will work, but will yield much longer instance startup times.</para></entry>
            </row>
            <row>
              <entry><para>Disk Space</para></entry>
              <entry><para>40 GB</para></entry>
              <entry><para>200 GB</para></entry>
              <entry><para>40GB is only enough space for only a single image, cache, etc., Eucalyptus does not like to run out of disk space.</para></entry>
            </row>
            <row>
              <entry><para>Networking</para></entry>
              <entry><para>100 Mbps</para></entry>
              <entry><para>1000 Mbps</para></entry>
              <entry><para>Machine images are hundreds of MB, and need to be copied over the network to nodes.</para></entry>
            </row>
          </tbody>
          </tgroup>
        </table>

      </sect3>
            <sect3 id="uec-node-requirements" status="review">
        <title>Node Requirements</title>
 
        <para>
        The other system(s) are <emphasis>nodes</emphasis>, which will run::
        </para>

        <itemizedlist>
          <listitem><para>the Node Controller (NC)</para></listitem>
        </itemizedlist>

        <table>
          <title>UEC Node Requirements</title>
          <tgroup cols="4" rowsep="1">
          <colspec colname="1"/>
          <colspec colname="2"/>
          <colspec colname="3"/>
          <colspec colname="4"/>
          <thead>
            <row>
              <entry morerows="1" valign="middle"><para>Hardware</para></entry>
              <entry morerows="1" valign="middle"><para>Minimum</para></entry>
              <entry morerows="1" valign="middle"><para>Suggested</para></entry>
              <entry morerows="1" valign="middle"><para>Notes</para></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><para>CPU</para></entry>
              <entry><para>VT Extensions</para></entry>
              <entry><para>VT, 64-bit, Multicore</para></entry>
              <entry><para>64-bit can run both i386, and amd64 instances; by default, Eucalyptus will only run 1 VM per CPU core on a Node.</para></entry>
            </row>
            <row>
              <entry><para>Memory</para></entry>
              <entry><para>1 GB</para></entry>
              <entry><para>4 GB</para></entry>
              <entry><para>Additional memory means more, and larger guests.</para></entry>
            </row>
            <row>
              <entry><para>Disk</para></entry>
              <entry><para>5400 RPM IDE</para></entry>
              <entry><para>7200 RPM SATA or SCSI</para></entry>
              <entry><para>Eucalyptus nodes are disk-intensive; I/O wait will likely be the performance bottleneck.</para></entry>
            </row>
            <row>
              <entry><para>Disk Space</para></entry>
              <entry><para>40 GB</para></entry>
              <entry><para>100 GB</para></entry>
              <entry><para>Images will be cached locally, Eucalyptus does not like to run out of disk space.</para></entry>
            </row>
            <row>
              <entry><para>Networking</para></entry>
              <entry><para>100 Mbps</para></entry>
              <entry><para>1000 Mbps</para></entry>
              <entry><para>Machine images are hundreds of MB, and need to be copied over the network to nodes.</para></entry>
            </row>
          </tbody>
          </tgroup>
        </table>

      </sect3>

    </sect2>
    <sect2 id="uec-frontend-installation" status="review">
      <title>Installing the Cloud/Cluster/Storage/Walrus Front End Server</title>
      
      <procedure>
        <step>
          <para>
          Download the Ubuntu &distro-rev; Server ISO file, and burn it to a CD.
          </para>
        </step>
        <step>
          <para>
          When you boot, select <emphasis>“Install Ubuntu Enterprise Cloud”</emphasis>.   The installer will detect if any other Eucalyptus components are present. 
          </para>
        </step>
        <step>
          <para>
          You can then choose which components to install, based on your chosen <ulink url="https://help.ubuntu.com/community/UEC/Topologies">topology</ulink>.
          </para>
        </step>
        <step>
          <para>
          When asked whether you want a <emphasis>“Cluster”</emphasis> or a <emphasis>“Node”</emphasis> install, select
          <emphasis>“Cluster”</emphasis>.
          </para>
        </step>
        <step>
          <para>
          It will ask two other cloud-specific questions during the course of the install:
          </para>
          <itemizedlist>
            <listitem>
              <para>
              Name of your cluster.
              </para>
              <itemizedlist><listitem><para>e.g. <emphasis>cluster1</emphasis>.</para></listitem></itemizedlist>
            </listitem>
            <listitem>
              <para>
              A range of public IP addresses on the LAN that the cloud can allocate to instances.
              </para>
              <itemizedlist><listitem><para>e.g. <emphasis>192.168.1.200-192.168.1.249</emphasis>.</para></listitem></itemizedlist>
              </listitem>
          </itemizedlist>
        </step>
      </procedure>

    </sect2>
    <sect2 id="uec-node-installation" status="review">
      <title>Installing the Node Controller(s)</title>

      <para>
      The node controller install is even simpler. Just make sure that you are connected to the network on which the cloud/cluster controller is already running.
      </para>
      
      <procedure>
        <step>
          <para>
          Boot from the same ISO on the node(s).
          </para>
        </step>
        <step>
          <para>
          When you boot, select <emphasis>“Install Ubuntu Enterprise Cloud”</emphasis>. 
          </para>
        </step>
        <step>
          <para>
          Select <emphasis>“Install Ubuntu Enterprise Cloud”</emphasis>.
          </para>
        </step>
        <step>
          <para>
          It should detect the Cluster and preselect <emphasis>“Node”</emphasis> install for you.
          </para>
        </step>
        <step>
          <para>
          Confirm the partitioning scheme.
          </para>
        </step>
        <step>
          <para>
          The rest of the installation should proceed uninterrupted; complete the installation and reboot the node.
          </para>
        </step>
      </procedure>

    </sect2>
    <sect2 id="uec-register-nodes" status="review">
      <title>Register the Node(s)</title>
 
      <procedure>
        <step>

      <para>
      Nodes are the physical systems within <application>UEC</application> that actually run the virtual machine instances of the cloud.
      </para>

      <para>
      All component registration should be automatic, assuming:
      </para>

      <orderedlist numeration="loweralpha">
        <listitem>
          <para>
         Public SSH keys have been exchanged properly.
          </para>
        </listitem>
        <listitem>
          <para>
         The services are configured properly.
          </para>
        </listitem>
        <listitem>
          <para>
          The appropriate <emphasis>uec-component-listener</emphasis> is running.
          </para>
        </listitem>
        <listitem>
          <para>
          Verify Registration.
          </para>
        </listitem>
      </orderedlist>

      <para>
      Steps a to e should only be required if you're using the <ulink url="https://help.ubuntu.com/community/UEC/PackageInstall">UEC/PackageInstall</ulink> method. 
      Otherwise, if you are following this guide, these steps should already be completed automatically for you, and therefore you can skip <emphasis>"a"</emphasis>
      to <emphasis>"e"</emphasis>.
      </para>

     </step>
     <step>
       <para>Exchange Public Keys</para>

        <para>
        The Cloud Controller's <emphasis>eucalyptus</emphasis> user needs to have SSH access to the Walrus Controller, Cluster Controller, and Storage Controller 
        as the eucalyptus user.
        </para> 

        <para>
        Install the Cloud Controller's <emphasis>eucalyptus</emphasis> user's public ssh key by:
        </para> 

        <itemizedlist>
          <listitem>
            <para>
           On the target controller, temporarily set a password for the eucalyptus user:
            </para>
<screen>
<command>sudo passwd eucalyptus</command>
</screen>
          </listitem>
          <listitem>
            <para>
           Then, on the Cloud Controller:
            </para>
<screen>
<command>sudo -u eucalyptus ssh-copy-id -i ~eucalyptus/.ssh/id_rsa.pub eucalyptus@&lt;IP_OF_NODE&gt;</command>
</screen>
          </listitem>
          <listitem>
            <para>
           You can now remove the password of the eucalyptus account on the target controller, if you wish:
            </para>
<screen>
<command>sudo passwd -d eucalyptus</command>
</screen>
          </listitem>
        </itemizedlist>

      </step>
      <step>
        <para>Configuring the Services</para>
        
        <para>
        On the <emphasis>Cloud Controller</emphasis>:
        </para>

        <itemizedlist>
          <listitem>
            <para>
            For the <emphasis>Cluster Controller</emphasis> Registration:
            </para>
            <itemizedlist>
              <listitem><para>Define the shell variable CC_NAME in <filename>/etc/eucalyptus/eucalyptus-cc.conf</filename></para></listitem>
              <listitem>
                <para>
                Define the shell variable CC_IP_ADDR in <filename>/etc/eucalyptus/eucalyptus-ipaddr.conf</filename>, as a space separated list of one or more IP addresses.
                </para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>
            For the <emphasis>Walrus Controller</emphasis> Registration:
            </para>
            <itemizedlist>
              <listitem><para>Define the shell variable WALRUS_IP_ADDR in <filename>/etc/eucalyptus/eucalyptus-ipaddr.conf</filename>, as a single IP address.</para></listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>
        On the <emphasis>Cluster Controller</emphasis>:
        </para>

        <itemizedlist>
          <listitem>
            <para>
            For <emphasis>Storage Controller</emphasis> Registration:
            </para>
            <itemizedlist>
              <listitem><para>Define the shell variable CC_NAME in <filename>/etc/eucalyptus/eucalyptus-cc.conf</filename></para></listitem>
              <listitem>
                <para>
                Define the shell variable SC_IP_ADDR in <filename>/etc/eucalyptus/eucalyptus-ipaddr.conf</filename>, as a space separated list of one or more IP addresses.
                </para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

      </step>
      <step>
        <para>Publish</para>

        <para>
        Now start the publication services.
        </para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Walrus Controller:</emphasis></para> 
<screen>
<command>sudo start eucalyptus-walrus-publication</command>
</screen>
          </listitem>
          <listitem>
            <para><emphasis>Cluster Controller:</emphasis></para> 
<screen>
<command>sudo start eucalyptus-cc-publication</command>
</screen>
          </listitem>
          <listitem>
            <para><emphasis>Storage Controller:</emphasis></para> 
<screen>
<command>sudo start eucalyptus-sc-publication</command>
</screen>
          </listitem>
          <listitem>
            <para><emphasis>Node Controller:</emphasis></para> 
<screen>
<command>sudo start eucalyptus-nc-publication</command>
</screen>
          </listitem>
        </itemizedlist>

      </step>
      <step>
        <para>Start the Listener</para>

        <para>
       On the <emphasis>Cloud Controller</emphasis> and the <emphasis>Cluster Controller(s)</emphasis>, run:
        </para>

<screen>
<command>sudo start uec-component-listener</command>
</screen>
 
      </step>
      <step>
        <para>Verify Registration</para>

<screen>
<command>cat /var/log/eucalyptus/registration.log</command>
<computeroutput>2010-04-08 15:46:36-05:00 | 24243 -> Calling node cluster1 node 10.1.1.75
2010-04-08 15:46:36-05:00 | 24243 -> euca_conf --register-nodes returned 0
2010-04-08 15:48:47-05:00 | 25858 -> Calling walrus Walrus 10.1.1.71
2010-04-08 15:48:51-05:00 | 25858 -> euca_conf --register-walrus returned 0
2010-04-08 15:49:04-05:00 | 26237 -> Calling cluster cluster1 10.1.1.71
2010-04-08 15:49:08-05:00 | 26237 -> euca_conf --register-cluster returned 0
2010-04-08 15:49:17-05:00 | 26644 -> Calling storage cluster1 storage 10.1.1.71
2010-04-08 15:49:18-05:00 | 26644 -> euca_conf --register-sc returned 0</computeroutput>
</screen>

        <note>
          <para>
          The output on your machine will vary from the example above.
          </para>
        </note>
 
      </step>
      </procedure>  

    </sect2>
    <sect2 id="uec-obtain-credentials" status="review">
      <title>Obtain Credentials</title>

      <para>
      After installing and booting the <emphasis>Cloud Controller</emphasis>, users of the cloud will need to retrieve their credentials. 
      This can be done either through a web browser, or at the command line.
      </para>

      <sect3 id="uec-creds-browser" status="review">
        <title>From a Web Browser</title>

        <procedure>
          <step>
            <para>
            From your web browser (either remotely or on your Ubuntu server) access the following URL:
            </para>
<programlisting>
https://&lt;cloud-controller-ip-address&gt;:8443/
</programlisting>

            <warning>
              <para>
              You must use a secure connection, so make sure you use "https" not "http" in your URL. You will get a security 
              certificate warning. You will have to add an exception to view the page. If you do not accept it you will not 
              be able to view the Eucalyptus configuration page. 
              </para>
            </warning>
          </step>
          <step>
            <para>
            Use username <emphasis>'admin'</emphasis> and password <emphasis>'admin'</emphasis> for the first time login 
            (you will be prompted to change your password).
            </para>
          </step>
          <step>
            <para>
            Then follow the on-screen instructions to update the admin password and email address.
            </para>
          </step>
          <step>
            <para>
            Once the first time configuration process is completed, click the <emphasis>'credentials'</emphasis> tab 
            located in the top-left portion of the screen. 
            </para>
          </step>
          <step>
            <para>
            Click the <emphasis>'Download Credentials'</emphasis> button to get your certificates.
            </para>
          </step>
          <step>
            <para>
            Save them to <filename>~/.euca</filename>.
            </para>
          </step>
          <step>
            <para>
            Unzip the downloaded zip file into a safe location (<filename>~/.euca</filename>).
            </para>
<screen>
<command>unzip -d ~/.euca mycreds.zip</command>
</screen>
          </step>
        </procedure>

      </sect3>
      <sect3 id="uec-creds-cli" status="review">
        <title>From a Command Line</title>

        <procedure>
          <step>
            <para>
            Alternatively, if you are on the command line of the <emphasis>Cloud Controller</emphasis>, you can run:
            </para>
<screen>
<command>mkdir -p ~/.euca</command>
<command>chmod 700 ~/.euca</command>
<command>cd ~/.euca</command>
<command>sudo euca_conf --get-credentials mycreds.zip</command>
<command>unzip mycreds.zip</command>
<command>ln -s ~/.euca/eucarc ~/.eucarc</command>
<command>cd -</command>
</screen>
          </step>
        </procedure>

      </sect3>
      <sect3 id="uec-creds-usage" status="review">
        <title>Extracting and Using Your Credentials</title>

        <para>
        Now you will need to setup EC2 API and AMI tools on your server using X.509 certificates.
        </para>

        <procedure>
          <step>
            <para>
            Install the required cloud user tools:
            </para>
<screen>
<command>sudo apt-get install euca2ools</command>
</screen>
          </step>
          <step>
            <para>
            To validate that everything is working correctly, get the local cluster availability details:
            </para>
<screen>
<command>. ~/.euca/eucarc</command>
<command>euca-describe-availability-zones verbose</command>
<computeroutput>AVAILABILITYZONE   myowncloud                 192.168.1.1
AVAILABILITYZONE   |- vm types                free / max   cpu   ram  disk
AVAILABILITYZONE   |- m1.small                0004 / 0004   1    128     2
AVAILABILITYZONE   |- c1.medium               0004 / 0004   1    256     5
AVAILABILITYZONE   |- m1.large                0002 / 0002   2    512    10
AVAILABILITYZONE   |- m1.xlarge               0002 / 0002   2   1024    20
AVAILABILITYZONE   |- c1.xlarge               0001 / 0001   4   2048    20</computeroutput>
</screen>

            <note>
              <para>
              Your output from the above command will vary.
              </para>
            </note>
          </step>
        </procedure>

      </sect3>
    </sect2>
    <sect2 id="uec-image-installation" status="review">
      <title>Install an Image from the Store</title>

      <para>
      The following is by far the simplest way to install an image. However, advanced users may be interested in learning how to 
      <ulink url="https://help.ubuntu.com/community/UEC/BundlingImages">Bundle their own image</ulink>.
      </para>

      <para>
      The simplest way to add an image to <application>UEC</application> is to install it from the Image Store on the UEC web interface.
      </para>

      <procedure>
        <step>
          <para>
          Access the web interface at the following URL (Make sure you specify https):
          </para>
<programlisting>
https://&lt;cloud-controller-ip-address&gt;:8443/
</programlisting>
        </step>
        <step>
          <para>
          Enter your login and password (if requested, as you may still be logged in from earlier).
          </para>
        </step>
        <step>
          <para>
          Click on the <emphasis>Store</emphasis> tab.
          </para>
        </step>
        <step>
          <para>
          Browse available images.
          </para>
        </step>
        <step>
          <para>
          Click on <emphasis>install</emphasis> for the image you want.
          </para>
        </step>
      </procedure>

      <para>
      Once the image has been downloaded and installed, you can click on <emphasis>"How to run?"</emphasis> that will be displayed
      below the image button to view the command to execute to instantiate (start) this image. The image will also appear on the 
      list given on the <emphasis>Image</emphasis> tab.
      </para>

    </sect2>
    <sect2 id="uec-image-running" status="review">
      <title>Run an Image</title>

      <para>
      There are multiple ways to instantiate an image in UEC:
      </para>

      <itemizedlist>
        <listitem><para>Use the command line.</para></listitem>
        <listitem><para>Use one of the UEC compatible management tools such as <emphasis>Landscape</emphasis>.</para></listitem>
        <listitem>
          <para>
          Use the <ulink url="https://help.ubuntu.com/community/UEC/ElasticFox">ElasticFox</ulink> extension to Firefox.
          </para>
        </listitem>
      </itemizedlist>

      <para>
      Here we will describe the process from the command line:
      </para>

      <procedure>
        <step>
          <para>
          Before running an instance of your image, you should first create a <emphasis>keypair</emphasis> (ssh key) that you can 
          use to log into your instance as root, once it boots. The key is stored, so you will only have to do this once. 
          </para>
          <para>
          Run the following command:
          </para>
<programlisting>
if [ ! -e ~/.euca/mykey.priv ]; then
    mkdir -p -m 700 ~/.euca
    touch ~/.euca/mykey.priv
    chmod 0600 ~/.euca/mykey.priv
    euca-add-keypair mykey > ~/.euca/mykey.priv
fi
</programlisting>
          <note>
            <para>
            You can call your key whatever you like (in this example, the key is called <emphasis>'mykey'</emphasis>), but remember what it is called. 
            If you forget, you can always run <command>euca-describe-keypairs</command> to get a list of created keys stored in the system.
            </para>
          </note>
        </step>
        <step>
          <para>
          You must also allow access to port 22 in your instances:
          </para>
<screen>
<command>euca-authorize default -P tcp -p 22 -s 0.0.0.0/0</command>
</screen>
        </step>
        <step>
          <para>
          Next, you can create instances of your registered image:
          </para>
<screen>
<command>euca-run-instances $EMI -k mykey -t m1.small</command>
</screen>
          <note>
            <para>
             If you receive an error regarding <emphasis>image_id</emphasis>, you may find it by viewing Images page or click 
             <emphasis>"How to Run"</emphasis> on the <emphasis>Store</emphasis> page to see the sample command.
            </para>
          </note>
        </step>
        <step>
          <para>
          The first time you run an instance, the system will be setting up caches for the image from which it will be created.
          This can often take some time the first time an instance is run given that VM images are usually quite large.
          </para>
          <para> 
          To monitor the state of your instance, run:
          </para>
<screen>
<command>watch -n5 euca-describe-instances</command>
</screen>
          <para>
          In the output, you should see information about the instance, including its state. While first-time caching is being performed, 
          the instance's state will be <emphasis>'pending'</emphasis>.
          </para>
        </step>
        <step>
          <para>
          When the instance is fully started, the above state will become <emphasis>'running'</emphasis>. Look at the IP address assigned 
          to your instance in the output, then connect to it:
          </para>
<screen>
<command>IPADDR=$(euca-describe-instances | grep $EMI | grep running | tail -n1 | awk '{print $4}')</command>
<command>ssh -i ~/.euca/mykey.priv ubuntu@$IPADDR</command>
</screen>
        </step>
        <step>
          <para>
          And when you are done with this instance, exit your SSH connection, then terminate your instance:
          </para>
<screen>
<command>INSTANCEID=$(euca-describe-instances | grep $EMI | grep running | tail -n1 | awk '{print $2}')</command>
<command>euca-terminate-instances $INSTANCEID</command>
</screen>
        </step>
      </procedure>

      <sect3 id="uec-first-boot" status="review">
        <title>First Boot</title>

        <para>
       The <application>cloud-init</application> package provides "first boot" functionality for the Ubuntu UEC images. 
       It is in charge of taking the generic filesystem image that is booting and customizing it for this particular instance.
       That includes things like:
        </para>

        <itemizedlist>
          <listitem>
            <para>
            Setting the hostname.
            </para>
          </listitem>
          <listitem>
            <para>
            Putting the provided ssh public keys into <filename>~ubuntu/.ssh/authorized_keys</filename>.
            </para>
          </listitem>
          <listitem>
            <para>
            Running a user provided script, or otherwise modifying the image.
            </para>
          </listitem>
        </itemizedlist>

        <para>
        Setting hostname and configuring a system so the person who launched it can actually log into it are not terribly interesting. 
        The interesting things that can be done with <application>cloud-init</application> are made possible by data provided at launch 
        time called <ulink url="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=1085">user-data</ulink>.
         </para>

         <para>
         First, install the <application>cloud-init</application> package:
         </para>

<screen>
<command>sudo apt-get install cloud-init</command>
</screen>

         <para>
         If the user-data starts with <emphasis>'#!'</emphasis>, then it will be stored and executed as root late in the boot process of the 
         instance's first boot (similar to a traditional 'rc.local' script). Output from the script is directed to the console. 
         </para>

         <para>
        For example, create a file named <filename>ud.txt</filename> containing:
         </para>

<programlisting>
#!/bin/sh
echo ========== Hello World: $(date) ==========
echo "I have been up for $(cut -d\  -f 1 &lt; /proc/uptime) sec"
</programlisting>

          <para>
         Now start an instance with the <emphasis>--user-data-file</emphasis> option:
          </para>

<screen>
<command>euca-run-instances $EMI -k mykey -t m1.small  --user-data-file=ud.txt</command>
</screen>

           <para>
           Wait now for the system to come up and console to be available.  To see the result of the data file commands enter:
           </para>

<screen>
<command>euca-get-console-output $EMI | grep --after-context=1 Hello</command>
<computeroutput>========== Hello World: Mon Mar 29 18:05:05 UTC 2010 ==========
I have been up for 28.26 sec</computeroutput>
</screen>

        <note>
          <para>
          Your output may vary.
          </para>
        </note>

        <para>
        The simple approach shown above gives a great deal of power.  The user-data can contain a script in any language where an interpreter already exists
        in the image (#!/bin/sh, #!/usr/bin/python, #!/usr/bin/perl, #!/usr/bin/awk ... ).
        </para>

        <para>
       For many cases, the user may not be interested in writing a program.  For this case, cloud-init provides <emphasis>"cloud-config"</emphasis>, a configuration based approach
       towards customization.  To utilize the cloud-config syntax, the supplied user-data must start with a <emphasis>'#cloud-config'</emphasis>. 
        </para>

        <para>
        For example, create a text file named <filename>clout-config.txt</filename> containing:
        </para>

<programlisting>
#cloud-config
apt_upgrade: true
apt_sources:
- source: "ppa:ubuntu-server-edgers/server-edgers-apache "

packages:
- build-essential
- pastebinit

runcmd:
- echo ======= Hello World =====
- echo "I have been up for $(cut -d\  -f 1 &lt; /proc/uptime) sec"
</programlisting>

       <para>
      Create a new instance:
       </para>

<screen>
<command>euca-run-instances $EMI -k mykey -t m1.small --user-data-file=cloud-config.txt</command>
</screen>

        <para>
        Now, when the above system is booted, it will have: 
        </para> 

        <itemizedlist>
          <listitem><para>Added the Apache Edgers PPA.</para></listitem>
          <listitem><para>Run an upgrade to get all updates available</para></listitem>
          <listitem><para>Installed the 'build-essential' and 'pastebinit' packages</para></listitem>
          <listitem><para>Printed a similar message to the script above</para></listitem>
        </itemizedlist>

        <warning>
          <para>
          The <emphasis>Apache Edgers PPA</emphasis>, in the above example, contains the latest version of Apache from upstream source repositories.
          Package versions in the PPA are unsupported, and depending on your situation, this may or may not be desirable.  See  the 
          <ulink url="https://launchpad.net/~ubuntu-server-edgers">Ubuntu Server Edgers</ulink> web page for more details.
          </para>
        </warning>

        <para>
       The <emphasis>'runcmd'</emphasis> commands are run at the same point in boot that the <emphasis>'#!'</emphasis> script would run in the previous example. 
       It is present to allow you to get the full power of a scripting language if you need it without abandoning <emphasis>cloud-config</emphasis>.
        </para>

       <para>
       For more information on what kinds of things can be done with <application>cloud-config</application>, see
       <ulink url="http://bazaar.launchpad.net/~cloud-init-dev/cloud-init/trunk/files/head:/doc/examples/">doc/examples</ulink> in the source.
       </para>

      </sect3>

    </sect2>
    <sect2 id="uec-more-info" status="review">
      <title>More Information</title>

      <para>
      How to use the <ulink url="https://help.ubuntu.com/community/UEC/StorageController">Storage Controller</ulink>
      </para>

      <para>
      Controlling eucalyptus services:
      </para>

      <itemizedlist>
        <listitem><para>sudo service eucalyptus [start|stop|restart] (on the CLC/CC/SC/Walrus side)</para></listitem>
        <listitem><para>sudo service eucalyptus-nc [start|stop|restart] (on the Node side)</para></listitem>
      </itemizedlist>

      <para>
      Locations of some important files:
      </para>

      <itemizedlist>
        <listitem>
          <para>
          <emphasis>Log files:</emphasis>
          </para>
          <itemizedlist>
            <listitem><para>/var/log/eucalyptus</para></listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
          <emphasis>Configuration files:</emphasis>
          </para>
          <itemizedlist>
            <listitem><para>/etc/eucalyptus</para></listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
          <emphasis>Database:</emphasis>
          </para>
          <itemizedlist>
            <listitem><para>/var/lib/eucalyptus/db</para></listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
          <emphasis>Keys:</emphasis>
          </para>
          <itemizedlist>
            <listitem><para>/var/lib/eucalyptus</para></listitem>
            <listitem><para>/var/lib/eucalyptus/.ssh</para></listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <note>
        <para>
        Don't forget to source your <filename>~/.euca/eucarc</filename> before running the client tools. 
        </para>
      </note>

    </sect2>
    <sect2 id="uec-references" status="review">
      <title>References</title>

      <itemizedlist>
        <listitem>
          <para>
          For information on loading instances see the <ulink url="https://help.ubuntu.com/community/Eucalyptus">Eucalyptus Wiki</ulink> page.
          </para>
        </listitem>
        <listitem>
          <para>
          <ulink url="http://open.eucalyptus.com/">Eucalyptus Project Site (forums, documentation, downloads)</ulink>.
          </para>
        </listitem>
        <listitem>
          <para>
          <ulink url="https://launchpad.net/eucalyptus/">Eucalyptus on Launchpad (bugs, code)</ulink>.
          </para>
        </listitem>
        <listitem>
          <para>
          <ulink url="http://open.eucalyptus.com/wiki/EucalyptusTroubleshooting_v1.5">Eucalyptus Troubleshooting (1.5)</ulink>.
          </para>
        </listitem>
        <listitem>
          <para>
          <ulink url="http://support.rightscale.com/2._References/02-Cloud_Infrastructures/Eucalyptus/03-Administration_Guide/Register_with_RightScale">
          Register your cloud with RightScale</ulink>.
          </para>
        </listitem>
        <listitem>
          <para>
          You can also find help in the <emphasis>#ubuntu-virt</emphasis>, <emphasis>#eucalyptus</emphasis>, and 
          <emphasis>#ubuntu-server</emphasis> IRC channels on <ulink url="http://freenode.net">Freenode</ulink>.
          </para>
        </listitem>
      </itemizedlist>
      
    </sect2>
    <sect2 id="uec-glossary" status="review">
      <title>Glossary</title>

      <para>
      The Ubuntu Enterprise Cloud documentation uses terminology that might be unfamiliar to some readers. 
      This page is intended to provide a glossary of such terms and acronyms.
      </para>

      <itemizedlist>
        <listitem>
          <para>
          <emphasis>Cloud</emphasis> - A federated set of physical machines that offer computing resources through virtual machines,
          provisioned and recollected dynamically.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>Cloud Controller (CLC)</emphasis> - Eucalyptus component that provides the web UI (an https server on port 8443), 
          and implements the Amazon EC2 API. There should be only one Cloud Controller in an installation of UEC. This service is 
          provided by the Ubuntu <application>eucalyptus-cloud</application> package.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>Cluster</emphasis> - A collection of nodes, associated with a Cluster Controller. There can be more than one 
          Cluster in an installation of UEC. Clusters are sometimes physically separate sets of nodes. (e.g. floor1, floor2, floor2).
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>Cluster Controller (CC)</emphasis> - Eucalyptus component that manages collections of node resources. 
          This service is provided by the Ubuntu <application>eucalyptus-cc</application> package.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>EBS</emphasis> - Elastic Block Storage.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>EC2</emphasis> - Elastic Compute Cloud. Amazon's pay-by-the-hour, pay-by-the-gigabyte public cloud computing offering.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>EKI</emphasis> - Eucalyptus Kernel Image.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>EMI</emphasis> - Eucalyptus Machine Image.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>ERI</emphasis> - Eucalyptus Ramdisk Image.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>Eucalyptus</emphasis> - Elastic Utility Computing Architecture for Linking Your Programs To Useful Systems. 
          An open source project originally from the University of California at Santa Barbara, now supported by Eucalyptus Systems, 
          a Canonical Partner.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>Front-end</emphasis> - Physical machine hosting one (or more) of the high level Eucalyptus components (cloud, 
          walrus, storage controller, cluster controller).
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>Node</emphasis> - A node is a physical machine that's capable of running virtual machines, running a node controller.
          Within Ubuntu, this generally means that the CPU has VT extensions, and can run the KVM hypervisor.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>Node Controller (NC)</emphasis> - Eucalyptus component that runs on nodes which host the virtual machines that comprise
          the cloud. This service is provided by the Ubuntu package <application>eucalyptus-nc</application>.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>S3</emphasis> - Simple Storage Service. Amazon's pay-by-the-gigabyte persistent storage solution for EC2.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>Storage Controller (SC)</emphasis> - Eucalyptus component that manages dynamic block storage services (EBS). 
          Each 'cluster' in a Eucalyptus installation can have its own Storage Controller. This component is provided by the 
          <application>eucalyptus-sc</application> package.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>UEC</emphasis> - Ubuntu Enterprise Cloud. Ubuntu's cloud computing solution, based on Eucalyptus.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>VM</emphasis> - Virtual Machine.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>VT</emphasis> - Virtualization Technology. An optional feature of some modern CPUs, allowing for accelerated virtual machine hosting.
          </para>
        </listitem>
        <listitem>
          <para>
          <emphasis>Walrus</emphasis> - Eucalyptus component that implements the Amazon S3 API, used for storing VM images and user storage using 
          S3 bucket put/get abstractions.
          </para>
        </listitem>
      </itemizedlist>

    </sect2>
  </sect1>  
</chapter>
